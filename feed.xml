<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Eric Han&#39;s IT Blog</title>
  
  <subtitle>Eric Han&#39;s IT Blog</subtitle>
  <link href="https://futurecreator.github.io/feed.xml" rel="self"/>
  
  <link href="https://futurecreator.github.io/"/>
  <updated>2025-03-14T16:10:24.278Z</updated>
  <id>https://futurecreator.github.io/</id>
  
  <author>
    <name>Eric Han</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>서버리스 Serverless 아키텍처 파헤치기</title>
    <link href="https://futurecreator.github.io/2019/03/14/serverless-architecture/"/>
    <id>https://futurecreator.github.io/2019/03/14/serverless-architecture/</id>
    <published>2019-03-13T15:38:26.000Z</published>
    <updated>2025-03-14T16:10:24.278Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>서버리스(Serverless)하면 대부분 AWS Lambda 를 떠올리곤 합니다. 하지만 서버리스는 단순히 FaaS(Function-as-a-Service)만을 의미하지는 않습니다. 이번 포스트에서는 서버리스 아키텍처에 대한 개념과 키워드를 정리하고, FaaS 의 내부 구조를 살펴봅니다.</p><h2 id="Serverless">Serverless</h2><p>서버리스는 말 그대로 ‘서버(Server)가 없다(-less)’는 뜻입니다. 그래서 처음 접했을 때 물리적인 서버가 아예 없고 클라이언트에서 모든 것을 처리하는 구조로 보이기도 합니다. 하지만 실제로 서버가 없는 구조는 아니고, 서버에서 처리하는 작업을 클라우드 기반의 서비스로 처리해서 서버 구축 및 관리 비용을 줄이는 구조입니다. 따라서 개발 기간과 비용을 단축할 수 있을 뿐 아니라, 서버 운영과 유지 보수의 어려움을 크게 줄일 수 있습니다.</p><p>서버리스는 두 가지 개념으로 나눌 수 있습니다.</p><ul><li>서비스형 서버리스(Serviceful Serverless)</li><li>FaaS(Functions as a Service)</li></ul><p>두 가지 모두 서비스 형태로 무언가를 제공한다는 의미인데요. 여기서 ‘서비스’라는 의미는 소유하지 않고 사용한 만큼만 비용을 지불한다는 의미입니다. 렌트카가 좋은 예입니다. 차를 구매하지 않아도 사용할 수 있고, 사용한만큼만 비용을 지불하니까요.</p><p>그럼 이 두 영역을 좀 더 자세하게 알아봅시다.</p><h3 id="Serviceful-Serverless">Serviceful Serverless</h3><p><img src="firebase.png" alt="모바일 백엔드에 기능을 서비스 형태로 제공하는 Google Firebase"></p><p>클라이언트의 사양이 좋아지고 각종 프레임워크가 발전하면서 많은 로직을 클라이언트에서 자체적으로 처리하게 되었습니다. 자연스럽게 서버의 역할은 줄어들었고, 서버에서 처리하는 작업은 단순해졌습니다.</p><p>서비스형 서버리스는 직접 서버를 구축하고 프로비저닝하고 관리할 필요 없이, 서버의 역할을 서비스 형태로 사용하는 것을 의미합니다. 예를 들어 인증의 경우, 매번 새로 구축해야 하지만 <a href="https://auth0.com/">Auth0</a> 이나 <a href="https://aws.amazon.com/ko/cognito/">Amazon Cognito</a> 와 같은 인증 서비스를 사용하면 대부분의 구현을 대체할 수 있습니다.</p><p>특히 <a href="https://aws.amazon.com/ko/">Amazon Web Service</a> 나 <a href="https://cloud.google.com/">Google Cloud Platform</a> 같은 Public Cloud 는 많은 종류의 서비스를 제공하고 있습니다. 단순히 컴퓨팅 리소스, 스토리지, 네트워크 뿐 아니라 머신 러닝과 모바일 백엔드, 머신 러닝, 블록체인, IoT, 그리고 인공위성 제어까지. 데이터베이스와 파일 스토리지, 메시징 서비스도 빼놓을 수 없죠. 이러한 기능을 복잡한 인프라 구성 없이  간편하게 사용할 수 있습니다.</p><h3 id="FaaS">FaaS</h3><p>FaaS(Function-as-a-Service)는 함수를 서비스로 제공하는 형태입니다. 개발자는 로직이 담긴 함수 구현만 신경쓰면 됩니다.</p><p>함수(코드)를 실행하기 위해 서버를 올리고 런타임을 구성하고 코드를 배포해서 실행해야 하는 일련의 과정을 없애고, 사용자가 원하는 로직을 함수로 작성만 해놓으면 (특정 조건 하에) 함수가 실행됩니다. 좀 더 구체적으로는 함수가 호출되면 VM(또는 컨테이너)가 실행되고 해당 런타임 내에서 정의해놓은 함수가 실행됩니다. 실행 후 VM(또는 컨테이너)는 종료됩니다.</p><p>이러한 함수는 서버가 계속 대기하면서 사용자의 요청을 처리하는 것이 아니라, 이벤트가 있을 때마다 실행되는 작은 코드입니다. 따라서 주요 서비스 사이에서 간단한 작업을 처리하는 용도로 쓰이고, FaaS 는 앞서 알아본 서비스형 애플리케이션과 결합해 시너지 효과를 낼 수 있습니다.</p><p><img src="https://d1.awsstatic.com/product-marketing/Lambda/Diagrams/product-page-diagram_Lambda-RealTimeFileProcessing.a59577de4b6471674a540b878b0b684e0249a18c.png" alt="AWS Lambda 이미지 처리 예제"></p><p>대표적인 FaaS 는 <a href="https://aws.amazon.com/ko/lambda/?nc2=h_m1">AWS Lambda</a> 로 AWS 의 각종 서비스와 쉽게 연동됩니다. 예를 들어 사용자가 이미지를 업로드하면 해당 이미지를 해상도별로 처리해서 S3 에 저장하는 로직을 함수로 구현할 수 있습니다. 이외에도 Lambda 홈페이지에서 다양한 사례를 찾아볼 수 있습니다.</p><p>요청이 많으면 알아서 확장도 해주니 서버에 대해 신경쓸 필요가 없습니다. 비용은 함수가 실행되는 시간과 호출된 회수만큼만 지불합니다. 서버를 띄워놓았다면 요청이 없어도 비용을 지불하겠지만 람다는 요청이 없으면 비용도 지불하지 않습니다.</p><h2 id="AWS-Lambda">AWS Lambda</h2><p>FaaS 의 대표주자는 Lambda 입니다. 처음 Lambda 의 기본 개념은 간단했습니다. 그런데 서버리스의 활용도가 늘어나고 사람들의 관심이 많아지면서 AWS 는 서버리스 영역을 대폭 지원하고 있습니다.</p><table><thead><tr><th>항목</th><th>설명</th></tr></thead><tbody><tr><td>IDE</td><td>Lambda 개발 플러그인 제공 (Eclipse, Intellij, Visual Studio Code, etc.)</td></tr><tr><td>Custom Runtime 지원</td><td>미지원 언어의 경우 직접 런타임을 구성할 수 있도록 지원 (e.g., Ruby, Erlang, Cobol)</td></tr><tr><td>실행 시간</td><td>최대 15분의 실행 시간</td></tr><tr><td><a href="https://docs.aws.amazon.com/ko_kr/lambda/latest/dg/configuration-layers.html">Lambda Layers</a></td><td>공통 패키지 모듈 지원으로 코드가 가벼워지고 개발 생산성 향상</td></tr><tr><td><a href="https://aws.amazon.com/ko/step-functions/">AWS Step Functions</a></td><td>Lambda 함수를 단계적으로나 병렬적으로 실행할 수 있도록 워크플로우 구성</td></tr><tr><td><a href="https://firecracker-microvm.github.io/">Firecraker</a></td><td>서버리스 컴퓨팅에 최적화된 microVM 오픈소스</td></tr><tr><td><a href="https://aws.amazon.com/ko/serverless/serverlessrepo/">Serverless Application Repository</a></td><td>서버리스 애플리케이션을 공유하고 판매하는 마켓플레이스</td></tr></tbody></table><p>AWS Lambda 외에 주목할 만한 서비스도 있습니다.</p><ul><li><a href="https://cloud.google.com/knative/">Knative</a>: 쿠버네티스(Kubernetes) 기반의 서버리스 플랫폼</li><li><a href="https://nuclio.io/">Nuclio</a>: 직접 FaaS 를 제공할 수 있는 오픈 소스 서버리스 프레임워크</li></ul><h2 id="Serverless-Application">Serverless Application</h2><p>그렇다면 서버리스 애플리케이션이란 어떤 유형의 애플리케이션을 말할까요?</p><ul><li>클라이언트에서 사용자 인터랙션 로직을 대부분 처리</li><li>자주 사용하는 서버 기능은 서버리스형 서비스로 처리</li><li>각종 연계를 위해 사용하는 작은 함수(FaaS)</li></ul><p>먼저 클라이언트에서 사용자와 상호작용하는 로직을 대부분을 처리해서 서버의 역할을 줄입니다. 그리고 서버에서 제공하는 기능은 서버리스형 서비스를 적극 활용하고, 각 서비스 간 로직은 FaaS 를 이용해 구현합니다.</p><p>몇 가지 애플리케이션 형태에 따른 서버리스 아키텍처를 살펴보겠습니다. 여기서 사용한 모든 서비스는 AWS 의 서비스입니다.</p><h3 id="Web-Application">Web Application</h3><p><img src="web_application_architecture.png" alt="https://github.com/aws-samples/lambda-refarch-webapp"></p><p>먼저 일반적인 웹 애플리케이션을 서버리스 형태로 구성한 아키텍처입니다.</p><ul><li>사용자에게 보여줄 웹 페이지 및 정적 콘텐츠는 S3 에 저장 후 호스팅</li><li>사용자 요청은 API Gateway 로 받기</li><li>처리할 내용은 Lambda 에 작성</li><li>데이터 저장은 DB 서비스(DynamoDB) 사용</li><li>사용자 인증은 Amazon Cognito 사용</li><li>Route 53으로 도메인 구입 및 제공</li></ul><h3 id="Mobile-Backend">Mobile Backend</h3><p><img src="mobile-backend-architecture.png" alt="https://github.com/aws-samples/lambda-refarch-mobilebackend"></p><p>모바일 백엔드 아키텍처는 웹 애플리케이션과 비슷하지만 몇 가지 추가된 서비스가 있습니다.</p><ul><li>DynamoDB 에 저장하는 데이터는 람다를 이용해 검색엔진 서비스인 CloudSearch 에 저장합니다.</li><li>SNS(Simple Notification Service)를 이용해 사용자에게 푸시를 보냅니다.</li></ul><h3 id="Real-time-Stream-Processing">Real-time Stream Processing</h3><p><img src="realtime-stream-processing-architecture.png" alt="https://github.com/aws-samples/lambda-refarch-streamprocessing"></p><p>이번엔 실시간 스트림 데이터를 처리하는 아키텍처입니다.</p><ul><li>Kinesis 로 실시간 스트리밍 데이터를 수집합니다.</li><li>람다에서 들어오는 데이터를 처리하고 저장합니다.</li><li>이벤트 자체를 장기간 보존하기 위해 S3 에 저장합니다.</li><li>수집한 데이터는 CloudWatch 를 이용해 모니터링할 수 있습니다.</li></ul><p>이러한 아키텍처 외에도 서버리스 애플리케이션을 효과적으로 설계하기 위한 디자인 패턴이 있습니다. OOP 설계를 잘하기 위해 디자인 패턴이 있는 것처럼 말이죠. 이에 대해서는 다음 포스트에서 자세히 다뤄보도록 하겠습니다.</p><h2 id="vs-XaaS">vs. XaaS</h2><p>지금까지 서버리스에 대한 개념과 아키텍처에 대해 살펴봤습니다. 더 나아가기에 앞서, FaaS 라는 개념이 와닿지 않거나 기존 IaaS, PaaS 와는 어떻게 다른지 궁금하실 수 있습니다. 이런 서비스 형태를 통틀어 XaaS 라고 부르는데요, 피자에 비유해서 이해하기 쉽게 살펴보겠습니다. 바로 Pizza-as-a-Service 입니다.<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="http://www.paulkerrision.co.uk/">[1]</span></a></sup></p><p><img src="pizza-as-a-service.png" alt="Pizza as a Service"></p><ul><li><strong>홈메이드</strong>: 집에서 전기와 가스, 오븐부터 피자, 맥주, 친구까지 필요한 모든 것을 준비해야 합니다.</li><li><strong>공동 부엌</strong>: 돈을 내고 요리에 필요한 기구를 사용할 수 있는 공동 부엌입니다. 피자는 직접 만들어야 합니다.</li><li><strong>BYOP</strong>: 자기가 먹을 피자와 맥주를 직접 가져가는 Bring Your Own Plate 파티입니다.</li><li><strong>배달 주문</strong>: 피자를 시켜먹는 형태입니다. 맥주는 직접 시켜야 하고 친구들도 불러야 합니다.</li><li><strong>피자 매장</strong>: 친구들과 직접 매장에 가서 피자와 맥주를 사먹습니다.</li><li><strong>피자 파티</strong>: 모든 것이 준비되어 있습니다. 이미 친구들도 와있습니다. 그냥 즐기기만 하면 됩니다.</li></ul><p>이해하기 쉽게 먼저 비유를 살펴봤는데요, 이번엔 실제로 XaaS 를 비교해봅시다.</p><p><img src="xaas.png" alt="XaaS 비교"></p><ul><li><strong>Legacy</strong>: 기존 시스템은 인프라부터 소프트웨어까지 전부 구축하고 개발해야 합니다.</li><li><strong>Infrastructure-as-a-Service</strong>:필요한 하드웨어와 가상화, OS 등 인프라 요소를 서비스 형태로 제공합니다. 원하는 사양의 서버를 VM 으로 생성할 수 있습니다.</li><li><strong>Container-as-a-Service</strong>: 서비스 형태로 제공되는 컨테이너를 활용해 애플리케이션을 배포합니다.</li><li><strong>Platform-as-a-Service</strong>: 애플리케이션 개발에 집중할 수 있도록 인프라와 런타임 환경을 제공합니다.</li><li><strong>Function-as-a-Service</strong>: 실행할 함수 코드에만 집중할 수 있습니다.</li><li><strong>Software-as-a-Service</strong>: 제공되는 소프트웨어를 사용하는 형태입니다.</li></ul><p>여기서 유사하게 보이는 PaaS 와 FaaS 의  차이점은 다음과 같습니다.</p><ul><li>서버 유무: PaaS 는 그 플랫폼 위에 내 서버를 띄워야 하는 반면, FaaS 는 사용자가 관리할 서버가 없습니다.</li><li>확장: PaaS 는 확장이 서버 단위로, FaaS 는 함수 단위로 이루어집니다.</li><li>비용: PaaS 는 실행되는 서버 리소스의 스펙과 사용 시간에 따라 과금이 되고, FaaS 는 해당 함수의 호출 횟수와 수행 시간에 따라 과금됩니다.</li></ul><h2 id="Function-구성-요소">Function 구성 요소</h2><p>이번엔 함수의 기본적인 구성 요소를 살펴봅시다.</p><p>다음은 Python 으로 &quot;Hello from Lambda!&quot;를 출력하는 함수입니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">lambda_handler</span>(<span class="params">event, context</span>):</span><br><span class="line">    <span class="comment"># TODO implement</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="string">&#x27;statusCode&#x27;</span>: <span class="number">200</span>,</span><br><span class="line">        <span class="string">&#x27;body&#x27;</span>: json.dumps(<span class="string">&#x27;Hello from Lambda!&#x27;</span>)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>다음은 Ruby 로 만든 예제입니다.</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">require</span> <span class="string">&#x27;json&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">lambda_handler</span>(<span class="params"><span class="symbol">event:</span>, <span class="symbol">context:</span></span>)</span><br><span class="line">    <span class="comment"># TODO implement</span></span><br><span class="line">    &#123; <span class="symbol">statusCode:</span> <span class="number">200</span>, <span class="symbol">body:</span> <span class="variable constant_">JSON</span>.generate(<span class="string">&#x27;Hello from Lambda!&#x27;</span>) &#125;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>마지막으로 Node.js 런타임에서 동작하는 JavaScript 함수입니다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exports</span>.<span class="property">handler</span> = <span class="title function_">async</span> (event) =&gt; &#123;</span><br><span class="line">    <span class="comment">// TODO implement</span></span><br><span class="line">    <span class="keyword">const</span> response = &#123;</span><br><span class="line">        <span class="attr">statusCode</span>: <span class="number">200</span>,</span><br><span class="line">        <span class="attr">body</span>: <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(<span class="string">&#x27;Hello from Lambda!&#x27;</span>),</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>언어는 다르지만 모두 세 가지의 구성 요소로 이루어져 있다는 걸 알 수 있습니다.</p><ol><li>Handler 함수: 호출 시 실행되는 함수</li><li>Event 객체: 함수가 호출된 이벤트 정보를 담고 있는 객체</li><li>Context 객체: 해당 함수의 컨텍스트 정보(실행 관련 정보)를 담고 있는 객체</li></ol><h2 id="Function-내부-구조">Function 내부 구조</h2><p>FaaS 는 개념적으로 보면 다음과 같이 구성되어 있습니다.</p><p><img src="faas-architecture.jpg" alt="https://www.slideshare.net/AmazonWebServices/optimizing-your-serverless-applications-srv401r2-aws-reinvent-2018"></p><ul><li>Event Source: 함수가 실행될 조건이자 이벤트 소스 (HTTP 요청, 메시징, Cron 등)</li><li>Function: 작업할 내용</li><li>Service: 작업 결과를 처리(DB 저장, 다른 서비스로 전달, 메시징, 출력 등)</li></ul><p>특정 조건 하에 이벤트가 발생하면 VM(또는 컨테이너)을 띄워서 해당 함수를 실행하고, 해당 결과를 지정한 대로 처리하게 됩니다. 여기서 함수를 실행하려면 해당 함수를 실행할 수 있는 환경이 필요한데요, 이를 런타임이라고 합니다. 당연한 얘기지만, 런타임은 해당 함수를 어떤 언어로 작성하느냐에 따라 다를 것입니다. Node.js, Python, Java 등 실행에 필요한 환경이 미리 설치되어 있어야 합니다.<sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="AWS 에서는 런타임을 직접 만들어서 다양한 언어를 사용할 수 있도록 지원합니다.">[2]</span></a></sup></p><p><img src="lambda-function.jpg" alt="https://www.slideshare.net/AmazonWebServices/optimizing-your-serverless-applications-srv401r2-aws-reinvent-2018"></p><p>위 그림은 함수를 좀 더 자세히 들여다본 그림입니다.</p><ul><li>Compute substrate: 함수가 실행될 VM(또는 컨테이너)입니다.</li><li>Execution Environment: 그 위에 환경 변수 등 실행 환경이 포함됩니다.</li><li>Language runtime: 그 위에 언어별 런타임이 올라갑니다. 언어에 따라 성능 차이가 생깁니다 (e.g. Python vs. Node.js)</li><li>Your function: 마지막으로 우리가 작성한 코드 조각이 있습니다.</li></ul><h2 id="FaaS-성능-최적화">FaaS 성능 최적화</h2><p>FaaS 는 항상 띄워놓은 서버에 비해서 확실히 자원을 적게 소모하고 비용을 줄일 수 있습니다. 그런데 문제가 하나 있습니다. 서버에서 요청이 있을 때마다 VM 이나 컨테이너를 띄운다? 바로 성능 이슈가 생깁니다.</p><p>이번 섹션에서는 FaaS 의 성능을 향상시킬 수 있는 방법에 대해 알아봅니다.</p><h3 id="Cold-Start-Delay">Cold Start Delay</h3><p><img src="function-lifecycle.jpg" alt="https://www.slideshare.net/AmazonWebServices/optimizing-your-serverless-applications-srv401r2-aws-reinvent-2018"></p><p>위 그림은 AWS Lambda 함수의 라이프사이클입니다. 처음에 해당 함수 코드를 찾아 다운로드하고 새로운 실행 환경을 구성합니다. 이 과정을 차갑게 식은 서버를 실행하는 것에 비유해 콜드 스타트(Cold Start)라고 합니다. 함수를 처음 호출할 때나 업데이트 된 후 실행할 경우 어쩔 수 없이 발생하는 지연(delay)입니다.</p><p>그렇다면 이런 콜드 스타트 지연을 어떻게 줄일 수 있을까요? 함수가 실행되고 나면 이후에 또 다른 호출을 대비해서 실행 컨텍스트를 잠깐 동안 유지합니다. 따라서 해당 서버가 아직 내려가지 않은 따뜻한(warm) 상태라면 준비 과정을 거치지 않고 빠르게 함수가 수행됩니다. 이를 이용해 주기적으로 함수를 호출하도록 스케줄링하면, 서버가 내려가지 않도록 warm 상태를 유지하게 됩니다.</p><p><img src="cold-start-performance.png" alt="https://medium.com/thundra/dealing-with-cold-starts-in-aws-lambda-a5e3aa8f532"></p><p>5분 마다 지속적으로 함수를 실행시켰더니 지연이 확실히 줄어든 걸 보실 수 있습니다. 하지만 계속해서 호출하다보니 비용이 추가적으로 발생합니다.</p><p>주의할 점은 컨텍스트가 동일하게 계속해서 유지될거란 보장은 없다는 겁니다. 콜드 스타트를 줄이기 위해서 해당 컨텍스트를 재사용하지만, 어떠한 이유로라도 서버는 새로운 컨텍스트를 생성할 수 있습니다. 따라서 컨텍스트가 재사용될 것을 염두에 두고 해당 컨텍스트에 저장된 값을 다른 함수에서 재사용해서는 안됩니다.</p><h3 id="Execution-Environment">Execution Environment</h3><p><img src="lambda-function.jpg" alt="https://www.slideshare.net/AmazonWebServices/optimizing-your-serverless-applications-srv401r2-aws-reinvent-2018"></p><p>위 그림은 람다 함수를 자세히 들여다 본 그림입니다. 위에서 한 번 본 그림이죠? 이번에 함수의 성능 향상을 위해서 살펴볼 부분은 서버 위에 구성될 실행 환경입니다.</p><p>이 실행 환경의 성능을 개선하려면 메모리를 더 하는 수밖에 없습니다. 람다의 경우 메모리만 지정할 수 있고 다른 리소스는 메모리를 기준으로 자동 할당됩니다. 물론 그만큼 비용은 더 지불해야 합니다. 빠른 성능을 원하면 돈을 더 내야하는 거죠. 여기서 재미있는 점은 돈을 많이 낸다고 성능이 그에 비례하게 올라가진 않는다는 점입니다. 즉, 가성비를 따져봐야 합니다.</p><p><img src="smart-resource-allocation.jpg" alt="https://www.slideshare.net/AmazonWebServices/optimizing-your-serverless-applications-srv401r2-aws-reinvent-2018"></p><p>위 그림을 보면 메모리를 더 많이 할당할수록 소요되는 시간이 줄어들어 성능이 향상된 걸 볼 수 있습니다. 하지만 비용은 256MB, 512MB 보다 1024MB 일 때가 더 저렴합니다. $0.00001 추가 비용으로 성능을 10배 정도 높인 셈입니다.</p><p>재미있는 점은 람다의 경우 호출 횟수와 메모리 사용량을 보고 과금을 한다는 점인데, 메모리만 적게 쓴다면 CPU 또는 네트워크를 많이 사용하더라도 비용을 적게 낼 수 있습니다.</p><h3 id="Function">Function</h3><p>마지막으로 함수 영역을 최적화할 수 있는 방법입니다.</p><ul><li>함수는 처음 콜드 스타트할 때만 처음부터 끝까지 실행하고, 재사용할 때는 진입점인 핸들러 함수만 실행합니다. 따라서 필요치 않은 초기화 로직은 핸들러 밖으로 빼서 중복 실행되는 것을 막습니다.</li><li>라이브러리와 프레임워크는 꼭 필요한 것만 사용하고, 무거운 것보다는 가벼운 것을 사용합니다(e.g. Spring -&gt; Dagger, Guice).</li><li>코드를 간결하게 유지해야 합니다. 처음에 함수의 코드를 다운로드하고 압축을 풀기 때문에 코드의 양이 적을수록 좋습니다.</li><li>모든 로직을 하나의 함수에 담는 것보다 여러 작은 함수로 쪼개는 것이 좋습니다. 시간이 오래 걸리는 작업이 있을 경우 전체 리소스가 전부 대기해야 하기 때문입니다. 이런 경우 <a href="https://aws.amazon.com/ko/getting-started/tutorials/create-a-serverless-workflow-step-functions-lambda/">AWS Step Functions</a> 를 이용해 서버리스 워크플로우를 구성하는 것도 하나의 방법입니다.</li></ul><p>이외에도 함수 코드를 작성할 때 참고할만한 팁입니다.</p><ul><li>핵심 로직에서 핸들러(진입점) 함수를 분리하면 단위 테스트를 더 많이 생성할 수 있습니다.</li><li>람다 환경 변수를 활용해 하드 코딩을 없앱니다.</li><li>재귀 함수 호출은 사용하지 않는 것이 좋습니다.</li></ul><h2 id="참고">참고</h2><ul><li><a href="https://blog.symphonia.io/revisiting-serverless-architectures-29f0b831303c">Revisiting “Serverless Architectures”</a></li><li><a href="https://medium.com/@dabit3/full-stack-development-in-the-era-of-serverless-computing-c1e49bba8580">Full-Stack Development in the Era of Serverless Computing</a></li><li><a href="https://www.slideshare.net/AmazonWebServices/optimizing-your-serverless-applications-srv401r2-aws-reinvent-2018">Optimizing Your Serverless Applications</a></li></ul><h2 id="Related-Posts">Related Posts</h2><ul><li><a href="/2019/02/25/kubernetes-cluster-on-google-compute-engine-for-developers/" title="개발자를 위한 쿠버네티스(Kubernetes) 클러스터 구성하기(Kubeadm, GCE, CentOS)">개발자를 위한 쿠버네티스(Kubernetes) 클러스터 구성하기(Kubeadm, GCE, CentOS)</a></li><li><a href="/2019/01/19/spring-boot-containerization-and-ci-cd-to-kubernetes-cluster/" title="스프링 부트 컨테이너와 CI&#x2F;CD 환경 구성하기">스프링 부트 컨테이너와 CI&#x2F;CD 환경 구성하기</a></li><li><a href="/2018/11/09/it-infrastructure-basics/" title="개발자를 위한 인프라 기초 총정리">개발자를 위한 인프라 기초 총정리</a></li><li><a href="/2018/11/16/docker-container-basics/" title="도커 Docker 기초 확실히 다지기">도커 Docker 기초 확실히 다지기</a></li></ul><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">http://www.paulkerrision.co.uk/<a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">AWS 에서는 런타임을 직접 만들어서 다양한 언어를 사용할 수 있도록 지원합니다.<a href="#fnref:2" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;p&gt;서버리스(Serverless)하면 대부분 AWS Lambda 를 떠올</summary>
      
    
    
    
    <category term="Cloud" scheme="https://futurecreator.github.io/categories/Cloud/"/>
    
    
    <category term="aws" scheme="https://futurecreator.github.io/tags/aws/"/>
    
    <category term="lambda" scheme="https://futurecreator.github.io/tags/lambda/"/>
    
    <category term="cloud" scheme="https://futurecreator.github.io/tags/cloud/"/>
    
    <category term="gcp" scheme="https://futurecreator.github.io/tags/gcp/"/>
    
    <category term="serverless" scheme="https://futurecreator.github.io/tags/serverless/"/>
    
    <category term="faas" scheme="https://futurecreator.github.io/tags/faas/"/>
    
    <category term="serviceful_serverless" scheme="https://futurecreator.github.io/tags/serviceful-serverless/"/>
    
  </entry>
  
  <entry>
    <title>오픈 소스 컨트리뷰션을 위한 GitHub Fork &amp; Pull Request</title>
    <link href="https://futurecreator.github.io/2019/03/05/github-fork-and-pull-request-process-for-open-source-contribution/"/>
    <id>https://futurecreator.github.io/2019/03/05/github-fork-and-pull-request-process-for-open-source-contribution/</id>
    <published>2019-03-04T16:46:15.000Z</published>
    <updated>2025-03-14T16:10:24.268Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>GitHub 에서 오픈 소스를 사용하다보면 발견한 버그를 직접 수정하거나, 새로운 기능을 추가하고 싶을 때가 있습니다. 하지만 어디서부터 어떻게 시작해야할 지 막막하기도 합니다. 이번 포스트에서는 오픈 소스에 컨트리뷰션(기여)하는 절차를 간단히 알아보겠습니다.</p><h2 id="1-New-Issue">1. New Issue</h2><p>먼저, 사용하다가 발견한 버그나 기능에 대한 의견을 이슈(Issue)로 만들어 제기합니다. 내가 바로 처리할 수 있는 것이라도 먼저 이슈를 제기해서 다른 사람들의 의견과 동의를 구하는 것이 좋습니다. 누군가는 해당 이슈에 대해 다르게 생각할 수도 있고, 내 아이디어를 발전시켜 줄 수도 있기 때문입니다.</p><p><img src="new-issue.png" alt="이슈 제기"></p><p><img src="same-issue.png" alt="비슷한 이슈를 발견했다는 코멘트"></p><p><img src="fix-issue.png" alt="이슈를 고치겠다는 컨트리뷰터"></p><p><img src="reopen-issue.png" alt="PR 반영 후에도 비슷한 이슈를 발견했다는 코멘트"></p><p>이렇게 올라간 이슈는 해당 주제에 대해 토론과 대화가 이뤄집니다. 이슈에는 새롭게 번호가 붙는데 <code>#</code> 을 이용해서 특정 이슈를 검색하거나 언급할 수 있습니다(e.g. 111번 이슈라면 <code>#111</code>). 그리고 이슈를 올리기 전에, 기존에 올라간 이슈 중에 비슷한 이슈가 있는지 미리 검색해보는 것이 좋습니다.</p><p>수정 또는 새로운 기능에 대한 동의가 이뤄지면 누군가가 개발을 해야하는데요, 이번엔 직접 개발해볼까요?</p><h2 id="2-Fork-Clone-하기">2. Fork &amp; Clone 하기</h2><p>먼저 기여하고 싶은 저장소에서 <strong>Fork</strong> 버튼을 눌러 포크를 진행합니다.</p><p><img src="fork-button.png" alt="기여하고 싶은 저장소"></p><p>그러면 내 계정으로 저장소가 복사됩니다.</p><p><img src="forked-repository.png" alt="포크된 저장소"></p><p>이렇게 포크된 저장소를 클론(Clone)해서 내려받습니다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/futureCreator/kube-backup.git</span><br></pre></td></tr></table></figure><h2 id="3-Remote-Repository-추가하기">3. Remote Repository 추가하기</h2><p>현재 원격 저장소(<code>origin</code>)은 포크된 우리의 저장소입니다. 이와 별개로 원래 저장소에서는 따로 개발이 진행될 것이기 때문에 최신 버전과 싱크를 맞추는 작업이 필요합니다. 그래서 원래 저장소도 원격 저장소(<code>upstream</code>)로 추가합니다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add upstream https://github.com/kuberhost/kube-backup.git</span><br></pre></td></tr></table></figure><p>추가된 저장소는 다음과 같이 확인할 수 있습니다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git remote -v</span><br><span class="line">originhttps://github.com/futureCreator/kube-backup.git (fetch)</span><br><span class="line">originhttps://github.com/futureCreator/kube-backup.git (push)</span><br><span class="line">upstreamhttps://github.com/kuberhost/kube-backup.git (fetch)</span><br><span class="line">upstreamhttps://github.com/kuberhost/kube-backup.git (push)</span><br></pre></td></tr></table></figure><h2 id="4-Branch-생성하고-작업하기">4. Branch 생성하고 작업하기</h2><p>이제 로컬에서 마음껏 작업하면 됩니다. 간단한 작업이라면 그냥 <code>master</code> 브랜치에서 작업해도 됩니다. 하지만 복잡한 작업은 새로운 브랜치(e.g. <code>newfeature</code>)를 생성해서 작업하는 것이 좋겠죠.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git checkout master</span><br><span class="line">git branch newfeature   </span><br><span class="line">git checkout newfeature</span><br></pre></td></tr></table></figure><p>작업할 때 커밋 메시지를 고민하는 경우가 많은데, 로컬에서 개발할 때는 커밋 메시지를 크게 고민하지 않아도 됩니다. 푸시(Push)하지 않는 한 해당 메시지는 올라가지 않으니까요. 푸시 하기 전에 커밋 내역을 정리할 수 있으므로 로컬에서는 마음껏 커밋해도 괜찮습니다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git commit add .</span><br><span class="line">git commit -m ‘Update ...’</span><br></pre></td></tr></table></figure><h2 id="5-작업-정리하기">5. 작업 정리하기</h2><p>작업이 완료된 후 푸시하기 전에 원래 저장소에 수정된 작업이 있으면 포크된 저장소와 싱크를 맞춰야 합니다. <code>upstream</code> 브랜치와 <code>master</code> 를 머지(Merge)합니다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git fetch upstream</span><br><span class="line">git checkout master</span><br><span class="line">git merge upstream/master</span><br></pre></td></tr></table></figure><p>이제 <code>rebase -i</code> 명령어를 이용해 커밋 내역을 정리하고 <code>newfeature</code> 와 <code>master</code> 브랜치를 합칩니다. <code>-i</code> 옵션은 인터랙티브 옵션으로 커밋 이력을 보여주고, 사용자가 특정 커밋을 선택하거나 합칠 수 있는 명령어입니다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout newfeature</span><br><span class="line">git rebase -i master</span><br></pre></td></tr></table></figure><h2 id="6-Push-하기">6. Push 하기</h2><p>이제 모든 수정 사항이 반영된 <code>master</code> 브랜치를 포크된 원격 저장소(<code>origin</code>)으로 푸시합니다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin master</span><br></pre></td></tr></table></figure><h2 id="7-Pull-Request-만들기">7. Pull Request 만들기</h2><p>GitHub 웹 페이지에서 포크한 저장소를 찾아가면 내가 푸시한 브랜치 기반으로 <strong>Create Pull Request</strong> 버튼이 생긴 걸 볼 수 있습니다. 또는 <strong>Compare</strong> 버튼을 눌러 브랜치를 비교하고, 원하는 브랜치로 Pull Request 를 생성할 수 있습니다. 인터페이스가 직관적이어서 쉽게 비교할 수 있습니다.</p><p><img src="comparing-changes.png" alt="Pull Request 만들기"></p><p>Pull Request 생성 시 본문에 수정한 내용을 간단히 적을 수 있는데요, 특정 문법으로 해당 이슈를 바로 닫을(Close) 수 있습니다.</p><ul><li>close</li><li>closes</li><li>closed</li><li>fix</li><li>fixes</li><li>fixed</li><li>resolve</li><li>resolves</li><li>resolved</li></ul><p>e.g. 111번 이슈에 대한 PR: <code>close #111</code>, <code>fixes #111</code>, etc.</p><p>그럼 Pull Request 가 승인될 때 해당 이슈가 자동으로 닫힙니다.</p><h2 id="8-Merged">8. Merged!</h2><p><img src="merged.png" alt="Pull Request 승인"></p><p>생성된 Pull Request 가 검토 과정을 거쳐 승인이 나면 수정한 소스는 원본 소스로 머지됩니다.</p><p><img src="closed-issue.png" alt="해결된 이슈"></p><p>해당 이슈는 자동으로 닫혔습니다.</p><p>물론 승인이 나지 않을 수도 있습니다. 방향이 다르거나 혹은 더 수정이 필요한 것일 수도 있습니다.</p><h2 id="정리">정리</h2><p>이번 포스트에서는 오픈 소스 기여 절차에 대해 알아봤습니다. 컨트리뷰션이라고 하면 거창해보이지만 꼭 대단한 기여만 있는 것은 아닙니다. 작은 버그를 발견하고 이슈를 제기하는 것도 일종의 기여이고, 해당 오픈 소스가 발전할 수 있도록 의견을 제시하는 것도 일종의 기여니까요. 직접 소스를 커밋해서 이슈를 해결하려면 그 전에 커뮤니티의 의견을 듣고 동의를 구하는 과정이 중요한 것 같습니다. 그렇게 여러 사람이 힘을 모아서 소프트웨어를 발전시켜 나가는 것이 진정한 오픈 소스의 힘이 아닐까 합니다.</p><h2 id="참고">참고</h2><ul><li><a href="https://gist.github.com/Chaser324/ce0505fbed06b947d962">GitHub Forking</a></li><li><a href="https://help.github.com/articles/closing-issues-using-keywords/">Closing issues using keywords</a></li></ul><h2 id="Related-Posts">Related Posts</h2><ul><li><a href="/2018/06/07/computer-system-time/" title="컴퓨터 시간의 1970년은 무슨 의미일까?">컴퓨터 시간의 1970년은 무슨 의미일까?</a></li><li><a href="/2018/06/05/metasyntactic-variables-foo-bar/" title="foo, bar 의 어원을 찾아서">foo, bar 의 어원을 찾아서</a></li><li><a href="/2018/06/11/about-clean-code/" title="클린코드가 시작되는 곳">클린코드가 시작되는 곳</a></li><li><a href="/2018/09/09/software-versioning/" title="SW 라이브러리 버전 제대로 읽기">SW 라이브러리 버전 제대로 읽기</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;p&gt;GitHub 에서 오픈 소스를 사용하다보면 발견한 버그를 직접 수정하</summary>
      
    
    
    
    <category term="Programming" scheme="https://futurecreator.github.io/categories/Programming/"/>
    
    
    <category term="github" scheme="https://futurecreator.github.io/tags/github/"/>
    
    <category term="open_source" scheme="https://futurecreator.github.io/tags/open-source/"/>
    
    <category term="issue" scheme="https://futurecreator.github.io/tags/issue/"/>
    
    <category term="pull_request" scheme="https://futurecreator.github.io/tags/pull-request/"/>
    
    <category term="fork" scheme="https://futurecreator.github.io/tags/fork/"/>
    
    <category term="clone" scheme="https://futurecreator.github.io/tags/clone/"/>
    
    <category term="community" scheme="https://futurecreator.github.io/tags/community/"/>
    
  </entry>
  
  <entry>
    <title>Git과 CronJob을 활용한 쿠버네티스 오브젝트 YAML 자동 백업</title>
    <link href="https://futurecreator.github.io/2019/02/27/kubernetes-object-yaml-auto-backup-using-git-and-cronjob/"/>
    <id>https://futurecreator.github.io/2019/02/27/kubernetes-object-yaml-auto-backup-using-git-and-cronjob/</id>
    <published>2019-02-26T15:10:14.000Z</published>
    <updated>2025-03-14T16:10:24.268Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>쿠버네티스(Kubernetes)에서 시시각각으로 변하는 오브젝트의 상태를 저장하고 관리하려면 어떻게 해야 할까요? 가장 먼저 생각할 수 있는 방법은 YAML 파일로 export 해서 저장하는 것입니다.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># e.g. kube-system Namespace 의 모든 Pod 을 YAML 형태로 출력하기</span></span><br><span class="line">kubectl get po -n kube-system -o yaml</span><br></pre></td></tr></table></figure><p>Pod 뿐만 아니라 Deployment, Service, ConfigMap 등 모든 Namespace 의 다양한 오브젝트를 YAML 형태로 출력할 수 있습니다. YAML 은 복잡하지 않고 데이터를 체계적으로 보여주기 때문에 읽기 쉬운 장점이 있습니다. 이를 주기적으로 수행하도록 쉘 스크립트를 짜서 관리할 수도 있을텐데요. YAML 파일을 만들기는 쉽지만 관리가 어렵고, 문제가 생겼을 시에 활용하기 어려운 단점이 있습니다.</p><p>이번 포스트에서는 이런 문제를 해결할 수 있는 오픈 소스를 소개하려고 합니다.</p><h2 id="Kube-backup">Kube-backup</h2><p><a href="https://github.com/kuberhost/kube-backup">Kube-backup</a> 은 Git과 CronJob 을 이용해 쿠버네티스 오브젝트를 YAML 파일로 백업하는 오픈소스입니다.</p><p>이 오픈소스의 핵심은 다음과 같습니다.</p><ul><li>설정한 쿠버네티스 오브젝트를 YAML 파일로 백업</li><li>지정한 Git의 브랜치로 Push</li><li>CronJob 형태로 주기적 수행</li></ul><p><img src="https://user-images.githubusercontent.com/26019/48974539-12be7600-f097-11e8-91d7-b19c4c8d3e23.png" alt="https://github.com/kuberhost/kube-backup"></p><p>설정을 이용해 백업할 오브젝트의 선별이 쉽고, Namespace 와 오브젝트 별로 체계적인 분류가 가능합니다.</p><p><img src="https://user-images.githubusercontent.com/26019/48974571-b9a31200-f097-11e8-8f0a-52afc67e4112.png" alt="https://github.com/kuberhost/kube-backup"></p><p>또한 Git 을 이용해서 변경 이력을 관리하기가 쉽고 문제가 생기는 부분을 쉽게 파악할 수 있습니다. 또한 변경이 있는 부분만 Push 하기 때문에 관리가 용이하고, 시스템 버전에 따라서 저장소 또는 브랜치를 분리해서 관리할 수 있습니다.</p><p>물론 위 그림은 간단한 클러스터의 경우이고, 대규모 운영 클러스터의 경우에는 백업할 내용이 많아 적절한 설정이 필요합니다.</p><h2 id="클러스터-준비하기">클러스터 준비하기</h2><p>먼저 설치할 클러스터가 필요합니다. 이번 포스트에서는 쿠버네티스 클러스터가 있다는 전제 하에 진행됩니다. 쿠버네티스 클러스터가 필요하다면 다음 포스트를 참고하세요.</p><a href="/2019/02/25/kubernetes-cluster-on-google-compute-engine-for-developers/" title="개발자를 위한 쿠버네티스(Kubernetes) 클러스터 구성하기(Kubeadm, GCE, CentOS)">개발자를 위한 쿠버네티스(Kubernetes) 클러스터 구성하기(Kubeadm, GCE, CentOS)</a><h2 id="사전-준비하기">사전 준비하기</h2><p>그럼 실제 클러스터에 배포해보겠습니다. <a href="https://github.com/kuberhost/kube-backup">GitHub 리파지토리</a>에 있는 배포용 YAML 을 이용하면 쉽게 배포가 가능합니다. 그 전에 앞서 몇 가지 설정이 필요합니다.</p><p><img src="create-github-repository.png" alt="GitHub 리파지토리 생성하기"></p><p>먼저 백업 YAML 파일을 저장할 라피지토리가 필요하겠죠? GitHub이나 GitLab 등 원하는 리파지토리를 생성합니다. 백업용이니까 Private 리파지토리가 좋겠습니다. 이번 포스트에는 GitHub 기준으로 진행합니다.</p><p>그리고 기본 설정인 <code>master</code> 브랜치가 필요하므로 <code>README.md</code> 파일로 초기화해서 <code>master</code> 브랜치를 만들어줍니다.</p><p>이렇게 프로그램 상에서 자동으로 Git 에 접속하는 경우에는 <code>https</code> 대신 <code>ssh</code> 방식을 사용합니다. <code>https</code> 방식은 보안을 위해 계정 정보를 직접 입력해야 하기 때문에 Key 를 이용해 인증을 할 수 있는 <code>ssh</code>방식을 사용합니다.</p><p>이를 위해서 먼저 포트가 열려 있어야 합니다. 운영 환경의 경우에는 방화벽이 있을 수 있으므로 사전에 <code>22</code> 포트를 오픈합니다.</p><p>그리고 GitHub 에 접속할 SSH Key 를 생성합니다. GitHub 에서는 다른 리파지토리 또는 유저가 사용하는 Key 를 사용할 수 없기 때문에 새로 Key 를 생성합니다.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -f ./new-key</span><br></pre></td></tr></table></figure><p>그러면 Private Key 와 Public Key 한 쌍이 생성됩니다.</p><p><img src="deploy-keys.png" alt="Public Key 등록하기"></p><p>이제 GitHub 의 <strong>Settings &gt; Deploy Keys</strong> 에 생성한 Public Key 를 등록합니다.</p><p><img src="deploy-yaml-files.png" alt="배포용 YAML 파일"></p><p>배포용 YAML 파일을 내려받습니다. 또는 포스트에 내용을 복사해서 사용합니다.</p><h2 id="설치하기">설치하기</h2><p>배포용 YAML 파일명 앞에 붙어있는 숫자 순서대로 설치를 진행하면 됩니다.</p><h3 id="Namespace">Namespace</h3><p><code>0_namespace.yaml</code> 파일로 Namespace <code>kube-backup</code> 을 생성합니다.</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Namespace</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kube-backup</span></span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f 0_namespace.yaml</span><br></pre></td></tr></table></figure><h3 id="RBAC">RBAC</h3><p>그리고 <code>1_service_account.yaml</code> 파일로 ServiceAccount 를 생성하고 Role 을 설정합니다.</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kube-backup-user</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-backup</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kube-backup-view-all</span></span><br><span class="line"><span class="attr">rules:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">apiGroups:</span> [<span class="string">&quot;*&quot;</span>]</span><br><span class="line">  <span class="attr">resources:</span> [<span class="string">&quot;*&quot;</span>]</span><br><span class="line">  <span class="attr">verbs:</span> [<span class="string">&quot;get&quot;</span>, <span class="string">&quot;list&quot;</span>, <span class="string">&quot;watch&quot;</span>]</span><br><span class="line"><span class="bullet">-</span> <span class="attr">nonResourceURLs:</span> [<span class="string">&quot;*&quot;</span>]</span><br><span class="line">  <span class="attr">verbs:</span> [<span class="string">&quot;get&quot;</span>, <span class="string">&quot;list&quot;</span>, <span class="string">&quot;watch&quot;</span>]</span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRoleBinding</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1beta1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kube-backup-user</span></span><br><span class="line"><span class="attr">subjects:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">kube-backup-user</span></span><br><span class="line">    <span class="attr">namespace:</span> <span class="string">kube-backup</span></span><br><span class="line"><span class="attr">roleRef:</span></span><br><span class="line">  <span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kube-backup-view-all</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">RoleBinding</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">psp:unprivileged</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-backup</span></span><br><span class="line"><span class="attr">roleRef:</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br><span class="line">  <span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">podsecuritypolicy:unprivileged</span></span><br><span class="line"><span class="attr">subjects:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">Group</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">system:serviceaccounts:kube-backup</span></span><br><span class="line">    <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f 1_service_account.yaml</span><br></pre></td></tr></table></figure><h3 id="ConfigMap">ConfigMap</h3><p>다음으로 <code>2_config_map.yaml</code>에 위에서 만든 SSH key 를 추가합니다. 해당 ConfigMap 은 Volume 으로 마운트되어 컨테이너에서 Git Clone 및 Push 할 때 사용됩니다.</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kube-backup-ssh-config</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-backup</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="attr">id_rsa:</span> <span class="string">|</span></span><br><span class="line"><span class="string">    -----BEGIN RSA PRIVATE KEY-----</span></span><br><span class="line"><span class="string">    # private key 내용 추가</span></span><br><span class="line"><span class="string">    -----END RSA PRIVATE KEY-----</span></span><br><span class="line"><span class="string"></span>  <span class="attr">id_rsa.pub:</span> <span class="string">|</span></span><br><span class="line">    <span class="comment"># public key 내용 추가</span></span><br></pre></td></tr></table></figure><p><code>2_config_map.yaml</code> 파일을 이용해 ConfigMap 을 생성합니다.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f 2_config_map.yaml</span><br></pre></td></tr></table></figure><h3 id="CronJob">CronJob</h3><p>이제 <code>3_cronjob.yaml</code>를 수정해 백업을 수행할 CronJob 을 만들어봅시다.</p><p>먼저 해당 CronJob 의 스케쥴을 원하는 만큼 cron 형태로 수정합니다.</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">schedule:</span> <span class="string">&quot;0 */1 * * *&quot;</span> <span class="comment"># e.g. 매 정시 수행</span></span><br></pre></td></tr></table></figure><p>여기서 주의할 점은 특정 시각을 cron으로 설정하는 경우는 UTC 기준으로 설정해야 합니다.</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># e.g. 매일 오전 1시에 백업 수행</span></span><br><span class="line"><span class="comment"># 01:00 KST -&gt; 16:00 UTC</span></span><br><span class="line"><span class="attr">schedule:</span> <span class="string">&quot;0 16 * * *&quot;</span></span><br></pre></td></tr></table></figure><p>다음으로 <code>GIT_REPO</code>에 백업할 저장소 위치를 SSH 형식으로 추가합니다.</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">env:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">GIT_REPO_URL</span></span><br><span class="line">    <span class="attr">value:</span> <span class="string">git@github.com:futureCreator/kube-backup-test.git</span></span><br></pre></td></tr></table></figure><p>Custom Resource 는 따로 이름을 추가해줘야 합니다. 다음 명령어로 Custom Resources 를 조회합니다.<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="jq 설치 안내 https://zetawiki.com/wiki/리눅스_jq_다운로드_설치">[1]</span></a></sup></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">kubectl get crd -o json | jq -r <span class="string">&#x27;.items | (.[] | [.spec.names.singular, .spec.group, .spec.scope]) | @tsv&#x27;</span></span><br><span class="line"><span class="comment"># 출력 예시</span></span><br><span class="line">adapter            config.istio.io         Namespaced</span><br><span class="line">alertmanager       monitoring.coreos.com   Namespaced</span><br><span class="line">apikey             config.istio.io         Namespaced</span><br><span class="line">attributemanifest  config.istio.io         Namespaced</span><br><span class="line">clusterbus         channels.knative.dev    Cluster</span><br></pre></td></tr></table></figure><p>출력 결과를 보면 세 번째 열의 항목이 <code>Namespaced</code> 와 <code>Cluster</code> 로 나뉘는데 이에 맞춰서 <code>EXTRA_RESOURCES</code> 와 <code>EXTRA_GLOBAL_RESOURCES</code> 로 나눠서 추가합니다.</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">env:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">EXTRA_GLOBAL_RESOURCES</span> <span class="comment"># spec.scope 이 Cluster인 항목</span></span><br><span class="line">    <span class="attr">value:</span> <span class="string">clusterbus</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">EXTRA_RESOURCES</span> <span class="comment"># spec.scope이 Namespaced인 항목</span></span><br><span class="line">    <span class="attr">value:</span> <span class="string">adapter,</span> <span class="string">alertmanager,</span> <span class="string">apikey,</span> <span class="string">attributemanifest</span></span><br></pre></td></tr></table></figure><p>Commit 에 사용할 타임존을 설정합니다.</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">env:</span> </span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">TZ</span></span><br><span class="line">    <span class="attr">value:</span> <span class="string">:Asia/Seoul</span></span><br></pre></td></tr></table></figure><p>여기까지 작성한 CronJob의 예시입니다.</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">batch/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">CronJob</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kube-system-backup</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-backup</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">schedule:</span> <span class="string">&quot;0 */1 * * *&quot;</span></span><br><span class="line">  <span class="attr">concurrencyPolicy:</span> <span class="string">Forbid</span></span><br><span class="line">  <span class="attr">successfulJobsHistoryLimit:</span> <span class="number">2</span></span><br><span class="line">  <span class="attr">failedJobsHistoryLimit:</span> <span class="number">2</span></span><br><span class="line">  <span class="attr">jobTemplate:</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">template:</span></span><br><span class="line">        <span class="attr">spec:</span></span><br><span class="line">          <span class="attr">restartPolicy:</span> <span class="string">OnFailure</span></span><br><span class="line">          <span class="attr">serviceAccount:</span> <span class="string">kube-backup-user</span></span><br><span class="line">          <span class="attr">containers:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">backup</span></span><br><span class="line">              <span class="attr">image:</span> <span class="string">kuberhost/kube-backup</span></span><br><span class="line">              <span class="attr">imagePullPolicy:</span> <span class="string">Always</span></span><br><span class="line">              <span class="attr">env:</span></span><br><span class="line">                <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">BACKUP_VERBOSE</span></span><br><span class="line">                  <span class="attr">value:</span> <span class="string">&quot;1&quot;</span></span><br><span class="line">                <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">GIT_REPO_URL</span></span><br><span class="line">                  <span class="attr">value:</span> <span class="string">git@github.com:futureCreator/kube-backup-test.git</span></span><br><span class="line">                <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">EXTRA_GLOBAL_RESOURCES</span></span><br><span class="line">                  <span class="attr">value:</span> <span class="string">clusterbus</span></span><br><span class="line">                <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">EXTRA_RESOURCES</span></span><br><span class="line">                  <span class="attr">value:</span> <span class="string">adapter,</span> <span class="string">alertmanager,</span> <span class="string">apikey,</span> <span class="string">attributemanifest</span></span><br><span class="line">                <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">TZ</span></span><br><span class="line">                  <span class="attr">value:</span> <span class="string">:Asia/Seoul</span></span><br><span class="line">              <span class="attr">volumeMounts:</span></span><br><span class="line">                <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">ssh-config</span></span><br><span class="line">                  <span class="attr">mountPath:</span> <span class="string">/root/.ssh/id_rsa</span></span><br><span class="line">                  <span class="attr">subPath:</span> <span class="string">id_rsa</span></span><br><span class="line">                <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">ssh-config</span></span><br><span class="line">                  <span class="attr">mountPath:</span> <span class="string">/root/.ssh/id_rsa.pub</span></span><br><span class="line">                  <span class="attr">subPath:</span> <span class="string">id_rsa.pub</span></span><br><span class="line">          <span class="attr">volumes:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">ssh-config</span></span><br><span class="line">              <span class="attr">configMap:</span></span><br><span class="line">                <span class="attr">name:</span> <span class="string">kube-backup-ssh-config</span></span><br><span class="line">                <span class="attr">defaultMode:</span> <span class="number">256</span></span><br></pre></td></tr></table></figure><p>테스트 시에는 Pod 으로 생성하면 편리합니다.</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kube-system-backup</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-backup</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">restartPolicy:</span> <span class="string">OnFailure</span></span><br><span class="line">  <span class="attr">serviceAccount:</span> <span class="string">kube-backup-user</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">backup</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">kuberhost/kube-backup</span></span><br><span class="line">    <span class="attr">imagePullPolicy:</span> <span class="string">Always</span></span><br><span class="line">    <span class="attr">env:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">BACKUP_VERBOSE</span></span><br><span class="line">      <span class="attr">value:</span> <span class="string">&quot;1&quot;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">GIT_REPO_URL</span></span><br><span class="line">      <span class="attr">value:</span> <span class="string">git@github.com:futureCreator/kube-backup-test.git</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">EXTRA_GLOBAL_RESOURCES</span></span><br><span class="line">      <span class="attr">value:</span> <span class="string">clusterbus</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">EXTRA_RESOURCES</span></span><br><span class="line">      <span class="attr">value:</span> <span class="string">adapter,</span> <span class="string">alertmanager,</span> <span class="string">apikey,</span> <span class="string">attributemanifest</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">TZ</span></span><br><span class="line">      <span class="attr">value:</span> <span class="string">:Asia/Seoul</span></span><br><span class="line">    <span class="attr">volumeMounts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">ssh-config</span></span><br><span class="line">      <span class="attr">mountPath:</span> <span class="string">/root/.ssh/id_rsa</span></span><br><span class="line">      <span class="attr">subPath:</span> <span class="string">id_rsa</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">ssh-config</span></span><br><span class="line">      <span class="attr">mountPath:</span> <span class="string">/root/.ssh/id_rsa.pub</span></span><br><span class="line">      <span class="attr">subPath:</span> <span class="string">id_rsa.pub</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">ssh-config</span></span><br><span class="line">    <span class="attr">configMap:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">kube-backup-ssh-config</span></span><br><span class="line">      <span class="attr">defaultMode:</span> <span class="number">256</span></span><br></pre></td></tr></table></figure><p><code>3_cronjob.yaml</code> 파일로 CronJob 을 생성합니다.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f 3_cronjob.yaml</span><br></pre></td></tr></table></figure><h2 id="확인하기">확인하기</h2><p>설정한 시간마다 Job 과 Pod 이 생성되고 작업이 수행되는 것을 확인할 수 있습니다.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">kubectl get all -n kube-backup</span><br><span class="line">NAME                                      READY     STATUS      RESTARTS   AGE</span><br><span class="line">pod/kube-system-backup-1547712000-zcdr9   0/1       Completed   0          1h</span><br><span class="line">pod/kube-system-backup-1547715600-x6988   0/1       Completed   0          1m</span><br><span class="line"></span><br><span class="line">NAME                                      DESIRED   SUCCESSFUL   AGE</span><br><span class="line">job.batch/kube-system-backup-1547712000   1         1            1h</span><br><span class="line">job.batch/kube-system-backup-1547715600   1         1            1m</span><br><span class="line"></span><br><span class="line">NAME                               SCHEDULE      SUSPEND   ACTIVE    LAST SCHEDULE   AGE</span><br><span class="line">cronjob.batch/kube-system-backup   0 */1 * * *   False     0         1m              7d</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>GitHub에서 Commit 내역을 확인할 수 있습니다.</p><p><img src="github-repository.png" alt="GitHub Repository"></p><p><img src="commit-history.png" alt="Commit 내역"></p><p>Commit 상세 내역에서 변경 사항을 확인할 수 있습니다.</p><p><img src="commit-diff.png" alt="Commit 상세 내역"></p><h2 id="추가-설정하기">추가 설정하기</h2><p>필요한 경우 환경변수(<code>env</code>)에 설정을 추가할 수 있습니다.</p><table><thead><tr><th>항목</th><th>내용</th></tr></thead><tbody><tr><td>SKIP_NAMESPACES</td><td>특정 네임스페이스 제외</td></tr><tr><td>SKIP_GLOBAL_RESOURCES</td><td>특정 글로벌 리소스 제외</td></tr><tr><td>SKIP_RESOURCES</td><td>특정 리소스 제외</td></tr><tr><td>SKIP_OBJECTS</td><td>특정 오브젝트 제외</td></tr><tr><td>ONLY_NAMESPACES</td><td>특정 네임스페이스의 항목만 관리(whitelist)</td></tr><tr><td>GIT_USER</td><td>기본은 <code>kube-backup</code></td></tr><tr><td>GIT_EMAIL</td><td>기본은 <code>kube-backup@$(HOSTNAME)</code></td></tr><tr><td>GIT_BRANCH</td><td>기본은 <code>master</code> 브랜치</td></tr></tbody></table><p>이 외에도 Grafana 의 Dashboard 및 설정을 백업하기 위한 옵션도 있습니다. 백업 내용은 <code>_grafana_</code> 폴더에 저장됩니다.</p><table><thead><tr><th>항목</th><th>내용</th></tr></thead><tbody><tr><td>GRAFANA_URL</td><td>Grafana 의 URL</td></tr><tr><td>GRAFANA_TOKEN</td><td>Grafana API Key</td></tr></tbody></table><p>API Key 는 Grafana 의 <strong>Configuration &gt; API Keys</strong> 에서 Admin 권한으로 생성하면 됩니다.</p><h2 id="참고">참고</h2><p>세부 내용은 다음 링크를 참고하세요.</p><ul><li><a href="https://github.com/kuberhost/kube-backup">kuberhost/kube-backup | GitHub</a></li><li><a href="https://hub.docker.com/r/kuberhost/kube-backup">kuberhost/kube-backup | Docker Hub</a></li></ul><h2 id="Related-Posts">Related Posts</h2><ul><li><a href="/2019/02/25/kubernetes-cluster-on-google-compute-engine-for-developers/" title="개발자를 위한 쿠버네티스(Kubernetes) 클러스터 구성하기(Kubeadm, GCE, CentOS)">개발자를 위한 쿠버네티스(Kubernetes) 클러스터 구성하기(Kubeadm, GCE, CentOS)</a></li><li><a href="/2019/01/19/spring-boot-containerization-and-ci-cd-to-kubernetes-cluster/" title="스프링 부트 컨테이너와 CI&#x2F;CD 환경 구성하기">스프링 부트 컨테이너와 CI&#x2F;CD 환경 구성하기</a></li><li><a href="/2018/11/16/docker-container-basics/" title="도커 Docker 기초 확실히 다지기">도커 Docker 기초 확실히 다지기</a></li><li><a href="/2018/11/09/it-infrastructure-basics/" title="개발자를 위한 인프라 기초 총정리">개발자를 위한 인프라 기초 총정리</a></li></ul><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">jq 설치 안내 https://zetawiki.com/wiki/리눅스_jq_다운로드_설치<a href="#fnref:1" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;p&gt;쿠버네티스(Kubernetes)에서 시시각각으로 변하는 오브젝트의 상</summary>
      
    
    
    
    <category term="Cloud" scheme="https://futurecreator.github.io/categories/Cloud/"/>
    
    
    <category term="backup" scheme="https://futurecreator.github.io/tags/backup/"/>
    
    <category term="kubernetes" scheme="https://futurecreator.github.io/tags/kubernetes/"/>
    
    <category term="open_source" scheme="https://futurecreator.github.io/tags/open-source/"/>
    
    <category term="cluster" scheme="https://futurecreator.github.io/tags/cluster/"/>
    
    <category term="kube_backup" scheme="https://futurecreator.github.io/tags/kube-backup/"/>
    
    <category term="object" scheme="https://futurecreator.github.io/tags/object/"/>
    
    <category term="yaml" scheme="https://futurecreator.github.io/tags/yaml/"/>
    
    <category term="git" scheme="https://futurecreator.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>개발자를 위한 쿠버네티스(Kubernetes) 클러스터 구성하기(Kubeadm, GCE, CentOS)</title>
    <link href="https://futurecreator.github.io/2019/02/25/kubernetes-cluster-on-google-compute-engine-for-developers/"/>
    <id>https://futurecreator.github.io/2019/02/25/kubernetes-cluster-on-google-compute-engine-for-developers/</id>
    <published>2019-02-24T16:43:07.000Z</published>
    <updated>2025-03-14T16:10:24.258Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>이제 개발자가 컨테이너 기반으로 애플리케이션을 개발하면서 도커(Docker)를 많이 사용합니다. 그리고 이러한 컨테이너를 쉽게 관리하고 테스트할 쿠버네티스(Kubernetes) 환경이 필요한 경우가 생기게 됩니다.</p><p>쿠버네티스 클러스터 중 가장 쉽게 접할 수 있는 건 <a href="https://kubernetes.io/docs/setup/minikube/">Minikube</a> 입니다. 하지만 Minikube 는 Master 하나로 이루어져 있어 부족한 점이 많습니다. 쿠버네티스의 다양한 기능을 살펴보려면 Master 노드와 Worker 노드 여러 개로 이루어진 실제 클러스터 환경을 구성할 필요가 있습니다.</p><p>물론 쿠버네티스 클러스터를 구성하는 것이 간단한 일은 아닙니다. 그래서 개발자들이 처음 쿠버네티스 클러스터를 구성할 때 많은 어려움을 겪습니다. 하지만 쿠버네티스에서 제공하는 <code>kubeadm</code>이라는 툴을 이용하면 비교적 쉽게 설치할 수 있습니다.</p><p>이번 포스트에서는 GCE 위에 Master 노드 하나, Worker 노드 둘로 이루어진 클러스터를 구성해보겠습니다.</p><h2 id="쿠버네티스의-구조">쿠버네티스의 구조</h2><p>설치를 진행하기에 앞서 우리가 구축할 시스템이 어떻게 구성되어 있는지 간단하게 알아보는게 좋겠습니다.</p><p><img src="kubernetes-architecture.png" alt="쿠버네티스 아키텍처"></p><p>Worker 노드는 실제 Pod 이 실행되는 서버이고, Master 노드는 각 Worker 노드를 제어하는 서버입니다. 각 노드에는 쿠버네티스의 구성 요소가 돌아가고 있습니다.</p><p>API 서버는 작업 상태를 정의하고 조회할 수 있는 RESTful 웹 서비스를 제공하고, 쿠버네티스의 각 구성 요소는 API 서버를 거쳐 서로 통신합니다. 특히 쿠버네티스 오브젝트의 상태를 저장하는 etcd 는 API 서버를 통해서만 접근할 수 있습니다.</p><p>쿠버네티스는 현재 시스템을 사용자가 정의한 상태, 즉 사용자가 원하는 상태(어떤 Pod 이 몇 개가 떠있고, 어떤 Service 가 어떤 포트로 열려있고 등)로 맞춰줍니다. 그러려면 오브젝트의 현재 상태를 지속적으로 체크하고 상태를 제어해야 합니다. 컨트롤러 매니저(Controller Manager)에는 Replication, DaemonSet, Job, Service 등 다양한 오브젝트를 제어하는 컨트롤러가 존재합니다.</p><p>스케쥴러(Scheduler)는 노드의 정보와 알고리즘을 통해 특정 Pod 을 어떤 노드에 배포할 지 결정합니다. 대상 노드들을 조건에 따라 걸러내고 남은 노드는 우선 순위(점수)를 매겨서 가장 최적의 노드를 선택합니다.</p><p>위의 모듈은 Control Plane 인 Master 노드에 존재하지만, Kubelet 과 Kube-proxy 는 Worker 노드에 존재합니다. Kubelet 은 API 서버와 통신하며 Worker 노드의 작업을 제어하는 에이전트입니다. Kube-proxy 는 Pod 에 접근하기 위한 <code>iptables</code> 를 설정합니다. <code>iptables</code> 는 리눅스 커널의 패킷 필터링 기능을 관리하는 도구입니다. 이전에는 해당 패킷이 Kube-proxy 를 거쳐 지나갔기 때문에 proxy 라는 이름이 붙었지만, 지금은 패킷이 직접 통과하진 않습니다.</p><p>각 구성 요소에 대한 상세한 설명은 이후 포스트에서 알아보기로 하고, 다시 설치 과정으로 돌아갑시다.</p><h2 id="준비하기">준비하기</h2><p>쿠버네티스는 3개월 마다 새로운 버전이 릴리즈 되고 해당 버전은 9개월 동안 버그와 보안 이슈를 수정하는 패치가 이루어집니다. 2019년 2월 현재 최신 버전인 1.13 버전으로 설치하겠습니다.</p><p>우리가 구성할 노드는 Master 노드 하나와 Worker 노드 두 개로, 총 세 개의 서버가 필요합니다.</p><p>쿠버네티스 노드로 사용할 서버의 사양을 확인합니다.</p><table><thead><tr><th>항목</th><th>사양</th></tr></thead><tbody><tr><td>CPU</td><td>2 CPU 이상</td></tr><tr><td>메모리</td><td>2 GB 이상</td></tr><tr><td>OS</td><td>CentOS 7, RHEL 7, Ubuntu 16.04+ etc.</td></tr></tbody></table><p>또한 각 서버는 다음 조건을 만족해야 합니다.</p><ul><li>각 노드가 서로 네트워크 연결되어 있어야 합니다.</li><li>각 노드는 다음 정보가 겹치지 않아야 합니다.<ul><li>hostname: <code>hostname</code></li><li>MAC address: <code>ip link</code> 또는 <code>ifconfig -a</code></li><li>product_uuid: <code>sudo cat /sys/class/dmi/id/product_uuid</code></li></ul></li></ul><p>마지막으로, 각 노드가 사용하는 포트입니다. 각 포트는 모두 열려 있어야 합니다.</p><table><thead><tr><th style="text-align:center">노드</th><th style="text-align:center">프로토콜</th><th style="text-align:center">방향</th><th>포트 범위</th><th>목적</th><th>누가 사용?</th></tr></thead><tbody><tr><td style="text-align:center">Master</td><td style="text-align:center">TCP</td><td style="text-align:center">Inbound</td><td>6443</td><td>Kubernetes API server</td><td>All</td></tr><tr><td style="text-align:center">Master</td><td style="text-align:center">TCP</td><td style="text-align:center">Inbound</td><td>2379-2380</td><td>etcd server client API</td><td>kube-apiserver, etcd</td></tr><tr><td style="text-align:center">Master</td><td style="text-align:center">TCP</td><td style="text-align:center">Inbound</td><td>10250</td><td>Kubelet API</td><td>Self, Control plane</td></tr><tr><td style="text-align:center">Master</td><td style="text-align:center">TCP</td><td style="text-align:center">Inbound</td><td>10251</td><td>kube-scheduler</td><td>Self</td></tr><tr><td style="text-align:center">Master</td><td style="text-align:center">TCP</td><td style="text-align:center">Inbound</td><td>10252</td><td>kube-controller-manager</td><td>Self</td></tr><tr><td style="text-align:center">Worker</td><td style="text-align:center">TCP</td><td style="text-align:center">Inbound</td><td>10250</td><td>Kubelet API</td><td>Self, Control plane</td></tr><tr><td style="text-align:center">Worker</td><td style="text-align:center">TCP</td><td style="text-align:center">Inbound</td><td>30000-32767</td><td>NodePort Services</td><td>All</td></tr></tbody></table><p>각 서버를 준비하는 방법은 여러 가지가 있겠지만 가장 쉽게 생각해볼 수 있는 건 VirtualBox 와 Vagrant 를 이용한 로컬 VM이나 AWS EC2 나 GCE 같은 퍼블릭 클라우드의 VM 을 사용하는 것입니다. 하지만 메모리가 넉넉하지 않으면 로컬에서 VM 세 개를 띄우는 건 부담일 수 있으므로, 이번 포스트에서는 GCE 를 사용해서 실습을 진행합니다.</p><h3 id="Google-Compute-Engine">Google Compute Engine</h3><p>Compute Engine 은 <a href="https://cloud.google.com/?hl=ko">Google Cloud Platform</a> 의 VM 입니다. GCP는 처음 가입 시 1년 동안 사용할 수 있는 $300 상당의 크레딧을 제공하기 때문에 학습이나 간단한 테스트를 할 때 유용합니다.</p><p><img src="create-gce-vm.png" alt="VM 생성하기"></p><p>먼저 <strong>만들기</strong>를 눌러 VM 을 생성합니다.</p><p><img src="create-gce-vm-instance-detail.png" alt="새로운 VM 설정하기"></p><p>위 내용을 참고해서 VM 을 설정합니다.</p><ul><li>지역: 어딜 해도 상관 없지만 가까운 도쿄로 하는 것이 속도가 빠릅니다.</li><li>영역: 지역에 문제 발생 시 피해를 최소화하기 위해 지역은 여러 영역으로 나뉘어져 있습니다. 각 노드를 다른 영역에 배치하는 것도 좋겠죠.</li><li>사양: 위에서 살펴 본 최소사양 이상이면 됩니다. 저는 무료 크레딧 사용이 이제 한 달도 안남아서 사양을 넉넉하게 잡았습니다.</li><li>부팅 디스크: CentOS 7을 선택합니다.</li><li>ID 및 API 서비스: AWS의 IAM 권한 설정처럼 GCP도 원하는 서비스 API 마다 권한을 오픈해야 합니다. 학습 및 테스트에만 사용할 것이므로 편의상 모든 Cloud API 액세스를 허용합니다.</li></ul><p><img src="gce-vm-list.png" alt="준비된 VM 리스트"></p><p><code>master</code>, <code>worker-1</code>, <code>worker-2</code> 총 세 개의 VM 을 생성합니다. 조금 기다리면 VM이 모두 준비됩니다.</p><p>각 VM 을 접속하는 방법은 로컬에 설치해서 사용하는 gcloud 나 웹 상에서 콘솔로 바로 접속할 수 있는 Cloud SSH 가 있습니다. 이번 실습에서는 별 다른 설정 없이 바로 접속이 가능한 Cloud SSH 를 사용합니다. VM 이 생성되길 기다리는 동안 크롬 확장 프로그램인 <a href="https://chrome.google.com/webstore/detail/ssh-for-google-cloud-plat/ojilllmhjhibplnppnamldakhpmdnibd">SSH for Google Cloud Platform</a> 을 설치하면 더 편하게 사용하실 수 있습니다.</p><h2 id="설치하기">설치하기</h2><h3 id="사전-작업하기">사전 작업하기</h3><p>사전 작업은 <code>master</code>, <code>worker-1</code>, <code>worker-2</code> 모두 동일하게 진행합니다. 터미널 화면을 분할해서 동시에 작업할 수 있는 <a href="https://github.com/tmux/tmux/wiki">tmux</a> 같은 유틸이 있으면 더 편하게 작업할 수 있습니다.</p><p>모든 설치 과정은 <code>root</code> 권한으로 진행합니다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> su -</span><br></pre></td></tr></table></figure><p>Swap 은 메모리가 부족하거나 절전 모드에서 디스크의 일부 공간을 메모리처럼 사용하는 기능입니다. Kubelet 이 정상 동작할 수 있도록 해당 기능을 swap 디바이스와 파일 모두 disable 합니다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">swapoff -a</span><br><span class="line"><span class="built_in">echo</span> 0 &gt; /proc/sys/vm/swappiness</span><br><span class="line">sed -e <span class="string">&#x27;/swap/ s/^#*/#/&#x27;</span> -i /etc/fstab</span><br></pre></td></tr></table></figure><ul><li><code>swapoff -a</code>: paging 과 swap 기능을 끕니다.</li><li><code>/proc/sys/vm/swappiness</code>: 커널 속성을 변경해 swap을 disable 합니다.</li><li><code>/etc/fastab</code>: Swap을 하는 파일 시스템을 찾아 disable 합니다.</li></ul><p>각 노드의 통신을 원활하게 하기 위해 방화벽 기능을 해제합니다.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl <span class="built_in">disable</span> firewalld</span><br><span class="line">systemctl stop firewalld</span><br></pre></td></tr></table></figure><p>SELinux(Security-Enhanced Linux)는 리눅스 보안 모듈로 액세스 권한을 제어합니다. 쿠버네티스에서는 컨테이너가 호스트의 파일시스템에 접속할 수 있도록 해당 기능을 꺼야 합니다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">setenforce 0</span><br><span class="line">sed -i <span class="string">&#x27;s/^SELINUX=enforcing$/SELINUX=permissive/&#x27;</span> /etc/selinux/config</span><br></pre></td></tr></table></figure><p>RHEL 과 CentOS 7에서 <code>iptables</code> 관련 이슈가 있어서 커널 매개변수를 다음과 같이 수정하고 적용합니다.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> &lt;&lt;<span class="string">EOF &gt;  /etc/sysctl.d/k8s.conf</span></span><br><span class="line"><span class="string">net.bridge.bridge-nf-call-ip6tables = 1</span></span><br><span class="line"><span class="string">net.bridge.bridge-nf-call-iptables = 1</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line">sysctl --system</span><br></pre></td></tr></table></figure><p><code>br_netfilter</code> 모듈이 활성화되어 있어야 합니다. <code>modprobe br_netfilter</code> 명령어로 해당 모듈을 명시적으로 추가하고, <code>lsmod | grep br_netfilter</code> 명령어로 추가 여부를 확인할 수 있습니다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">modprobe br_netfilter</span><br></pre></td></tr></table></figure><p>컨테이너 실행 환경인 도커(Docker)를 설치하고 실행합니다. 쿠버네티스는 도커 외에도 여러가지 CRI(Container Runtime Interface) 구현체를 지원하기 때문에 도커에 종속적이지 않습니다.<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="https://kubernetes.io/docs/setup/cri/">[1]</span></a></sup></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum install docker -y</span><br><span class="line">systemctl start docker.service</span><br></pre></td></tr></table></figure><h3 id="쿠버네티스-설치하기">쿠버네티스 설치하기</h3><p>이제 본격적인 설치 과정입니다. Kubeadm은 Kubelet 과 Kubectl 을 설치하지 않기 때문에 직접 설치해야 합니다. 리파지토리를 추가하고 설치 및 실행합니다. Kubectl 은 클러스터에게 명령을 내리기 위한 CLI 유틸입니다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> &lt;&lt;<span class="string">EOF &gt; /etc/yum.repos.d/kubernetes.repo</span></span><br><span class="line"><span class="string">[kubernetes]</span></span><br><span class="line"><span class="string">name=Kubernetes</span></span><br><span class="line"><span class="string">baseurl=https://packages.cloud.google.com/yum/repos/kubernetes-el7-x86_64</span></span><br><span class="line"><span class="string">enabled=1</span></span><br><span class="line"><span class="string">gpgcheck=1</span></span><br><span class="line"><span class="string">repo_gpgcheck=1</span></span><br><span class="line"><span class="string">gpgkey=https://packages.cloud.google.com/yum/doc/yum-key.gpg https://packages.cloud.google.com/yum/doc/rpm-package-key.gpg</span></span><br><span class="line"><span class="string">exclude=kube*</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line">yum install -y kubelet kubeadm kubectl --disableexcludes=kubernetes</span><br><span class="line">systemctl <span class="built_in">enable</span> kubelet &amp;&amp; systemctl start kubelet</span><br></pre></td></tr></table></figure><p>이제 Master 노드에 컨트롤 구성 요소를 설치할 차례입니다. 해당 작업은 <code>master</code> 에서만 실행합니다. 설치 시 사용할 이미지를 먼저 다운로드 합니다.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubeadm config images pull</span><br></pre></td></tr></table></figure><p>마스터 노드를 초기화합니다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubeadm init</span><br></pre></td></tr></table></figure><p>그럼 설치가 진행되고 마지막에 다음과 비슷한 로그가 출력됩니다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Your Kubernetes master has initialized successfully!</span><br><span class="line"></span><br><span class="line">To start using your cluster, you need to run the following as a regular user:</span><br><span class="line"></span><br><span class="line">  <span class="built_in">mkdir</span> -p <span class="variable">$HOME</span>/.kube</span><br><span class="line">  <span class="built_in">sudo</span> <span class="built_in">cp</span> -i /etc/kubernetes/admin.conf <span class="variable">$HOME</span>/.kube/config</span><br><span class="line">  <span class="built_in">sudo</span> <span class="built_in">chown</span> $(<span class="built_in">id</span> -u):$(<span class="built_in">id</span> -g) <span class="variable">$HOME</span>/.kube/config</span><br><span class="line"></span><br><span class="line">You should now deploy a pod network to the cluster.</span><br><span class="line">Run <span class="string">&quot;kubectl apply -f [podnetwork].yaml&quot;</span> with one of the options listed at:</span><br><span class="line">  https://kubernetes.io/docs/concepts/cluster-administration/addons/</span><br><span class="line"></span><br><span class="line">You can now <span class="built_in">join</span> any number of machines by running the following on each node</span><br><span class="line">as root:</span><br><span class="line"></span><br><span class="line">  kubeadm <span class="built_in">join</span> 10.146.0.25:6443 --token yuaea3.d7m8hkpvazrbv5yw --discovery-token-ca-cert-hash sha256:c6a7121c5d5207179f67d913fa654441137f76027ad0f4e23724f0202b280eec</span><br></pre></td></tr></table></figure><p>여기서 일반 사용자가 <code>kubectl</code> 을 사용할 수 있도록 로그 중간에 있는 명령어를 복사해서 실행합니다.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p <span class="variable">$HOME</span>/.kube</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">cp</span> -i /etc/kubernetes/admin.conf <span class="variable">$HOME</span>/.kube/config</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">chown</span> $(<span class="built_in">id</span> -u):$(<span class="built_in">id</span> -g) <span class="variable">$HOME</span>/.kube/config</span><br></pre></td></tr></table></figure><p>맨 마지막 라인의 명령어는 워커 노드를 해당 클러스터에 추가하는 명령어입니다. 해당 명령어를 복사해서 <code>worker-1</code>, <code>worker-2</code> 노드에서 수행합니다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubeadm <span class="built_in">join</span> 10.146.0.25:6443 --token yuaea3.d7m8hkpvazrbv5yw --discovery-token-ca-cert-hash sha256:c6a7121c5d5207179f67d913fa654441137f76027ad0f4e23724f0202b280eec</span><br></pre></td></tr></table></figure><p>만약 해당 커맨드를 복사해놓지 않고 지워진 경우에는 다음과 같이 토큰을 확인할 수 있습니다.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubeadm token list</span><br></pre></td></tr></table></figure><p>해당 토큰은 24시간 동안만 사용할 수 있습니다. 새 토큰이 필요한 경우는 다음 명령어를 실행하면 됩니다.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubeadm token create</span><br></pre></td></tr></table></figure><h3 id="Pod-network-add-on-설치하기">Pod network add-on 설치하기</h3><p>Pod 은 실제로 여러 노드에 걸쳐 배포되는데, Pod 끼리는 하나의 네트워크에 있는 것처럼 통신할 수 있습니다. 이를 오버레이 네트워크(Overlay Network)라고 합니다.</p><p>오버레이 네트워크를 지원하는 CNI(Container Network Interface) 플러그인을 설치해보겠습니다. CNI 에는 여러 종류가 있는데, 이번 실습에서는 Weave 를 이용합니다.</p><p>Master 노드에서 다음과 같이 설치합니다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f <span class="string">&quot;https://cloud.weave.works/k8s/net?k8s-version=<span class="subst">$(kubectl version | base64 | tr -d &#x27;\n&#x27;)</span>&quot;</span></span><br></pre></td></tr></table></figure><p>CNI를 설치하면 CoreDNS Pod 이 정상적으로 동작하게 됩니다.</p><p>다음 명령어로 각 노드와 상태를 확인할 수 있습니다. 처음엔 상태가 <code>NotReady</code> 라고 나올 수 있지만 잠시 기다리면 모두 <code>Ready</code> 상태가 됩니다.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">kubectl get no</span><br><span class="line">NAME       STATUS   ROLES    AGE     VERSION</span><br><span class="line">master     Ready    master   6m44s   v1.13.3</span><br><span class="line">worker-1   Ready    &lt;none&gt;   5m20s   v1.13.3</span><br><span class="line">worker-2   Ready    &lt;none&gt;   5m19s   v1.13.3</span><br></pre></td></tr></table></figure><h2 id="설치-확인하기">설치 확인하기</h2><p>다음 명령어로 쿠버네티스의 구성 요소가 모두 동작하는 것을 확인할 수 있습니다.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">kubectl get componentstatuses</span><br><span class="line">NAME                 STATUS    MESSAGE              ERROR</span><br><span class="line">scheduler            Healthy   ok                   </span><br><span class="line">controller-manager   Healthy   ok                   </span><br><span class="line">etcd-0               Healthy   &#123;<span class="string">&quot;health&quot;</span>: <span class="string">&quot;true&quot;</span>&#125; </span><br></pre></td></tr></table></figure><p>쿠버네티스의 구성 요소가 Pod 으로 어떤 노드에 떠있는지 확인할 수 있습니다. etcd, API server, Scheduler, Controller Manager, DNS Server 는 master 에서 실행됩니다. Kube proxy 와 Weave 는 각 worker 에서 실행됩니다.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">kubectl get po -o custom-columns=POD:metadata.name,NODE:spec.nodeName --sort-by spec.nodeName -n kube-system</span><br><span class="line">POD                              NODE</span><br><span class="line">kube-proxy-pz25z                 master</span><br><span class="line">etcd-master                      master</span><br><span class="line">kube-apiserver-master            master</span><br><span class="line">kube-controller-manager-master   master</span><br><span class="line">kube-scheduler-master            master</span><br><span class="line">weave-net-8npbk                  master</span><br><span class="line">coredns-86c58d9df4-r5qq5         worker-1</span><br><span class="line">weave-net-dbk8x                  worker-1</span><br><span class="line">kube-proxy-8mrkx                 worker-1</span><br><span class="line">coredns-86c58d9df4-tsdf4         worker-1</span><br><span class="line">weave-net-bds9l                  worker-2</span><br><span class="line">kube-proxy-7pn22                 worker-2</span><br></pre></td></tr></table></figure><p>이제 설치가 잘 되었는지 Pod 을 배포하고 동작을 확인해보겠습니다.</p><ul><li>간단한 Pod 배포하기</li><li>복잡한 Microservices 애플리케이션 배포하기</li></ul><h3 id="간단한-Pod-배포하기">간단한 Pod 배포하기</h3><p>먼저 간단한 Pod 을 배포해서 동작을 확인해봅시다. 다음과 같은 <code>pod-test.yaml</code> 파일을 생성합니다.</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">myapp-pod</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">myapp</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">myapp-container</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">busybox</span></span><br><span class="line">    <span class="attr">command:</span> [<span class="string">&#x27;sh&#x27;</span>, <span class="string">&#x27;-c&#x27;</span>, <span class="string">&#x27;echo Hello Kubernetes! &amp;&amp; sleep 3600&#x27;</span>]</span><br></pre></td></tr></table></figure><p>해당 Pod 이 실행되면 busybox 라는 경량 리눅스 이미지에 <code>Hello Kubernetes!</code> 라는 로그가 잠시 동안 출력되고 Pod 은 종료될겁니다.</p><p>이제 해당 Pod 을 배포합니다.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f pod-test.yaml</span><br></pre></td></tr></table></figure><p>해당 Pod 이 정상적으로 실행된 것을 볼 수 있습니다.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kubectl get po</span><br><span class="line">NAME        READY   STATUS    RESTARTS   AGE</span><br><span class="line">myapp-pod   1/1     Running   0          6s</span><br></pre></td></tr></table></figure><p>로그도 확인해봅니다.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl logs myapp-pod</span><br><span class="line">Hello Kubernetes!</span><br></pre></td></tr></table></figure><h3 id="복잡한-Microservices-애플리케이션-배포하기">복잡한 Microservices 애플리케이션 배포하기</h3><p>이번에는 Sock Shop 이라는 복잡한 마이크로서비스 애플리케이션을 배포해보겠습니다. 이 온라인 양말 가게 애플리케이션은 오픈 소스로 마이크로서비스 데모 애플리케이션입니다.<sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="https://microservices-demo.github.io">[2]</span></a></sup></p><p><img src="sock-shop.png" alt="Sock Shop 소개"></p><p>다음 명령을 이용해 Namespace 를 만들고 각종 구성 요소를 배포합니다. <code>complete-demo.yaml</code> 파일 안에는 애플리케이션에 필요한 Deployment, Service  등이 정의되어 있습니다.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl create ns sock-shop</span><br><span class="line">kubectl apply -n sock-shop -f <span class="string">&quot;https://github.com/microservices-demo/microservices-demo/blob/master/deploy/kubernetes/complete-demo.yaml?raw=true&quot;</span></span><br></pre></td></tr></table></figure><p>다음 명령어로 새롭게 배포된 구성 요소를 모두 확인할 수 있습니다.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get all -n sock-shop</span><br></pre></td></tr></table></figure><p>모든 Pod 이 <code>Running</code> 상태가 되면 <code>front-end</code> 서비스의 NodePort 를 확인합니다. NodePort 는 해당 서버(노드)의 포트와 Pod 을 연결해서 사용하는 방식입니다.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kubectl get svc front-end -n sock-shop -o wide</span><br><span class="line">NAME        TYPE       CLUSTER-IP      EXTERNAL-IP   PORT(S)        AGE     SELECTOR</span><br><span class="line">front-end   NodePort   10.105.37.122   &lt;none&gt;        80:30001/TCP   2m48s   name=front-end</span><br></pre></td></tr></table></figure><p>따라서 노드의 외부 IP와 포트 번호를 이용해서 접속할 수 있습니다. VM의 외부 IP는 VM 목록에서 확인할 수 있습니다. 그럼 <a href="http://34.85.95.211:30001">http://34.85.95.211:30001</a> 와 같은 주소가 됩니다.</p><p>하지만 접속 전에 해당 포트가 열려 있어야 합니다. GCP 서비스 중 VPC 네트워크 &gt; 방화벽 규칙 메뉴로 들어가 방화벽 규칙을 새로 추가합니다. 메뉴 찾기는 상단의 검색창을 이용하면 쉽습니다.</p><p><img src="firewall-rules.png" alt="방화벽 규칙"></p><p>이름은 <code>http-sock-shop</code> 와 같이 적당히 주고 수신 방향으로 합니다. 대상은 편의상 '네트워크의 모든 인스턴스’를 선택하고, IP 범위는 <code>0.0.0.0/0</code> 으로 설정합니다. 프로토콜 및 포트는 <code>tcp</code> 를 선택하고 위에서 확인한 NodePort 를 설정합니다.</p><p><img src="sock-shop-main.png" alt="Sock Shop 메인 페이지"></p><p>그러면 <a href="http://34.85.95.211:30001">http://34.85.95.211:30001</a> 로 접속할 수 있게 됩니다.</p><h2 id="마무리">마무리</h2><p>이번 포스트에서는 GCE 를 이용해서 간단하게 서버 자원을 확보하고 Kubeadm 을 이용해 클러스터를 구성했습니다. 그 전에 쿠버네티스의 구성 요소도 간단하게 살펴봤습니다.</p><p>물론 직접 컨트롤하지 않고 사용하는 것이 위주라면 GKE(Google Kubernetes Engine)와 같이 완전관리형(Fully-managed) 쿠버네티스 서비스를 이용하는 것도 좋습니다만, 직접 수정하면서 테스트할 수 있는 클러스터를 구축해보는 것도 좋겠습니다.</p><p>다음 포스트에서는 쿠버네티스 기본 개념을 상세하게 다뤄보려고 합니다.</p><h2 id="참고">참고</h2><ul><li><a href="https://kubernetes.io/docs/setup/independent/create-cluster-kubeadm/">Creating a single master cluster with kubeadm</a></li><li><a href="https://kubernetes.io/docs/setup/independent/install-kubeadm/">Installing kubeadm</a></li><li><a href="https://microservices-demo.github.io">Sock Shop - Microservices Demo Application</a></li></ul><h2 id="Related-Posts">Related Posts</h2><ul><li><a href="/2018/11/09/it-infrastructure-basics/" title="개발자를 위한 인프라 기초 총정리">개발자를 위한 인프라 기초 총정리</a></li><li><a href="/2018/11/16/docker-container-basics/" title="도커 Docker 기초 확실히 다지기">도커 Docker 기초 확실히 다지기</a></li><li><a href="/2019/01/19/spring-boot-containerization-and-ci-cd-to-kubernetes-cluster/" title="스프링 부트 컨테이너와 CI&#x2F;CD 환경 구성하기">스프링 부트 컨테이너와 CI&#x2F;CD 환경 구성하기</a></li><li><a href="/2019/02/27/kubernetes-object-yaml-auto-backup-using-git-and-cronjob/" title="Git과 CronJob을 활용한 쿠버네티스 오브젝트 YAML 자동 백업">Git과 CronJob을 활용한 쿠버네티스 오브젝트 YAML 자동 백업</a></li></ul><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">https://kubernetes.io/docs/setup/cri/<a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">https://microservices-demo.github.io<a href="#fnref:2" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;p&gt;이제 개발자가 컨테이너 기반으로 애플리케이션을 개발하면서 도커(Doc</summary>
      
    
    
    
    <category term="Cloud" scheme="https://futurecreator.github.io/categories/Cloud/"/>
    
    
    <category term="container" scheme="https://futurecreator.github.io/tags/container/"/>
    
    <category term="kubernetes" scheme="https://futurecreator.github.io/tags/kubernetes/"/>
    
    <category term="gce" scheme="https://futurecreator.github.io/tags/gce/"/>
    
    <category term="google_cloud_platform" scheme="https://futurecreator.github.io/tags/google-cloud-platform/"/>
    
    <category term="centos" scheme="https://futurecreator.github.io/tags/centos/"/>
    
    <category term="vm" scheme="https://futurecreator.github.io/tags/vm/"/>
    
  </entry>
  
  <entry>
    <title>스프링 부트 컨테이너와 CI/CD 환경 구성하기</title>
    <link href="https://futurecreator.github.io/2019/01/19/spring-boot-containerization-and-ci-cd-to-kubernetes-cluster/"/>
    <id>https://futurecreator.github.io/2019/01/19/spring-boot-containerization-and-ci-cd-to-kubernetes-cluster/</id>
    <published>2019-01-19T08:40:16.000Z</published>
    <updated>2025-03-14T16:10:24.248Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>이번 포스트에서는 간단한 스프링 부트(Spring Boot) 애플리케이션을 만들고 컨테이너화(Containerize)하는 방법을 알아봅니다. 그리고 다양한 툴을 이용해 도커 이미지를 지속적으로 빌드하고 배포할 수 있는 CI/CD 환경을 구성하고 쿠버네티스(Kubernetes) 클러스터에 배포하는 과정을 살펴봅니다.</p><p>살펴볼 내용은 다음과 같습니다.</p><ul><li>컨테이너화 Containerization</li><li>스프링 부트 컨테이너화하기</li><li>도커 이미지 기반 CI/CD 환경 구성하기</li><li>첫 번째 환경: Google Cloud Build</li><li>두 번째 환경: GitLab + GKE</li><li>정리</li></ul><h2 id="컨테이너화-Containerization">컨테이너화 Containerization</h2><p><img src="virtual-machine-vs-container.png" alt="가상 머신과 컨테이너 비교"></p><p>컨테이너화는 애플리케이션을 컨테이너로 감싸는 작업을 말합니다. 컨테이너는 가상 머신(Virtual Machine)과는 다르게 게스트 OS 없이 호스트 OS 의 자원을 공유하므로 더 빠르고 리소스 사용이 효율적인 가상화 방식입니다. 이번 포스트에서는 대표적인 가상화 SW인 도커(Docker)로 컨테이너를 만듭니다. 도커로 애플리케이션과 해당 실행 환경을 감싸면 이미지 형태로 빌드할 수 있습니다. 따라서 도커만 설치되어 있으면 어디든 동일한 환경에서 애플리케이션을 실행할 수 있으므로 개발 및 배포, 운영 시 매우 용이합니다.</p><p>가상화와 도커에 대한 자세한 내용은 다음 포스트를 참고하세요.</p><ul><li><a href="/2018/11/09/it-infrastructure-basics/" title="개발자를 위한 인프라 기초 총정리">개발자를 위한 인프라 기초 총정리</a></li><li><a href="/2018/11/16/docker-container-basics/" title="도커 Docker 기초 확실히 다지기">도커 Docker 기초 확실히 다지기</a></li></ul><h2 id="스프링-부트-컨테이너화하기">스프링 부트 컨테이너화하기</h2><p>먼저 스프링 부트 애플리케이션을 만들고 컨테이너화 해봅시다.</p><h3 id="환경-준비">환경 준비</h3><p>실습에 사용할 리눅스 머신이 필요합니다. Mac, 가상 머신, AWS EC2 등 원하는 환경을 준비합니다. 이번 포스트에서는 로컬 환경에서 간단하게 VM을 사용할 수 있는  <a href="https://www.virtualbox.org">VirtualBox</a> 와 <a href="https://www.vagrantup.com">Vagrant</a> 로 실습 환경을 구성합니다. VirtualBox 는 VM을 만들고, Vagrant 는 VM 이미지와 설정 파일(<code>Vagrantfile</code>)로 가상 머신을 쉽게 설정하고 찍어낼 수 있습니다. 두 SW 를 설치한 후 실습을 진행합니다.</p><p>원하는 경로에 폴더를 만들고 초기화합니다.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ vagrant init</span><br><span class="line">A `Vagrantfile` has been placed <span class="keyword">in</span> this directory. You are now</span><br><span class="line">ready to `vagrant up` your first virtual environment! Please <span class="built_in">read</span></span><br><span class="line">the comments <span class="keyword">in</span> the Vagrantfile as well as documentation on</span><br><span class="line">`vagrantup.com` <span class="keyword">for</span> more information on using Vagrant.</span><br></pre></td></tr></table></figure><p>생성된 <code>Vagrantfile</code> 을 수정합니다.</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Vagrant</span>.configure(<span class="string">&quot;2&quot;</span>) <span class="keyword">do</span> |<span class="params">config</span>|</span><br><span class="line">  config.vm.box = <span class="string">&quot;centos/7&quot;</span></span><br><span class="line">  config.vm.network <span class="string">&quot;forwarded_port&quot;</span>, <span class="symbol">guest:</span> <span class="number">80</span>, <span class="symbol">host:</span> <span class="number">8000</span></span><br><span class="line">  config.vm.network <span class="string">&quot;private_network&quot;</span>, <span class="symbol">ip:</span> <span class="string">&quot;192.168.33.10&quot;</span></span><br><span class="line">  config.vm.synced_folder <span class="string">&quot;.&quot;</span>, <span class="string">&quot;/vagrant&quot;</span>, <span class="symbol">disabled:</span> <span class="literal">true</span></span><br><span class="line">  config.vm.provision <span class="string">&quot;docker&quot;</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><ul><li><code>config.vm.box</code>: 가상 환경에서 사용할 박스 이미지를 설정합니다. CentOS 7을 사용합니다. <a href="https://app.vagrantup.com/boxes/search">Vagrant Cloud</a> 에서 원하는 박스 이미지를 검색할 수 있습니다.</li><li><code>config.vm.network &quot;forwarded_port&quot;</code>: 게스트의 <code>80</code>과 호스트의 <code>8000</code> 포트를 연결합니다.</li><li><code>config.vm.network &quot;forwarded_port&quot;</code>: 게스트의 <code>80</code>과 호스트의 <code>8000</code> 포트를 연결합니다.</li><li><code>config.vm.provision &quot;docker&quot; </code>: 도커를 자동으로 설치합니다. 따라서 VM에 따로 도커를 설치할 필요가 없습니다.</li></ul><p><code>vagrant up</code> 으로 VM 을 실행합니다.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">vagrant up</span><br><span class="line">Bringing machine <span class="string">&#x27;default&#x27;</span> up with <span class="string">&#x27;virtualbox&#x27;</span> provider...</span><br><span class="line">==&gt; default: Importing base box <span class="string">&#x27;centos/7&#x27;</span>...</span><br><span class="line">==&gt; default: Matching MAC address <span class="keyword">for</span> NAT networking...</span><br><span class="line">==&gt; default: Checking <span class="keyword">if</span> box <span class="string">&#x27;centos/7&#x27;</span> is up to <span class="built_in">date</span>...</span><br><span class="line">==&gt; default: A newer version of the box <span class="string">&#x27;centos/7&#x27;</span> <span class="keyword">for</span> provider <span class="string">&#x27;virtualbox&#x27;</span> is</span><br><span class="line">==&gt; default: available! You currently have version <span class="string">&#x27;1811.02&#x27;</span>. The latest is version</span><br><span class="line">==&gt; default: <span class="string">&#x27;1812.01&#x27;</span>. Run `vagrant box update` to update.</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><code>vagrant ssh</code> 로 VM에 SSH 접속할 수 있습니다. 접속 후에는  <code>sudo su -</code> 를 이용해 root 로 접속할 수 있습니다.</p><p>마지막으로 실습을 편하게 진행하기 위해 Java 와 Git 도 설치합시다.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> su -</span><br><span class="line">yum update -y</span><br><span class="line">yum install -y java-1.8.0-openjdk-devel.x86_64</span><br><span class="line">yum install -y git</span><br></pre></td></tr></table></figure><p>이제 Docker, Java, Git이 설치된 VM 을 사용할 수 있습니다.</p><h3 id="스프링-부트-애플리케이션-만들기">스프링 부트 애플리케이션 만들기</h3><p>실습에 사용할 간단한 스프링 부트 애플리케이션을 작성합니다. <a href="https://start.spring.io">Spring Initializr</a> 로 프로젝트를 만들면 필요한 초기 설정을 쉽게 구성할 수 있습니다.<br><img src="spring-initializr.png" alt="Spring Initalizr로 프로젝트 만들기"><br>위 그림과 같이 설정한 후 <strong>Generate Project</strong> 로 생성된 압축 파일을 다운로드합니다.</p><p>압축 파일을 풀고 해당 폴더에서 <code>mvnw spring-boot:run</code>으로 바로 실행해봅시다. 여기선 maven 을 사용하지만 gradle 을 사용해도 좋습니다.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ ./mvnw spring-boot:run</span><br><span class="line">[INFO] Scanning <span class="keyword">for</span> projects...</span><br><span class="line">[INFO] </span><br><span class="line">[INFO] ----------------------&lt; com.docker.example:hello &gt;----------------------</span><br><span class="line">[INFO] Building hello 0.0.1-SNAPSHOT</span><br><span class="line">[INFO] --------------------------------[ jar ]---------------------------------</span><br><span class="line">[INFO] </span><br><span class="line">[INFO] &gt;&gt;&gt; spring-boot-maven-plugin:2.1.1.RELEASE:run (default-cli) &gt; test-compile @ hello &gt;&gt;&gt;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><code>controller</code> 패키지를 만들고 <code>/</code> 요청을 받을 <code>HelloController</code> 를 만듭니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.docker.example.hello.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloController</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@RequestMapping(&quot;/&quot;)</span></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hello, Docker!&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>pom.xml</code> 파일에 플러그인 설정을 추가합니다. 해당 설정이 없으면 VM 이나 컨테이너 환경에서 빌드(테스트) 시 에러가 발생합니다.</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-surefire-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">useSystemClassLoader</span>&gt;</span>false<span class="tag">&lt;/<span class="name">useSystemClassLoader</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>Vagrantfile</code> 에 파일을 옮기는 설정을 추가합니다.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">config.vm.provision &quot;file&quot;, source: &quot;./hello&quot;, destination: &quot;$HOME/hello&quot;</span><br></pre></td></tr></table></figure><p>Vagrant 를 프로비저닝해서 소스를 옮깁니다.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vagrant up</span><br></pre></td></tr></table></figure><p>환경과 소스를 모두 준비했습니다.</p><h3 id="컨테이너로-감싸기">컨테이너로 감싸기</h3><p>이제 해당 애플리케이션을 감싸기 위한 실행 환경을 정의합니다. 이를 <code>Dockerfile</code> 에 정의합니다.</p><p><code>Dockerfile</code> 을 작성합니다.</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> openjdk:<span class="number">8</span>-jre-alpine</span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> target/*.jar app.jar</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;java&quot;</span>,<span class="string">&quot;-jar&quot;</span>,<span class="string">&quot;/app.jar&quot;</span>]</span></span><br></pre></td></tr></table></figure><p>도커는 베이스 이미지(<code>FROM</code>)를 기반으로 설정한 항목을 수행하면서 변경 사항을 이미지 레이어로 저장합니다.</p><ul><li><code>FROM</code>: 가벼운 리눅스인 alpine 에 openjdk 8 이 설치된 이미지입니다.</li><li><code>COPY</code>: 컨테이너 안으로 파일을 복사합니다.</li><li><code>ENTRYPOINT</code>: 컨테이너를 실행할 때 수행할 명령어 입니다.</li></ul><p>먼저 메이븐 빌드를 수행합니다.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./mvnw install</span><br></pre></td></tr></table></figure><p>도커 이미지를 빌드합니다.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t myorg/myapp .</span><br></pre></td></tr></table></figure><p>그러면 <code>myorg/myapp</code> 이라는 태그가 달린 이미지가 생성됩니다.</p><p>도커 이미지를 실행합니다.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 8000:8080 myorg/myapp</span><br><span class="line">a6a7955807288a90943b95b5520466e66d7de3ff2bee07a611627fba85c1aae8</span><br></pre></td></tr></table></figure><ul><li><code>-d</code> : 백그라운드에서 실행합니다.</li><li><code>-p</code> : <code>&lt;호스트 포트&gt;:&lt;컨테이너 포트&gt;</code> 형식으로 작성합니다.</li><li><code>a6a795580728</code>: 실행 시 해당 컨테이너 ID가 출력됩니다.</li></ul><p>도커가 실행되는 컨테이너를 확인합니다.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CONTAINER ID        IMAGE               COMMAND                CREATED             STATUS              PORTS                    NAMES</span><br><span class="line">a6a795580728        myorg/myapp         <span class="string">&quot;java -jar /app.jar&quot;</span>   5 seconds ago       Up 4 seconds        0.0.0.0:8000-&gt;8080/tcp   silly_merkle</span><br></pre></td></tr></table></figure><p>접속을 확인해봅시다. 고정 IP로 설정한 <code>http://192.168.33.10:8000</code> 로 접속하면 화면을 볼 수 있습니다.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl localhost:8000</span><br><span class="line">Hello, Docker!</span><br></pre></td></tr></table></figure><p>컨테이너 내부로 들어가면 <code>app.jar</code> 를 확인할 수 있습니다.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --entrypoint /bin/sh myorg/myapp</span><br><span class="line">/ <span class="comment"># ls</span></span><br><span class="line">app.jar  dev      home     media    proc     run      srv      tmp      var</span><br><span class="line">bin      etc      lib      mnt      root     sbin     sys      usr</span><br></pre></td></tr></table></figure><h3 id="Dockerfile-개선하기">Dockerfile 개선하기</h3><p>스프링 애플리케이션을 아주 쉽게 컨테이너로 만들었습니다. 하지만 지금 이미지는 조금 비효율적입니다. 도커가 이미지를 만드는 방식과 관련이 있습니다.</p><p>도커는 이미지를 빌드하는 과정을 이미지를 여러 겹의 레이어로 구성하고, 수정이 있는 레이어만 다시 작업합니다. 나머지 수정이 없는 레이어는 캐시해놓은 것을 사용하기 때문에 빠르게 빌드할 수 있습니다. 하지만 우리 JAR 파일 안에는 각종 디펜던시가 함께 들어가 있기 때문에 도커 이미지에는 하나의 레이어만 생성되고, 애플리케이션이 수정될 때마다 해당 레이어가 변경됩니다.</p><p>다음은 이미지의 레이어를 <code>docker inspect</code> 명령어로 확인한 모습입니다. 마지막 레이어가 우리 애플리케이션의 레이어입니다.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot;Layers&quot;: [</span><br><span class="line">&quot;sha256:7bff100f35cb359a368537bb07829b055fe8e0b1cb01085a3a628ae9c187c7b8&quot;,</span><br><span class="line">&quot;sha256:dbc783c89851d29114fb01fd509a84363e2040134e45181354051058494d2453&quot;,</span><br><span class="line">&quot;sha256:382d47ad6dc1ef98fc8d97372af64fc4f06c39de5edb9d6ba5a3315ce87def51&quot;,</span><br><span class="line">&quot;sha256:d180830db04728775d84bc906de568cb552bbfce823e835168c6e63b7905db4f&quot;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>이제 하나로 구성된 레이어를 여러 개의 레이어로 나눠봅시다.</p><p>먼저 디펜던시를 각각 복사할 수 있도록 폴더를 생성하고 JAR 압축을 풉니다.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> target/dependency</span><br><span class="line"><span class="built_in">cd</span> target/dependency</span><br><span class="line">jar -xvf ../*.jar</span><br></pre></td></tr></table></figure><p><code>Dockerfile</code> 을 수정합니다. 각 디펜던시를 <code>COPY</code> 하는 작업이 하나의 레이어가 됩니다.</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> openjdk:<span class="number">8</span>-jre-alpine</span><br><span class="line"><span class="keyword">ARG</span> DEPENDENCY=target/dependency</span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> <span class="variable">$&#123;DEPENDENCY&#125;</span>/BOOT-INF/lib /app/lib</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> <span class="variable">$&#123;DEPENDENCY&#125;</span>/META-INF /app/META-INF</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> <span class="variable">$&#123;DEPENDENCY&#125;</span>/BOOT-INF/classes /app</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;java&quot;</span>,<span class="string">&quot;-cp&quot;</span>,<span class="string">&quot;app:app/lib/*&quot;</span>,<span class="string">&quot;com.docker.example.hello.HelloApplication&quot;</span>]</span></span><br></pre></td></tr></table></figure><p>다시 도커 이미지를 빌드합니다.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t myorg/myapp .</span><br></pre></td></tr></table></figure><p>이미지를 확인해보면 레이어가 늘어난 것을 확인할 수 있습니다.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&quot;Layers&quot;: [</span><br><span class="line">&quot;sha256:7bff100f35cb359a368537bb07829b055fe8e0b1cb01085a3a628ae9c187c7b8&quot;,</span><br><span class="line">&quot;sha256:dbc783c89851d29114fb01fd509a84363e2040134e45181354051058494d2453&quot;,</span><br><span class="line">&quot;sha256:382d47ad6dc1ef98fc8d97372af64fc4f06c39de5edb9d6ba5a3315ce87def51&quot;,</span><br><span class="line">&quot;sha256:b1d7f7bd343054042f9c7f2847822f97749b14541f867137a53aca86e68f5d41&quot;,</span><br><span class="line">&quot;sha256:c40aca1731d0acd8b9b885b5196e2bc0e697eee03f03322fb91cb6ec5ab4816f&quot;,</span><br><span class="line">&quot;sha256:c2d77979785785ac75e5151e80679c91299a08b7e3f24d2dd0a1914fa26741cd&quot;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>이 방법은 압축을 해제하는 과정이 필요하므로, 이후 실습에서는 편의를 위해 첫 번째 방법으로 진행합니다.</p><h2 id="도커-이미지-기반-CI-CD-환경-구성하기">도커 이미지 기반 CI/CD 환경 구성하기</h2><p>이번에는 코드를 관리하고 도커 이미지 기반의 CI/CD 환경을 구성해봅시다.</p><h3 id="구성-요소">구성 요소</h3><ol><li>코드와 <code>Dockerfile</code> 을 함께 관리하고 CI 서버를 이용해 코드가 푸시될 때마다 해당 코드를 도커 이미지로 빌드합니다.</li><li>빌드한 이미지는 이미지 레지스트리(Image Registry)에 따로 저장해서 보관합니다.</li><li>빌드한 이미지를 컨테이너로 쿠버네티스(Kubernetes) 클러스터에 배포합니다.</li></ol><p>필요한 구성 요소는 다음과 같습니다.</p><table><thead><tr><th>도구</th><th>서비스</th></tr></thead><tbody><tr><td>소스 코드 관리</td><td><a href="https://github.com">GitHub</a>, <a href="https://gitlab.com">GitLab</a>, <a href="https://aws.amazon.com/ko/codestar/">AWS CodeStar</a>, <a href="https://cloud.google.com/source-repositories/">Google Cloud Source Repository</a>, etc.</td></tr><tr><td>코드를 push 할 때마다 자동으로 빌드하고 배포할 CI/CD 파이프라인</td><td><a href="https://aws.amazon.com/ko/codepipeline/">AWS CodePipeline</a>, <a href="https://cloud.google.com/cloud-build/">Google Cloud Build</a>, <a href="https://about.gitlab.com/product/continuous-integration/">GitLab CI/CD</a>, <a href="https://jenkins.io">Jenkins</a>, etc.</td></tr><tr><td>빌드한 이미지를 저장할 프라이빗 도커 레지스트리(Private Docker Registry)</td><td><a href="https://aws.amazon.com/ko/ecr/">Amazon Elastic Container Registry</a>, <a href="https://cloud.google.com/container-registry/">Google Container Registry</a>, <a href="https://docs.gitlab.com/ee/user/project/container_registry.html">GitLab Container Registry</a>, etc.</td></tr><tr><td>빌드 결과를 배포할 쿠버네티스(Kubernetes) 클러스터</td><td><a href="https://cloud.google.com/kubernetes-engine/">Google Kubernetes Engine</a>, <a href="https://aws.amazon.com/ko/eks/">Amazon Elastic Container Service for Kubernetes</a>, etc.</td></tr></tbody></table><p>이를 구성하는 방법은 여러가지가 있습니다. 이번 포스트에서는 다양한 시나리오를 살펴보기 위해 다음과 같이 세 가지 방법으로 구성해보겠습니다.</p><ul><li>Google Cloud Build</li><li>GCP와 Dockerfile</li><li>GItLab + GKE</li></ul><h3 id="쿠버네티스-Kubernetes">쿠버네티스 Kubernetes</h3><p><img src="kubernetes.png" alt="https://kubernetes.io"></p><p>도커 컨테이너는 도커만 설치되어 있으면 동작합니다. 하지만 분산 환경에서 많은 컨테이너를 관리하는 것은 쉽지 않습니다. 따라서 주로 도커 컨테이너를 그냥 사용하기보다는 쿠버네티스라는 컨테이너 플랫폼 위에서 실행합니다.</p><p>쿠버네티스는 분산 환경의 많은 컨테이너를 쉽게 관리할 수 있는 오케스트레이션(Orchestration) 툴로 알려져 있습니다. 하지만 쿠버네티스는 단순한 오케스트레이션 툴을 넘어 하나의 플랫폼으로 빠르게 발전했습니다. 이제는 많은 기업들이 컨테이너 운영 환경에 쿠버네티스를 도입해 사용하고 있습니다. 자세한 내용은 이후 쿠버네티스 관련 포스트에서 따로 다루도록 하겠습니다.</p><ul><li>여러 노드를 하나의 노드처럼 관리</li><li>노드의 부하를 확인해 컨테이너를 어디에 배포할 지 스케쥴링(scheduling)</li><li>컨테이너의 상태를 체크해 자동 복구(self healing)</li><li>부하에 따라 오토 스케일링(auto scaling)</li></ul><p>쿠버네티스는 구글에서 시작된 오픈소스로, 구글의 15년 이상의 컨테이너 운영 경험이 녹아 있습니다. Google Kubernetes Engine 은 <a href="https://cloud.google.com">Google Cloud Platform</a> 에서 제공하는 완전관리형(fully-managed) 쿠버네티스 클러스터로 Google SRE 가 관리하며 쿠버네티스의 최신 버전을 자동으로 적용하기 때문에 다른 관리 없이 편하게 사용이 가능합니다.</p><p>이번 포스트는 쿠버네티스 클러스터를 구성하고 관리하는 것이 목적이 아니므로 GKE 로 애플리케이션을 배포하겠습니다.</p><h2 id="첫-번째-환경-Google-Cloud-Build">첫 번째 환경: Google Cloud Build</h2><p>첫 번째로 구성해볼 환경은 GitHub 와 Google Cloud Build 를 이용한 구성입니다.</p><p><img src="github-cloudbuild.png" alt="GitHub 와 Cloud Build 를 이용한 CI/CD 구성"></p><ol><li>개발자가 코드를 작성하고 GitHub 으로 푸시합니다.</li><li>코드가 변경될 때마다 GitHub 와 연동된 Cloud Build 트리거가 실행됩니다.</li><li><code>cloudbuild.yaml</code> 에 정의된 빌드 작업을 수행합니다.</li><li>빌드 결과 생성된 도커 이미지를 컨테이너 레지스트리에 푸시합니다.</li><li>이미지를 GKE 클러스터에 배포합니다.</li></ol><h3 id="1-GitHub-저장소-준비하기">1. GitHub 저장소 준비하기</h3><p>먼저 코드를 저장할 GitHub 부터 준비합시다.</p><p>GitHub에 새로운 저장소를 생성합니다.<br><img src="create-github-repository.png" alt="GitHub 저장소 생성하기"></p><p>소스에서 Git 을 초기화합니다.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br><span class="line">Initialized empty Git repository <span class="keyword">in</span> /home/vagrant/hello/.git/</span><br></pre></td></tr></table></figure><p>새로 만든 저장소를 remote 저장소로 추가합니다.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin https://github.com/futureCreator/spring-boot-container.git</span><br></pre></td></tr></table></figure><p>저장소의 내용을 커밋하고 푸시합니다.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;# spring-boot-container&quot; &gt;&gt; README.md</span><br><span class="line">git add .</span><br><span class="line">git commit -m &quot;first commit&quot;</span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure><p>코드는 모두 준비됐습니다.</p><h3 id="2-트리거-생성하기">2. 트리거 생성하기</h3><p><a href="https://cloud.google.com/cloud-build/?hl=ko">Google Cloud Build</a>는 따로 빌드 환경을 구축할 필요 없이 간단하게 빌드할 수 있고, 구글의 서비스와 쉽게 통합할 수 있는 빌드 서비스입니다. GitHub와 연동해서 소스가 변경될 때 빌드를 트리거해서 시작하고, 빌드 과정을 <code>cloudbuild.yaml</code>에 정의하면 자동으로 빌드가 생성됩니다.</p><p>이후 실습에서 GCP 를 사용하면서 요금이 발생할 수 있습니다. GCP 는 가입 시 1년 동안 사용할 수 있는 $300 크레딧을 제공하므로 실습에는 큰 문제가 없을 겁니다. 회원 가입 후 새로운 프로젝트를 생성합니다.</p><p>GCP 는 사용하고자 하는 서비스의 API를 미리 활성화해야 합니다. API 매니저로 접속해서 Cloud Build API, Kubernetes Engine API, Container Registry API 등 실습하면서 필요할 때마다 해당 API 를 활성화하면 됩니다.</p><p>이제 빌드 트리거를 생성해봅시다. 먼저 GCP 검색 창에 ‘Cloud 빌드’를 검색하고 트리거 메뉴로 들어갑니다. <strong>트리거 만들기</strong>를 누르고 <strong>GitHub</strong> 를 선택합니다. 인증을 하면 해당 계정의 저장소가 나타나는데 위에서 만든 저장소를 선택합니다.</p><p>그리고 다음과 같이 트리거를 생성합니다. <code>cloudbuild.yaml</code> 파일로 빌드를 설정할 겁니다.</p><p><img src="cloud-build-trigger.png" alt="빌드 트리거 생성하기"></p><p>이제 모든 브랜치에 푸시될 경우 해당 트리거가 실행됩니다. 물론 콘솔에서 직접 수동으로 실행할 수도 있고 터미널에서 실행할 수도 있습니다.</p><h3 id="3-빌드하기">3. 빌드하기</h3><p>이제 빌드 작업을 <code>cloudbuild.yaml</code>에 작성할 차례입니다.</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">steps:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">&#x27;gcr.io/cloud-builders/mvn&#x27;</span></span><br><span class="line">  <span class="attr">args:</span> [<span class="string">&#x27;install&#x27;</span>]</span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">&#x27;gcr.io/cloud-builders/docker&#x27;</span></span><br><span class="line">  <span class="attr">args:</span> [<span class="string">&#x27;build&#x27;</span>, <span class="string">&#x27;-t&#x27;</span>, <span class="string">&#x27;gcr.io/spring-boot-container/spring-boot-container-test&#x27;</span>, <span class="string">&#x27;.&#x27;</span>]</span><br><span class="line">  <span class="attr">timeout:</span> <span class="string">500s</span></span><br><span class="line"><span class="attr">options:</span></span><br><span class="line">  <span class="attr">machineType:</span> <span class="string">&#x27;N1_HIGHCPU_8&#x27;</span> <span class="comment"># HIGHCPU로 빌드 스피드 업</span></span><br><span class="line"><span class="attr">timeout:</span> <span class="string">1000s</span> <span class="comment"># 빌드 자체에 대한 타임 아웃</span></span><br></pre></td></tr></table></figure><ul><li>각 스텝의 <code>name</code>은 빌드에 사용하는 이미지를 나타냅니다(cloud-builders). 해당 이미지의 컨테이너에서 빌드가 수행됩니다.</li><li>먼저 <code>mvn</code> 이미지에서 <code>install</code> 작업이 수행되고 <code>docker</code> 이미지에서 빌드를 수행합니다.</li></ul><p>파일을 생성하고 푸시하면 트리거가 작동해서 빌드가 수행됩니다.</p><p><img src="build-phase.png" alt="Cloud Build 결과"></p><h3 id="4-Container-Registry-에-이미지-푸시하기">4. Container Registry 에 이미지 푸시하기</h3><p>컨테이너의 장점 중 하나는 해당 이미지를 재활용할 수 있다는 점입니다. 자주 사용하는 이미지를 저장해놓고 언제든 내려받아 컨테이너로 실행할 수 있습니다. 이러한 이미지 저장소를 Docker Registry 또는 Container Registry 라고 합니다. Docker Hub 는 도커에서 운영하는 대표적인 컨테이너 레지스트리입니다.</p><p>이 외에도 클라우드 프로바이더는 private한 레지스트리를 제공합니다. AWS 의 Elastic Container Registry, GCP 의 Google Container Registry 가 있습니다. 이러한 레지스트리는 취약점 스캔, 위험한 이미지 자동 잠금, 자사 서비스와의 통합 등 부가 기능을 제공합니다. 특히 컨테이너는 애플리케이션과 환경을 함께 저장하므로 보안에 취약한데 이를 보완해주는 기능을 제공합니다.</p><p>Container Registry 를 사용하는 방법은 간단합니다. 위에서 본 것처럼 도커 이미지 빌드 시에 <code>[HOSTNAME]/[PROJECT-ID]/[IMAGE]:[TAG]</code> 형태로 태그를 달게 되는데요, 기본적으로 도커 허브(<code>docker.io</code>)가 적용됩니다. 우리는 Google Container Registry 에 맞는 태그를 달고 푸시해주면 됩니다.</p><p><code>cloudbuild.yaml</code> 해당 작업을 추가합시다.</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">steps:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">&#x27;gcr.io/cloud-builders/mvn&#x27;</span></span><br><span class="line">  <span class="attr">args:</span> [<span class="string">&#x27;install&#x27;</span>]</span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">&#x27;gcr.io/cloud-builders/docker&#x27;</span></span><br><span class="line">  <span class="attr">args:</span> [<span class="string">&#x27;build&#x27;</span>, <span class="string">&#x27;-t&#x27;</span>, <span class="string">&#x27;gcr.io/spring-boot-container/spring-boot-container-test&#x27;</span>, <span class="string">&#x27;.&#x27;</span>]</span><br><span class="line">  <span class="attr">timeout:</span> <span class="string">500s</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">&#x27;gcr.io/cloud-builders/docker&#x27;</span></span><br><span class="line">  <span class="attr">args:</span> [<span class="string">&#x27;push&#x27;</span>, <span class="string">&#x27;gcr.io/spring-boot-container/spring-boot-container-test&#x27;</span>]</span><br><span class="line"><span class="attr">options:</span></span><br><span class="line">  <span class="attr">machineType:</span> <span class="string">&#x27;N1_HIGHCPU_8&#x27;</span> <span class="comment"># HIGHCPU로 빌드 스피드 업</span></span><br><span class="line"><span class="attr">timeout:</span> <span class="string">1000s</span> <span class="comment"># 빌드 자체에 대한 타임 아웃</span></span><br></pre></td></tr></table></figure><ul><li>도커 빌드 시 태그명의 <code>gcr.io</code> 가 바로 Google Container Registry 입니다.</li><li><code>docker push</code> 를 하면 해당 태그에 맞춰서 저장소에 추가됩니다.</li></ul><p>빌드 작업 후 컨테이너 이미지가 추가된 것을 확인할 수 있습니다. 새로운 이미지는 <code>latest</code> 라는 태그가 자동으로 추가됩니다.</p><p><img src="container-registry-image.png" alt="컨테이너 이미지가 추가된 모습"></p><h3 id="5-Kubernetes-Engine-에-배포하기">5. Kubernetes Engine 에 배포하기</h3><p>지금까지 지속적인 통합(Continuous Integration) 환경을 구축했고 지속적인 배포(Continuous Deployment) 환경을 구축해봅시다.</p><p>빌드한 이미지를 쿠버네티스 클러스터에 Deployment 오브젝트로 배포합니다. 쿠버네티스의 Deployment 는 컨테이너 단위인 Pod 과 컨테이너의 개수를 유지해주는 ReplicaSet 을 포함하고, 배포 시 롤링 업데이트<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="롤링 업데이트(Rolling Update)란 기존 서비스를 유지하면서 업데이트하기 위한 방법으로, 여러 개의 인스턴스가 있을 때 하나씩 새로운 버전의 인스턴스로 교체하는 방법입니다.">[1]</span></a></sup> 을 지원합니다. 또한 Deployment 를 노출(expose)해서 외부에서 접근하는 서비스를 생성할 수 있습니다.</p><p>콘솔에서 GKE에 접속해 <strong>작업부하</strong> 메뉴에서 <strong>배포</strong>를 클릭해 새로운 배포를 생성합니다.</p><p><strong>Google Container Registry 이미지 선택</strong>을 클릭해 빌드한 이미지를 선택하고 <strong>완료</strong>를 클릭해 컨테이너를 추가합니다.</p><p>추가 정보를 작성합니다. 클러스터는 기존 클러스터를 생성해도 되지만 새로운 클러스터를 생성하겠습니다.<br><img src="create-k8s-deployment.png" alt="클러스터 정보"></p><p>클러스터가 생성되길 기다리면서 IAM에 권한을 추가합시다. Cloud Build의 서비스 계정이 클러스터에 접근해야 하므로 역할(권한)을 추가해줘야 합니다. <strong>IAM 및 관리자</strong> 메뉴에서 <strong>Cloud 빌드 서비스 계정</strong>의 권한에 <strong>Kubernetes Engine 관리자</strong> 역할을 추가합니다.<br><img src="iam-cloud-build-role.png" alt="Kubernetes Engine 관리자 역할 추가"></p><p><code>cloudbuild.yaml</code> 에 배포 작업을 추가합시다.</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">steps:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">&#x27;gcr.io/cloud-builders/mvn&#x27;</span></span><br><span class="line">  <span class="attr">args:</span> [<span class="string">&#x27;install&#x27;</span>]</span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">&#x27;gcr.io/cloud-builders/docker&#x27;</span></span><br><span class="line">  <span class="attr">args:</span> [<span class="string">&#x27;build&#x27;</span>, <span class="string">&#x27;-t&#x27;</span>, <span class="string">&#x27;gcr.io/spring-boot-container/spring-boot-container-test&#x27;</span>, <span class="string">&#x27;.&#x27;</span>]</span><br><span class="line">  <span class="attr">timeout:</span> <span class="string">500s</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">&#x27;gcr.io/cloud-builders/docker&#x27;</span></span><br><span class="line">  <span class="attr">args:</span> [<span class="string">&#x27;push&#x27;</span>, <span class="string">&#x27;gcr.io/spring-boot-container/spring-boot-container-test&#x27;</span>]</span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">&#x27;gcr.io/cloud-builders/kubectl&#x27;</span></span><br><span class="line">  <span class="attr">args:</span> </span><br><span class="line">  <span class="bullet">-</span> <span class="string">set</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">image</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">deployment/spring-boot-container</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">spring-boot-container-test=gcr.io/spring-boot-container/spring-boot-container-test</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">-n</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">spring-boot</span></span><br><span class="line">  <span class="attr">env:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&#x27;CLOUDSDK_COMPUTE_ZONE=us-central1-a&#x27;</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&#x27;CLOUDSDK_CONTAINER_CLUSTER=spring-boot-container-cluster&#x27;</span></span><br><span class="line"><span class="attr">options:</span></span><br><span class="line">  <span class="attr">machineType:</span> <span class="string">&#x27;N1_HIGHCPU_8&#x27;</span> <span class="comment"># HIGHCPU로 빌드 스피드 업</span></span><br><span class="line"><span class="attr">timeout:</span> <span class="string">1000s</span> <span class="comment"># 빌드 자체에 대한 타임 아웃</span></span><br></pre></td></tr></table></figure><ul><li><code>kubectl set image</code> 명령어를 이용해 컨테이너 이미지를 변경합니다.</li><li><code>CLOUDSDK_COMPUTE_ZONE</code>: 클러스터를 생성한 지역입니다.</li><li><code>CLOUDSDK_CONTAINER_CLUSTER</code>: 생성한 클러스터명입니다.</li><li><code>-n spring-boot</code>: 해당 Deployment 가 있는 namespace 를 지정합니다.</li></ul><p>이제 빌드 후 이미지가 새로 생성되면, 클러스터에서 새로운 이미지를 기반으로 Pod 이 새로 생성됩니다.<br><img src="cloud-build-result.png" alt="빌드 및 배포 결과"></p><p>새로운 이미지가 배포되어 Pod이 새로 생성된 것을 볼 수 있습니다.<br><img src="kubectl-deploy-result.png" alt="배포 결과 확인"></p><p>첫 번째 환경으로 GitHub와 Cloud Build를 이용해서 배포하는 환경을 구축해봤습니다. 각 단계별로 수정해볼만한 항목입니다.</p><ul><li>GitHub와 연동한 저장소는 Google Code Source Repository 에서도 확인할 수 있습니다. 물론 GitHub 대신 여기서 저장소를 생성해서 사용할 수도 있습니다.</li><li><code>cloudbuild.yaml</code> 에서 빌드 작업을 정의했습니다. 빌드 작업을 하나의 YAML 파일로 관리할 수 있어 편리했습니다. 메이븐 빌드는 <code>Dockerfile</code> 에서 수행하도록 수정할 수도 있습니다.</li><li>컨테이너 레지스트리는 다른 레지스트리를 사용할 수도 있지만 GCP 서비스와 연동이 잘 되는 Google Container Registry를 사용했습니다. 또한 취약점 검사를 적용해볼 수도 있고, 해당 이미지를 공개하면 다른 곳에서도 사용할 수 있습니다.</li><li>GKE는 쿠버네티스에 친숙하지 않더라도 쉽게 사용할 수 있도록 웹 UI에서 다양한 기능을 제공하고 있습니다. 이 외에도 Deployment 를 노출해 서비스를 만들 수도 있습니다.</li><li>빌드 과정에서 <code>mvn test</code> 를 수행하며 단위 테스트를 수행합니다. 실운영 환경에서는 빌드 과정에서 빌드 및 통합 테스트 스텝을 추가하는 것이 좋습니다.</li></ul><h2 id="두-번째-환경-GitLab-GKE">두 번째 환경: GitLab + GKE</h2><p>이번에는 GitLab 위주의 환경을 구성해보겠습니다.</p><p><img src="gitlab-cicd.png" alt="GitLab 과 GKE 를 이용한 CI/CD 구성"></p><p>GitLab은 GitHub에 비해 많이 사용되진 않지만 상당히 유용한 도구입니다. GitHub 처럼 다른 도구와 연동을 많이 제공하진 않지만 GitLab 자체에서 CI/CD 기능을 지원하고 Container Registry 도 지원합니다. 또한 GKE 와 연동해 클러스터의 상태를 바로 확인할 수 있습니다. 코드 저장소에서 빌드 파이프라인과 배포 상태까지 확인하는 것은 상당히 유용합니다.</p><h3 id="1-GitLab-저장소-준비하기">1. GitLab 저장소 준비하기</h3><p>두 번째 환경은 대부분 GitLab에서 지원하는 기능을 사용하기 때문에 설정이 더 간단합니다.</p><p>GitLab 저장소를 새로 만듭니다. 그리고 위에서 사용한 소스에 origin 을 새로 추가하고 푸시합니다.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git remote add gitlab_origin https://gitlab.com/futureCreator/spring-boot-container.git</span><br><span class="line">git push -u gitlab_origin master</span><br></pre></td></tr></table></figure><p>저장소는 간단하게 준비했습니다.</p><h3 id="2-메이븐-빌드하기">2. 메이븐 빌드하기</h3><p>먼저 메이븐 빌드를 먼저 정의합니다.</p><p>코드를 푸시하면 GitLab 대시보드에서 다음과 같은 화면을 볼 수 있습니다.<br><img src="gitlab-dashboard.png" alt="GitLab 대시보드"></p><p><strong>Set up CI/CD</strong> 를 클릭하면 <code>.gitlab-cicd.yml</code> 파일을 작성하는 화면으로 넘어갑니다. 위에서 작성한 <code>cloudbuild.yaml</code> 처럼 빌드 작업을 정의하는 파일입니다. 해당 파일을 작성하면 자동으로 CI/CD 가 적용됩니다.<sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="빌드 설정이 친숙하지 않은 개발자를 위해 사전에 정의된 CI/CD 설정으로 빌드 작업을 자동화하는 [Auto DevOps](https://about.gitlab.com/product/auto-devops/)라는 기능도 있습니다. `Auto Build`, `Auto Test`, `Auto Deploy` 등 기능을 제공합니다. GitLab 11.3부터 모든 프로젝트에 Auto DevOps가 기본적으로 설정되어 있어 코드를 처음 올리면 파이프라인 작업이 수행됩니다. 물론 완벽히 구성하지 않은 상태여서 첫 번째 파이프라인 작업이 실패한다면 해당 설정은 disabled 됩니다.">[2]</span></a></sup></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">image:</span> <span class="string">docker:latest</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">docker:dind</span></span><br><span class="line"></span><br><span class="line"><span class="attr">variables:</span></span><br><span class="line">  <span class="attr">DOCKER_DRIVER:</span> <span class="string">overlay</span></span><br><span class="line">  <span class="attr">SPRING_PROFILES_ACTIVE:</span> <span class="string">gitlab-ci</span></span><br><span class="line"></span><br><span class="line"><span class="attr">stages:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">build</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">package</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">deploy</span></span><br><span class="line"></span><br><span class="line"><span class="attr">maven-build:</span></span><br><span class="line">  <span class="attr">image:</span> <span class="string">maven:3-jdk-8</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">build</span></span><br><span class="line">  <span class="attr">script:</span> <span class="string">&quot;mvn install&quot;</span></span><br><span class="line">  <span class="attr">artifacts:</span></span><br><span class="line">    <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">target/*.jar</span></span><br></pre></td></tr></table></figure><p>해당 커밋에 대해 빌드 파이프라인이 생성됩니다. <strong>CI/CD &gt; Pipeline</strong> 화면에서 파이프라인의 빌드와 잡을 확인할 수 있습니다.<br><img src="gitlab-maven-build.png" alt="GitLab 메이븐 빌드"></p><p><code>cloudbuild.yaml</code> 과 문법은 다르지만 어떤 내용인지는 쉽게 알아 볼 수 있습니다.</p><h3 id="3-도커-빌드하고-Container-Registry-에-푸시하기">3. 도커 빌드하고 Container Registry 에 푸시하기</h3><p>이번엔 도커 빌드 스테이지를 추가하고 GitLab 저장소에 자동으로 생성되는 컨테이너 레지스트리에 도커 이미지를 푸시하겠습니다.</p><p>컨테이너 레지스트리는 저장소의 <strong>Registry</strong> 메뉴에 있습니다. 간단한 사용법을 확인할 수 있습니다.</p><p><code>.gitlab-cicd.yml</code> 파일에 도커 빌드 작업을 추가합니다.</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">image:</span> <span class="string">docker:latest</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">docker:dind</span></span><br><span class="line"></span><br><span class="line"><span class="attr">variables:</span></span><br><span class="line">  <span class="attr">DOCKER_DRIVER:</span> <span class="string">overlay</span></span><br><span class="line">  <span class="attr">SPRING_PROFILES_ACTIVE:</span> <span class="string">gitlab-ci</span></span><br><span class="line"></span><br><span class="line"><span class="attr">stages:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">build</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">package</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">deploy</span></span><br><span class="line"></span><br><span class="line"><span class="attr">maven-build:</span></span><br><span class="line">  <span class="attr">image:</span> <span class="string">maven:3-jdk-8</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">build</span></span><br><span class="line">  <span class="attr">script:</span> <span class="string">&quot;mvn install&quot;</span></span><br><span class="line">  <span class="attr">artifacts:</span></span><br><span class="line">    <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">target/*.jar</span></span><br><span class="line">      </span><br><span class="line"><span class="attr">docker-build:</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">package</span></span><br><span class="line">  <span class="attr">script:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">docker</span> <span class="string">build</span> <span class="string">-t</span> <span class="string">registry.gitlab.com/futurecreator/spring-boot-container</span> <span class="string">.</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">docker</span> <span class="string">login</span> <span class="string">-u</span> <span class="string">gitlab-ci-token</span> <span class="string">-p</span> <span class="string">$CI_BUILD_TOKEN</span> <span class="string">registry.gitlab.com</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">docker</span> <span class="string">push</span> <span class="string">registry.gitlab.com/futurecreator/spring-boot-container</span></span><br></pre></td></tr></table></figure><p>빌드 결과를 확인합니다.<br><img src="gitlab-docker-build.png" alt="GitLab 도커 빌드 결과"></p><p>컨테이너 레지스트리에서 빌드된 이미지를 확인할 수 있습니다.<br><img src="gitlab-registry-result.png" alt="컨테이너 레지스트리"></p><p>이제 코드가 변경될 때마다 빌드가 수행되고 이미지가 레지스트리에 추가됩니다.</p><h3 id="4-GKE-에-배포하기">4. GKE 에 배포하기</h3><p>마지막으로 쿠버네티스 클러스터에 배포할 차례입니다. 클러스터는 이전 실습에서 생성한 클러스터를 활용하면 되겠네요.</p><p>배포 과정 자체는 비슷하지만 GitLab 이 외부 서비스이다 보니 조금 더 손이 갑니다. cloud-sdk 로 클러스터에 접속하기 때문에 인증 절차가 필요합니다.</p><p>먼저 GCP의 <strong>IAM Service Account Credentials API &gt; 사용자 인증 정보</strong> 에서 서비스 계정의 키를 JSON 으로 생성합니다.<br><img src="create-key.png" alt="비공개 키 생성"></p><p>그러면 JSON Key를 자동으로 내려받습니다. 해당 JSON Key 내용을 복사해서 GitLab 의 <strong>Settings &gt; CI/CD &gt; Environment variables</strong> 에 <code>GOOGLE_KEY</code> 로 추가합니다.</p><p>클러스터에서 사전 작업을 합시다. 먼저 해당 애플리케이션을 배포할 네임스페이스를 생성합니다.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create namespace spring-boot-2</span><br></pre></td></tr></table></figure><p>GitLab 레지스트리에서 이미지를 받아오기 위한 계정 정보를 Secret 객체로 만들어야 합니다. 각 값은 여러분의 계정으로 작성하면 됩니다.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create secret docker-registry registry.gitlab.com --docker-server=https://registry.gitlab.com --docker-username=yourusername --docker-password=yourpassword --docker-email=youremail -n spring-boot-2</span><br></pre></td></tr></table></figure><p>이제 배포를 합시다. 첫 번째 환경을 구성할 때는 미리 배포가 되어 있어서 배포된 이미지를 교체하는 <code>kubectl set image</code> 명령어를 사용했습니다. 이번에는 변경 사항을 파일로 적용하는 <code>kubectl apply -f</code> 명령어를 이용하기 위해 소스 폴더 루트에 <code>deployment.yaml</code> 파일을 추가합니다.</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">spring-boot-container</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">spring-boot-2</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">spring-boot-container</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">spring-boot-container</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">spring-boot-container</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">spring-boot-container</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">registry.gitlab.com/futurecreator/spring-boot-container</span></span><br><span class="line">        <span class="attr">imagePullPolicy:</span> <span class="string">Always</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">8080</span></span><br><span class="line">      <span class="attr">imagePullSecrets:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">registry.gitlab.com</span></span><br></pre></td></tr></table></figure><ul><li>내용을 살펴보면 첫 번째 환경의 배포 YAML 과 비슷합니다.</li><li>다른 점은 배포할 네임스페이스, 이미지, 그리고 이미지를 내려받을 때 사용할 <code>imagePullSecrets</code> 설정입니다.</li></ul><p>이제 <code>.gitlab-cicd.yml</code> 파일에 배포 과정을 추가합니다.</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">image:</span> <span class="string">docker:latest</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">docker:dind</span></span><br><span class="line"></span><br><span class="line"><span class="attr">variables:</span></span><br><span class="line">  <span class="attr">DOCKER_DRIVER:</span> <span class="string">overlay</span></span><br><span class="line">  <span class="attr">SPRING_PROFILES_ACTIVE:</span> <span class="string">gitlab-ci</span></span><br><span class="line"></span><br><span class="line"><span class="attr">stages:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">build</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">package</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">deploy</span></span><br><span class="line"></span><br><span class="line"><span class="attr">maven-build:</span></span><br><span class="line">  <span class="attr">image:</span> <span class="string">maven:3-jdk-8</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">build</span></span><br><span class="line">  <span class="attr">script:</span> <span class="string">&quot;mvn install&quot;</span></span><br><span class="line">  <span class="attr">artifacts:</span></span><br><span class="line">    <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">target/*.jar</span></span><br><span class="line">      </span><br><span class="line"><span class="attr">docker-build:</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">package</span></span><br><span class="line">  <span class="attr">script:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">docker</span> <span class="string">build</span> <span class="string">-t</span> <span class="string">registry.gitlab.com/futurecreator/spring-boot-container</span> <span class="string">.</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">docker</span> <span class="string">login</span> <span class="string">-u</span> <span class="string">gitlab-ci-token</span> <span class="string">-p</span> <span class="string">$CI_BUILD_TOKEN</span> <span class="string">registry.gitlab.com</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">docker</span> <span class="string">push</span> <span class="string">registry.gitlab.com/futurecreator/spring-boot-container</span></span><br><span class="line">  </span><br><span class="line"><span class="attr">k8s-deploy:</span></span><br><span class="line">  <span class="attr">image:</span> <span class="string">google/cloud-sdk</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">deploy</span></span><br><span class="line">  <span class="attr">script:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">echo</span> <span class="string">&quot;$GOOGLE_KEY&quot;</span> <span class="string">&gt;</span> <span class="string">key.json</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">gcloud</span> <span class="string">auth</span> <span class="string">activate-service-account</span> <span class="string">--key-file</span> <span class="string">key.json</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">gcloud</span> <span class="string">config</span> <span class="string">set</span> <span class="string">compute/zone</span> <span class="string">us-central1-a</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">gcloud</span> <span class="string">config</span> <span class="string">set</span> <span class="string">project</span> <span class="string">spring-boot-container</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">gcloud</span> <span class="string">container</span> <span class="string">clusters</span> <span class="string">get-credentials</span> <span class="string">spring-boot-container-cluster</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">kubectl</span> <span class="string">apply</span> <span class="string">-f</span> <span class="string">deployment.yaml</span></span><br></pre></td></tr></table></figure><ul><li><code>gcloud</code> 를 이용해 클러스터에 접속합니다. 접속이 안될 경우 <code>GOOGLE_KEY</code>, 프로젝트명, 지역, 클러스터 이름 등 접속 정보를 확인합니다.</li><li>우리가 작성한 <code>deployment.yaml</code> 을 이용해 변경 사항을 배포합니다.</li></ul><p>빌드 결과를 확인합니다.<br><img src="gitlab-gke-deploy-result.png" alt="GitLab 빌드 결과 확인"></p><p>클러스터에 접속해 배포 결과를 확인합니다.<br><img src="gitlab-gke-deploy-kubectl.png" alt="GKE 배포 결과 확인"></p><p>이번에는 GitLab 의 서비스를 주로 이용해서 CI/CD  환경을 구성했습니다. Cloud Build 와 비교했을 때 서비스가 무료이고 GitLab 안에서 대부분 해결할 수 있다는 장점이 있습니다(물론 GitLab 도 특정 서비스는 유료입니다). 또한 해당 서비스를 시각적으로 파이프라인으로 볼 수 있는 것도 장점입니다.</p><h2 id="정리">정리</h2><p>이번 포스트에서는 간단한 스프링부트 애플리케이션을 작성해서 컨테이너로 만들고 CI/CD 환경을 구성했습니다. 코드가 수정될 때마다 빌드하고 원하는 환경에 배포까지 쉽게 할 수 있었습니다. 기존에 많이 사용하는 Jenkins 는 별도의 서버를 구성하거나 쿠버네티스 클러스터에 별도의 컨테이너를 띄워야 합니다. 그래서 최대한 쉽게 접근해서 구성할 수 있는 환경 위주로 실습했습니다.</p><p>실습에 사용한 코드는 다음 저장소에서 확인할 수 있습니다.</p><ul><li><a href="https://github.com/futureCreator/spring-boot-container">https://github.com/futureCreator/spring-boot-container</a></li><li><a href="https://gitlab.com/futureCreator/spring-boot-container">https://gitlab.com/futureCreator/spring-boot-container</a></li></ul><h2 id="참고">참고</h2><ul><li><a href="https://spring.io/blog/2018/11/08/spring-boot-in-a-container">Spring Boot in Conatiner | Spring.io</a></li><li><a href="https://cloud.google.com/cloud-build/docs/">Google Cloud Build Docs | Google Cloud Platform</a></li><li><a href="https://docs.gitlab.com/ee/ci/">GItLab Continuous Intergration (GitLab CI/CD) | GitLab Docs</a></li></ul><h2 id="Related-Posts">Related Posts</h2><ul><li><a href="/2018/11/16/docker-container-basics/" title="도커 Docker 기초 확실히 다지기">도커 Docker 기초 확실히 다지기</a></li><li><a href="/2018/11/09/it-infrastructure-basics/" title="개발자를 위한 인프라 기초 총정리">개발자를 위한 인프라 기초 총정리</a></li><li><a href="/2018/07/04/aws-certified/" title="AWS 자격증 준비하기">AWS 자격증 준비하기</a></li><li><a href="/2018/12/15/aws-reinvent-2018-summary/" title="AWS re:Invent 2018 한 방에 정리하기">AWS re:Invent 2018 한 방에 정리하기</a></li><li><a href="/2019/02/25/kubernetes-cluster-on-google-compute-engine-for-developers/" title="개발자를 위한 쿠버네티스(Kubernetes) 클러스터 구성하기(Kubeadm, GCE, CentOS)">개발자를 위한 쿠버네티스(Kubernetes) 클러스터 구성하기(Kubeadm, GCE, CentOS)</a></li></ul><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">롤링 업데이트(Rolling Update)란 기존 서비스를 유지하면서 업데이트하기 위한 방법으로, 여러 개의 인스턴스가 있을 때 하나씩 새로운 버전의 인스턴스로 교체하는 방법입니다.<a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">빌드 설정이 친숙하지 않은 개발자를 위해 사전에 정의된 CI/CD 설정으로 빌드 작업을 자동화하는 <a href="https://about.gitlab.com/product/auto-devops/">Auto DevOps</a>라는 기능도 있습니다. <code>Auto Build</code>, <code>Auto Test</code>, <code>Auto Deploy</code> 등 기능을 제공합니다. GitLab 11.3부터 모든 프로젝트에 Auto DevOps가 기본적으로 설정되어 있어 코드를 처음 올리면 파이프라인 작업이 수행됩니다. 물론 완벽히 구성하지 않은 상태여서 첫 번째 파이프라인 작업이 실패한다면 해당 설정은 disabled 됩니다.<a href="#fnref:2" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;p&gt;이번 포스트에서는 간단한 스프링 부트(Spring Boot) 애플리케</summary>
      
    
    
    
    <category term="Cloud" scheme="https://futurecreator.github.io/categories/Cloud/"/>
    
    
    <category term="github" scheme="https://futurecreator.github.io/tags/github/"/>
    
    <category term="deploy" scheme="https://futurecreator.github.io/tags/deploy/"/>
    
    <category term="container" scheme="https://futurecreator.github.io/tags/container/"/>
    
    <category term="docker" scheme="https://futurecreator.github.io/tags/docker/"/>
    
    <category term="kubernetes" scheme="https://futurecreator.github.io/tags/kubernetes/"/>
    
    <category term="gcp" scheme="https://futurecreator.github.io/tags/gcp/"/>
    
    <category term="spring-boot" scheme="https://futurecreator.github.io/tags/spring-boot/"/>
    
    <category term="gke" scheme="https://futurecreator.github.io/tags/gke/"/>
    
    <category term="gitlab" scheme="https://futurecreator.github.io/tags/gitlab/"/>
    
    <category term="ci-cd" scheme="https://futurecreator.github.io/tags/ci-cd/"/>
    
    <category term="build" scheme="https://futurecreator.github.io/tags/build/"/>
    
  </entry>
  
  <entry>
    <title>AWS re:Invent 2018 한 방에 정리하기</title>
    <link href="https://futurecreator.github.io/2018/12/15/aws-reinvent-2018-summary/"/>
    <id>https://futurecreator.github.io/2018/12/15/aws-reinvent-2018-summary/</id>
    <published>2018-12-15T14:34:44.000Z</published>
    <updated>2025-03-14T16:10:24.248Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p><a href="https://reinvent.awsevents.com/">AWS re:Invent</a> 는 AWS(<em>Amazon Web Service</em>)의 대표적인 컨퍼런스로 새로운 서비스와 기능을 발표하는 행사입니다. 또한 클라우드 컴퓨팅 시장을 선도하는 회사답게 가장 규모가 크고 인기가 많은 행사입니다. 이번 행사에서는 4일간의 키노트 세션과 전야제에서 100개 이상의 서비스가 새로 출시되었습니다. 기존 서비스는 더 정교해지고, 새로운 서비스로 지원하는 영역은 더 넓어졌습니다.</p><p>물론 모든 서비스를 모두 알 필요는 없습니다. 이 많은 서비스를 모두 알고 잘 다룰 수도 없을 뿐더러 그럴 필요도 없기 때문입니다. 하지만 신규 서비스를 살펴보면서 AWS 가 어떤 방향으로 가고 있는지, 클라우드 컴퓨팅이 어떻게 발전할지 살펴보는 건 의미있는 일입니다.</p><p>이번 포스팅에서는 분야별로 새로 출시된 주요 AWS 서비스를 살펴보겠습니다.</p><ul><li>글로벌 인프라</li><li>컴퓨팅</li><li>스토리지</li><li>데이터베이스</li><li>머신 러닝과 인공 지능</li><li>보안 및 클라우드 하이브리드</li><li>차세대 산업 (IoT, 로봇, 우주 산업)</li></ul><h2 id="글로벌-인프라-Global-Infrastructure">글로벌 인프라 Global Infrastructure</h2><p>먼저 글로벌 인프라부터 살펴보겠습니다. AWS 는 단순 리전 확장 뿐 아니라 인프라 성능과 가용성을 높이고, 여러 네트워크를 쉽게 관리할 수 있는 서비스를 제공합니다.</p><ul><li>글로벌 리전 확장</li><li>AWS Global Accelerator</li><li>AWS Transit Gateway</li></ul><h3 id="글로벌-리전-확장">글로벌 리전 확장</h3><p><img src="https://d1.awsstatic.com/about-aws/Global%20Infrastructure/Global-Infrastructure-update_Stockholm.0dcd1b04b611082716971185b6963d224eef86ae.png" alt="https://aws.amazon.com/ko/about-aws/global-infrastructure/"></p><p>AWS 는 전 세계에 데이터 센터를 보유하고 있습니다. 이 데이터 센터는 리전(<em>Region</em>)과 가용 영역(<em>Availability Zone, AZ</em>)으로 나뉘어져 있는데요. 데이터 센터를 지역별 물리적인 위치로 나누고, 리전 안에서도 가용 영역을 나눕니다. 따라서 인스턴스의 장애가 다른 곳으로 퍼지는 것을 막고  글로벌 서비스 시 원하는 지역에 빠른 서비스가 가능합니다.</p><p><img src="https://docs.aws.amazon.com/ko_kr/AWSEC2/latest/UserGuide/images/aws_regions.png" alt="https://docs.aws.amazon.com/ko_kr/AWSEC2/latest/UserGuide/using-regions-availability-zones.html"></p><p>AWS 는 글로벌 리전을 확장해 19개의 리전과 57개의 가용 영역을 구축했습니다. 앞으로 바레인, 케이프타운, 홍콩, 스톡홀름 등 4개의 리전을 추가할 계획이라고 합니다. 우리나라에는 2016년부터 서비스된 아시아 태평양 서울 리전이 있습니다. 또한 AWS 는 전 세계 150개 이상의 글로벌 PoP와 89 Direct Connect 전용선 연결 지점, 100GbE 네트워크망을 운영 중입니다.</p><p>따라서 AWS 를 통해 더 빠르고 안전한 서비스를 제공할 수 있습니다. 물론 리전과 가용 영역을 최대한 활용할 수 있는 설계가 필요합니다. 비용은 더 들겠지만 멀티 리전으로 구축해야만 AWS 장애 시 피해를 최소화할 수 있습니다.</p><h3 id="AWS-Global-Accelerator">AWS Global Accelerator</h3><p><img src="https://d1.awsstatic.com/r2018/b/ubiquity/global-accelerator-before.46be83fdc7c630457bba963c7dc928cb676d9046.png" alt="https://aws.amazon.com/ko/global-accelerator/?nc2=h_re"></p><p>글로벌 애플리케이션의 경우 사용자의 위치에 따라 여러 네트워크를 거치면서 성능에 영향을 줍니다. 또한 중간에 네트워크에 문제가 생길 경우 서비스가 제공되지 않을 수도 있죠.</p><p><img src="https://d1.awsstatic.com/r2018/b/ubiquity/global-accelerator-after.2e404ac7f998e501219f2614bc048bb9c01f46d4.png" alt="https://aws.amazon.com/ko/global-accelerator/?nc2=h_re"></p><p><a href="https://aws.amazon.com/ko/global-accelerator/?nc2=h_re">AWS Global Accelerator</a> 는 AWS 글로벌 네트워크를 활용해 경로를 최적화해서 성능을 높이고, 지속적인 모니터링으로 가용성을 제공합니다. 따라서 재해 복구에 대응하고, 성능 개선과 네트워크 확장 등을 손쉽게 구성할 수 있습니다.</p><h3 id="AWS-Transit-Gateway">AWS Transit Gateway</h3><p><img src="https://d1.awsstatic.com/r2018/b/transit-gateway/tgw-before.ad71b2b9e9d7cc759ac712e4919659ba619cca35.png" alt="https://aws.amazon.com/ko/transit-gateway/?nc2=h_re"></p><p>Amazon VPC(<em>Amazon Virtual Private Cloud</em>)는 사내 시스템과 같은 프라비잇 클라우드를  손쉽게 구축할 수 있는 서비스입니다. AWS 상에서 처리할 수 있는 워크로드가 많아지고 확장되면서 VPC 끼리 혹은 기존의 온프레미스 네트워크와 연결이 필요해지는데요. 기존에는 VPN 연결을 중앙에서 관리할 수 없어서 연결이 많아질수록 관리하기가 매우 복잡했습니다.</p><p><img src="https://d1.awsstatic.com/r2018/b/transit-gateway/tgw-after.a35c10feecbbbab677150eac358aa478dbf787fa.png" alt="https://aws.amazon.com/ko/transit-gateway/?nc2=h_re"></p><p><a href="https://aws.amazon.com/ko/transit-gateway/?nc2=h_re">AWS Transit Gateway</a> 는 Amazon VPC와 온프레미스 네트워크를 손쉽게 연결하고 중앙에서 모니터링하고 관리하는 기능을 제공합니다. 따라서 확장하기 쉽고 아키텍처를 간소화할 수 있습니다.</p><h2 id="컴퓨팅-Computing">컴퓨팅 Computing</h2><p>컴퓨팅 분야에서는 자체 칩셋을 이용한 인스턴스와 서버리스에 대한 지원이 돋보이네요. 아래 주제에 대해 살펴봅니다.</p><ul><li>EC2 Instance</li><li>Container</li><li>Serverless</li></ul><h3 id="EC2-Instance">EC2 Instance</h3><p>Amazon Elastic Compute Clode(<em>EC2</em>)는 AWS 의 대표적인 서비스로 VM 인스턴스를 제공합니다. 인스턴스 타입을 다양하게 제공해서 사용자가 원하는 용도에 맞게 선택할 수 있습니다. 같은 인스턴스라도 vCPU, 메모리, 스토리지, 네트워크 성능 등에 따라 세부적으로 선택할 수 있습니다.<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="https://aws.amazon.com/ko/ec2/instance-types/">[1]</span></a></sup></p><table><thead><tr><th>용도</th><th>인스턴스 모델</th><th>설명</th></tr></thead><tbody><tr><td>범용</td><td>M5, M5a, M5d, M4</td><td>균형 있는 성능 제공</td></tr><tr><td>범용 + 버스팅</td><td>T3, T3a, T2</td><td>균형 있는 성능 + CPU 사용량 버스팅</td></tr><tr><td>컴퓨팅</td><td>C5, C5d, C4</td><td>컴퓨팅 집약적 워크로드에 최적화</td></tr><tr><td>메모리</td><td>R5, R5a, R5d, R4</td><td>메모리 사용에 최적화</td></tr><tr><td>대용량 메모리</td><td>X1, X1e</td><td>대규모 in-memory 사용에 최적화<br />RAM 요금이 가장 저렴</td></tr><tr><td>HPC 전용</td><td>Z1d</td><td>고성능 컴퓨팅 제공</td></tr><tr><td>범용 GPU</td><td>P3, P2</td><td>GPU 컴퓨팅 애플리케이션에 적합 (머신 러닝, 딥 러닝 등)</td></tr><tr><td>그래픽 최적화</td><td>G3</td><td>그래픽 집약적 워크로드에 최적화</td></tr><tr><td>FPGA</td><td>F1</td><td>FPGA(<em>Field Programmable Gate Array</em>)<br />용도에 따라 커스터마이징할 수 있는 칩</td></tr><tr><td>스토리지</td><td>D2</td><td>우수한 디스크 처리량 제공</td></tr><tr><td>빅데이터</td><td>H1</td><td>균형 있는 성능과 높은 디스크 처리량 제공</td></tr><tr><td>고속 I/O</td><td>I3</td><td>고성능 NVMe(<em>Non-Volatile Memory Express</em>) SSD 지원<br />NoSQL, In-memory DB, Elasticsearch 등에 적합</td></tr><tr><td>베어메탈</td><td>I3m</td><td>가상화 되지 않은 베어 메탈(<em>Bare Metal</em>) 인스턴스</td></tr></tbody></table><p>인스턴스를 보시면 a 또는 d 가 붙어 있는 모델을 확인할 수 있는데요, 뒤에 a 가 붙은 모델(<em>M5a, R5a</em>)은 AMD 기반으로 비용을 절감할 수 있는 모델입니다. 그리고 d 가 붙은 모델(<em>M5d, R5d, Z1d, C5d</em>)은 호스트 서버에 NVMe  SSD 를 연결해 빠른 입출력을 제공하는 모델입니다.</p><p>그리고 이번 행사에서 두 개의 새로운 인스턴스를 공개했습니다.</p><h4 id="EC2-A1-Instance">EC2 A1 Instance</h4><p>AWS 는 비용을 절감할 수 있고 클라우드 컴퓨팅에 최적화된 칩을 직접 만들기로 합니다. 2015년 인수한 <a href="http://www.annapurnalabs.com/">Annapurna Labs</a> 을 통해 Arm 기반의 맞춤형 CPU를 개발하고 이를 지원하는 첫 번째 인스턴스를 공개했습니다.</p><p><a href="https://aws.amazon.com/ko/ec2/instance-types/a1/">EC2 A1 Instance</a> 는 웹 서버 및 컨테이너형 마이크로서비스에 최적화된 인스턴스로 인스턴스 확장 시 45%까지 비용을 절감할 수 있습니다.</p><h4 id="EC2-C5n-Instance">EC2 C5n Instance</h4><p><a href="https://aws.amazon.com/ko/ec2/instance-types/c5/">EC2 C5n Instance</a> 는 차세대 컴퓨팅 최적화 모델인 C5 인스턴스에 100Gbps 고성능 네트워킹을 추가한 인스턴스입니다. 따라서 대규모 작업을 신속하게 처리하고 네트워크 작업 부하의 비용을 절감할 수 있습니다.</p><h4 id="Elastic-Fabric-Adapter">Elastic Fabric Adapter</h4><p>이 외에도 새로 출시된 <a href="https://aws.amazon.com/ko/about-aws/whats-new/2018/11/introducing-elastic-fabric-adapter/">Elastic Fabric Adapter</a>(<em>EFA</em>)는 EC2 인스턴스를 위한 네트워크 인터페이스입니다. 애드온으로 인스턴스에 추가해서 사용할 수 있는 기능인데요. 전산 유체 역학, 기후 모델링, 저수지 시뮬레이션 등 인스턴스 간 통신이 필요한 고성능 컴퓨팅(<em>High-Performance Computing,HPC</em>) 애플리케이션을 지원합니다.</p><h3 id="Container">Container</h3><p>현재 AWS에서는 컨테이너를 사용하는 몇 가지 옵션을 제공하고 있습니다.</p><h4 id="Amazon-ECS">Amazon ECS</h4><p><img src="https://d1.awsstatic.com/diagrams/product-page-diagrams/product-page-diagram_ECS_1.86ebd8c223ec8b55aa1903c423fbe4e672f3daf7.png" alt="https://aws.amazon.com/ko/ecs/"></p><p><a href="https://aws.amazon.com/ko/ecs/">Amazon Elastic Container Service</a>(<em>ECS</em>)는 도커(<em>Docker</em>) 컨테이너를 관리하는 오케스트레이션 서비스로 컨테이너화한 애플리케이션을 쉽게 실행하고 확장 및 축소하는 기능을 제공합니다.</p><h4 id="AWS-Fargate">AWS Fargate</h4><p><img src="https://d1.awsstatic.com/diagrams/product-page-diagrams/product-page-diagram-Fargate_how-it-works.03c366c5aa4aa2cfb99aa91cbcd4d534f541bde2.png" alt="https://aws.amazon.com/ko/fargate/"></p><p><a href="https://aws.amazon.com/ko/fargate/">AWS Fargate</a> 는 AWS EC2와 같은 컴퓨팅 엔진입니다. 위의 Amazon ECS 를 사용할 때 EC2와 Fargate 중 선택을 할 수 있는데요. Fargate를 사용하면 가상 머신 클러스터에 대한 프로비저닝, 구성, 확장 등 클러스터 관리를 자동으로 처리해주기 때문에 애플리케이션을 개발하는데 집중할 수 있습니다.</p><p>Fargate는 현재는 ECS 만 지원하지만 향후 EKS 도 지원할 예정이라고 합니다.</p><h4 id="AWS-EKS">AWS EKS</h4><p><img src="https://d1.awsstatic.com/diagrams/product-page-diagrams/product-page-diagram-AmazonEKS-v2.dd41321fd3aa0915b93396c13e739351d2160ba8.png" alt="https://aws.amazon.com/ko/eks/"></p><p><a href="https://aws.amazon.com/ko/eks/">Amazon Elastic Container Service for Kubernetes</a>(<em>EKS</em>)는 AWS 상에서 쿠버네티스(<em>Kubernetes</em>) 클러스터를 제공해주는 서비스로 제어 영역(<em>Control Plane</em>)을 자동으로 관리 및 업데이트 해줍니다. 따라서 사용자는 워커 노드를 프로비저닝하고 EKS의 엔드포인트에 연결하기만 하면 됩니다.</p><h4 id="AWS-App-Mesh">AWS App Mesh</h4><p>마이크로서비스 아키텍처는 장점도 많지만 작은 서비스간 연결이 많아지면서 복잡해지는 단점도 있습니다. 이를 극복하고 보완하기 위한 설계와 툴이 나오면서 마이크로서비스도 발전하고 있는데요. 그 중 하나가 서비스 메시(<em>Service Mesh</em>)라는 개념으로 마이크로서비스의 커뮤니케이션을 보다 쉽게 모니터링하고 관리할 수 있는 방법입니다.</p><p><img src="https://image.slidesharecdn.com/talk-microservices-170321085816/95/the-birth-and-evolution-of-a-microservices-architecture-lugano-tech-talk-0317-33-638.jpg?cb=1490257746" alt="https://www.slideshare.net/welld/the-birth-and-evolution-of-a-microservices-architecture"></p><p>마이크로서비스는 여러 서비스가 서로 호출하는 구조로 되어 있습니다. 문제의 시작은 이겁니다. 이 중 하나의 서비스에서 장애가 나면 어떻게 될까요? 장애는 해당 서비스 자체에서만 끝나는 것이 아니라 연쇄적으로 퍼지게 됩니다.</p><p><img src="https://www.nginx.com/wp-content/uploads/2016/11/Health-check-for-microservices-large.png" alt="https://www.nginx.com/blog/microservices-reference-architecture-nginx-circuit-breaker-pattern/"></p><p>해결책은 서비스간 호출을 바로 하는 것이 아니라 중간 다리를 거쳐서 호출하고, 장애 발생 시 중간 다리에서 연결을 끊어버리는 겁니다. 이를 <a href="https://microservices.io/patterns/reliability/circuit-breaker.html">써킷 브레이커 패턴</a>(<em>Circuit Breaker Pattern</em>)이라고 합니다. 회로 차단기라는 뜻이죠.</p><p><img src="https://www.redhat.com/cms/managed-files/service-mesh-1680.png" alt="https://www.redhat.com/ko/topics/microservices/what-is-a-service-mesh"></p><p>이와 비슷한 작업을 인프라 레벨에서 풀 수 있는 것이 바로 서비스 메시입니다. 마이크로서비스는 각자 프록시를 옆에 두고 해당 프록시를 거쳐서 통신합니다. 이를 오토바이의 사이드카와 비슷하다고 해서 사이드카 패턴(<em>Sidecar Pattern</em>)이라고 합니다. 이렇게 서비스마다 프록시를 다 붙여놓으면서비스간 오고 가는 정보를 수집할 수 있고 라우팅, 헬스체킹, 로드 밸런싱, 써킷 브레이킹 등 다양한 작업을 할 수 있어 유용합니다. 프록시로는 <a href="https://www.envoyproxy.io/">Envoy</a> 가 많이 사용됩니다.</p><p><img src="https://istio.io/docs/concepts/what-is-istio/arch.svg" alt="https://istio.io/docs/concepts/what-is-istio/"></p><p>문제는 마이크로서비스가 워낙 많다보니 프록시의 개수 또한 많아지고 관리가 어려워지는 점입니다. 그래서 프록시를 중앙에서 관리하도록 나온 툴이 <a href="https://istio.io/">Istio</a> 입니다.</p><p><img src="https://d1.awsstatic.com/r2018/a/Product-Page-Diagram_Lattice_After.de0ef7327c19197e473f7bf59f4687cea53f01f3.png" alt="https://aws.amazon.com/ko/app-mesh/"></p><p>새로 출시된 <a href="https://aws.amazon.com/app-mesh/">AWS App Mesh</a> 는 추가적인 도구 설치 없이 ECS 및 EKS 를 기반으로 서비스 메시를 제공합니다. 따라서 마이크로서비스 모니터링과 제어를 쉽게 할 수 있습니다.</p><h4 id="AWS-Cloud-Map">AWS Cloud Map</h4><p><img src="https://d1.awsstatic.com/r2018/a/product-page-diagram_skymap_before-after.601791b8d5c69fb0c7e96bd6706cfd5320ca8f3d.png" alt="https://aws.amazon.com/ko/cloud-map/?nc1=h_ls"></p><p>새로 출시된 <a href="https://aws.amazon.com/ko/cloud-map/?nc1=h_ls">AWS Cloud Map</a> 은 리소스 관리 서비스입니다. 마이크로서비스는 트래픽에 따라 동적으로 확장되거나 축소되다보니 리소스 이름과 위치를 수동으로 관리하기가 어렵습니다. AWS Cloud Map 은 이를 중앙에서 등록해 관리할 수 있어 애플리케이션 버전이나 배포 환경에 따라 맞춤형 리소스를 구성할 수 있습니다.</p><h3 id="Serverless">Serverless</h3><p>AWS Lambda 는 서버리스(<em>Serverless</em>) 컴퓨팅의 선두주자입니다. 저도 처음에 써보고 놀랐던 기억이 나네요. 서버 관리 없이 코드만 올리면 각종 트리거(이벤트)를 기반으로 실행되는 간단한 방식입니다. 단순히 메시지 큐만 사용하는 것이 아니라 AWS 내 각종 서비스를 이벤트 소스로 사용할 수 있어서 큰 인기를 얻었습니다. 단점으로는 코드 실행 시 VM이 생성되어 런타임을 구성하고 코드가 실행되기 때문에 처음 실행 시 VM을 부팅하는 시간이 걸린다는 점이 있는데요.  이에 맞춰 AWS 에서도 Lambda 의 단점을 보완하고 기능을 대폭 강화했습니다.</p><ul><li>IDE</li><li>Language Support</li><li>Programming Models</li><li>Workflows</li><li>Firecracker</li></ul><h4 id="AWS-Toolkits-for-IDEs">AWS Toolkits for IDEs</h4><p><img src="aws-toolkits-for-ides.jpg" alt="https://www.slideshare.net/awskorea/aws-reinvent-2018-new-services-channy"></p><p>람다를 사용하면서 불편한 점 중 하나는 코드를 외부에서 작성 후 업로드 해야하는 점이었습니다. 자바스크립트 같은 경우는 람다 콘솔에서 바로 작성할 수 있지만 자바 같은 경우는 소스를 말아서 올려야했죠. 그래서 AWS 는 브라우저 기반의 IDE인 AWS Cloud 9 을 출시했습니다. 서버리스 개발에 유용하고 EC2 인스턴스에 쉽게 접근할 수 있는 터미널도 함께 제공되었습니다.</p><p>하지만 개발자들은 원래 익숙한 툴을 좋아하기 마련이죠. 그래서 AWS Toolkit for IDEs 라고 기존 개발 환경과 통합을 제공합니다. 기존에 제공하던 <a href="https://aws.amazon.com/ko/eclipse/">AWS Toolkits for Eclipse</a> 와 <a href="https://aws.amazon.com/ko/visualstudio/">AWS Toolkits for Visual Studio</a> 외에 새로 <a href="https://github.com/aws/aws-toolkit-jetbrains">PyCharm</a>, <a href="https://github.com/aws/aws-toolkit-jetbrains">IntelliJ</a>, <a href="https://github.com/aws/aws-toolkit-vscode">Visual Studio Code</a>를 지원합니다. 이에 기존에 작업하던 환경 그대로 서버리스 개발을 하는 것이 더 쉬워졌습니다.</p><h4 id="커스텀-런타임-지원">커스텀 런타임 지원</h4><p>기존에 지원하는 자바, Node.js, C#, 파이썬, Go 외에도 커스텀 런타임을 지원합니다. Linux 호환 언어라면 런타임을 활용할 수 있습니다. 이번에 람다에 새로 추가된 Ruby 도 이런 방식으로 지원했다고 하네요. 따라서 Erlang, elixir, Cobol 등 다양한 언어를 지원할 수 있게 되었습니다.</p><h4 id="Lambda-Layers">Lambda Layers</h4><p>람다는 함수에서 사용하는 라이브러리와 디펜던시를 같이 말아 업로드해서 사용합니다. 그러다보니 마이크로서비스  애플리케이션을 구성할 경우 이러한 공유 코드, 라이브러리, 디펜던시가 각각 들어가 중복됩니다. 그러다보니 수정이 필요한 경우 모든 람다 함수를 수정해야하는 문제가 생겼는데요. 이런 부분을 별도의 레이어로 분리하는 Lambda Layers 기능을 지원합니다. 따라서 런타임 환경을 손쉽게 확장하고 관리할 수 있습니다.</p><h4 id="Serverless-Application-Repository">Serverless Application Repository</h4><p><img src="https://d1.awsstatic.com/serverless/SAR/DeployApplications-Diagram.6756142e0376c98b3b94b166c766bdb7043ba12c.png" alt="https://aws.amazon.com/ko/serverless/serverlessrepo/"></p><p><a href="https://aws.amazon.com/ko/serverless/serverlessrepo/">Serverless Application Repository</a> 는 서버리스 애플리케이션을 공유하고 판매하는 마켓 플레이스입니다. AWS 외에도 여러 사용자가 올린 애플리케이션을 확인할 수 있습니다.</p><h4 id="Nested-Applications">Nested Applications</h4><p>서버리스 아키텍처가 커지면서 생산성을 높일 방법이 필요해졌습니다. <a href="https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/serverless-sam-template-nested-applications.html">Nested Applications</a> 도 그런 방법 중 하나입니다. 서버리스 애플리케이션을 다른 서버리스 애플리케이션의 컴포넌트처럼 사용해 개발 중복을 줄이고 생산성을 높여줍니다.</p><h4 id="Application-Load-Balancer-Support-for-Lambda">Application Load Balancer Support for Lambda</h4><p>람다의 이벤트 소스로 로드 밸런서가 추가되었습니다. 로드 밸런서가 컨텐츠 기반 라우팅 규칙을 지원하게 되면서 요청 내용에 따라 다른 람다 함수를 호출할 수 있게 된 것인데요. 따라서 기존에 로드 밸런서를 사용하는 웹 애플리케이션에도 쉽게 람다를 추가할 수 있습니다.</p><h4 id="Web-Socket-support-for-API-Gateway">Web Socket support for API Gateway</h4><p><img src="https://s3-us-west-2.amazonaws.com/assets.blog.serverless.com/reinvent/websockets-chat-app.png" alt="https://serverless.com/blog/api-gateway-websockets-support/"></p><p><a href="https://aws.amazon.com/ko/api-gateway/">Amazon API Gateway</a> 에서 Web Socket 을 지원하면서 웹 소켓 연결을 이용해 람다 함수를 호출할 수 있게 되었습니다. 따라서 실시간 양방향 통신 애플리케이션을 쉽게 구축할 수 있습니다.</p><h4 id="Step-Functions-API-Connectors">Step Functions + API Connectors</h4><p><img src="https://d1.awsstatic.com/product-marketing/Step%20Functions/sfn_how-it-works.f795601e8338db32506b9abb01e71704f483fc81.png" alt="https://aws.amazon.com/ko/step-functions/"></p><p><a href="https://aws.amazon.com/ko/step-functions/">AWS Step Functions</a> 는 람다 함수를 단계적으로나 병렬적으로 실행할 수 있도록 워크플로를 설계하고 모니터링할 수 있는 서비스입니다. 이번엔 워크플로를 지원하는 AWS 서비스가 확대되어 더 다양한 방식으로 사용할 수 있게 되었습니다.</p><h4 id="Amazon-Managed-Streaming-for-Kafka">Amazon Managed Streaming for Kafka</h4><p><img src="https://d1.awsstatic.com/product-marketing/Kinesis/diagram-kafka.08473d6874a142f0a629530688617780b73fb6e1.png" alt="https://aws.amazon.com/ko/kafka/"></p><p>카프카(<em>Kafka</em>)는 비동기 처리를 위한 대표적인 오픈 소스 분산 메시징 시스템입니다. 위 그림처럼 스트리밍 데이터를 읽어 버퍼링하고 필요한 애플리케이션에게 공급하는 역할을 하기도 합니다. AWS 에서 제공하는 카프카는 카프카를 사용하던 기존 코드를 변경 없이 적용할 수 있도록 호환성을 제공하고, 별도 주키퍼(<em>Zookeeper</em>) 노드 필요 없이 클러스터를 관리해줍니다. 또한 가용 영역 3개를 이용한 롤링 업그레이드로 패치도 지원합니다. 따라서 기존 카프카를 이용하던 애플리케이션이나 새로 구축하는 애플리케이션에서 관리에 대한 걱정 없이 카프카를 쉽게 사용할 수 있습니다.</p><h4 id="Firecracker">Firecracker</h4><p><img src="https://firecracker-microvm.github.io/img/diagram-desktop@3x.png" alt="https://firecracker-microvm.github.io/"></p><p>위에서 말씀드린 것처럼 람다 함수를 실행 시 VM이 뜨면서 해당 코드를 실행하게 됩니다. VM은 컨테이너 기반보다 보안은 우수하지만 처음 부팅 시 느리고 비교적 리소스를 효율적으로 사용하기 어렵습니다. 람다 출시 이후 사용자들이 람다를 다양하게 사용하고 인기를 얻으면서 람다를 속도와 리소스 효율 면에서 개선할 필요가 생겼습니다.</p><p>이에 AWS는 기존의 컨테이너 방식이나 VM 방식이 아닌 새로운 가상화 기술을 오픈 소스로 공개했습니다. <a href="https://firecracker-microvm.github.io/">Firecracker</a> 는 서버리스 컴퓨팅에 최적화된 microVM으로 VM 보안성은 유지하되 컨테이너의 빠른 확장과 리소스 효율성을 더했습니다. 가상화되지 않은 환경에서 1초 이내로 microVM을 시작할 수 있고 microVM 당 5MiB 메모리를 사용해 오버헤드가 낮습니다. 오픈 소스이지만 이미 AWS Lambda 와 AWS Fargate 에 적용되어 검증되었으며 앞으로도 많은 발전이 기대되는 프로젝트입니다.</p><h2 id="스토리지-Storage">스토리지 Storage</h2><p>다음은 스토리지입니다. 스토리지는 용도를 다양화하고 데이터 이동에 편의성을 증가시켰습니다.</p><h4 id="S3-신규-클래스">S3 신규 클래스</h4><p>Amazon Simple Storage Service(<em>S3</em>)는 데이터를 저장하는 스토리지 서비스입니다. S3는 데이터를 저장하고 얼마나 자주 사용하는지에 따라서 클래스를 구분하고 비용을 정산하기 때문에 적절한 용도에 따른 스토리지 클래스를 선택하는 것이 좋습니다. 보통 자주 사용하지 않는 것은 싼 가격에 많은 데이터를 저장할 수 있지만 속도는 느리고, 자주 사용하는 것은 비용이 높지만 속도는 빠르게 구성되어 있습니다.</p><p>새롭게 추가된 신규 클래스로는 인공지능을 기반으로 사용 빈도에 따라 자동으로 클래스를 조정해 비용을 최적화하는 <a href="https://aws.amazon.com/ko/about-aws/whats-new/2018/11/s3-intelligent-tiering/">S3 Intelligent-Tiering</a> 과 기존 백업용 클래스인 S3 Glacier 보다 더 저렴한 <a href="https://aws.amazon.com/ko/about-aws/whats-new/2018/11/s3-glacier-deep-archive/">S3 Glacier Deep Archive</a> 가 있습니다. 따라서 총 6개의 스토리지 클래스를 제공합니다.</p><table><thead><tr><th>이름</th><th>설명</th></tr></thead><tbody><tr><td>S3 Standard</td><td>범용 스토리지</td></tr><tr><td>S3 Intelligent-Tiering</td><td>인공지능을 기반으로 사용 빈도에 따라 자동으로 클래스를 조정해 비용을 최적화</td></tr><tr><td>S3 Standrad-Infrequent Access</td><td>자주 사용은 안하지만 필요할 때는 빠르게 액세스</td></tr><tr><td>S3 One Zone-Infrequent Access</td><td>가용성을 위해 3AZ에 저장하는 스탠다드와 달리 하나의 AZ에 저장해 빠르게 작업 가능</td></tr><tr><td>S3 Glacier</td><td>자주 사용하지 않는 데이터를 보관하기 위한 아카이브용 스토리지</td></tr><tr><td>S3 Glacier Deep Archive</td><td>장기간 보관에 적합한 최저 비용 스토리지</td></tr></tbody></table><h4 id="Amazon-FSx-for-Windows-File-Server">Amazon FSx for Windows File Server</h4><p><img src="https://d1.awsstatic.com/r2018/b/FSx-Windows/FSx_Windows_File_Server_How-it-Works.9396055e727c3903de991e7f3052ec295c86f274.png" alt="https://aws.amazon.com/ko/fsx/windows/"></p><p>퍼블릭 클라우드에서 Windows 워크로드를 사용하는 비율은 AWS(57.7%)가 Microsoft Azure(30.9%)보다도 높다고 합니다. 이에 완전 관리형 Windows 파일 시스템인 <a href="https://aws.amazon.com/ko/fsx/windows/">Amazon FSx for Windows File Server</a> 가 새로 출시되었습니다. 따라서 기존에 보유한 애플리케이션 및 윈도우 환경과 완벽하게 호환되는 네트워크 파일 스토리지로 사용할 수 있습니다.</p><h4 id="Amazon-FSx-for-Lustre">Amazon FSx for Lustre</h4><p><img src="https://d1.awsstatic.com/r2018/b/FSX-Lustre/FSx_Lustre_diagram.9f3f9ca4ea7827b296033b17f885543d4c3ca778.png" alt="https://aws.amazon.com/ko/fsx/lustre/"></p><p>데이터 레이크, HPC(고성능 컴퓨팅), EDA(전자 설계 자동화) 등의 대규모 작업들은 피비바이트(<em>PiB, 125TB</em>) 단위로 데이터를 처리합니다. <a href="http://lustre.org/">Lustre</a> 는 이런 고성능 작업을 지원하는 병렬 파일 시스템으로 오픈소스인데요. AWS 는 이를 기반으로 매니지드 파일 시스템인 <a href="https://aws.amazon.com/ko/fsx/lustre/">Amazon FSx for Lustre</a> 를 출시했습니다. 또한 S3 와 통합해서 상대적으로 높은 처리량이 필요하지 않은 분석 전후의 데이터는 S3에 보관할 수 있습니다.</p><h4 id="AWS-DataSync">AWS DataSync</h4><p><img src="https://d1.awsstatic.com/r2018/b/product-page-diagram_Sync(Final).d10b7228ccf2256a072408532a4650720248e1c4.png" alt="https://aws.amazon.com/ko/datasync/"></p><p><a href="https://aws.amazon.com/ko/datasync/">AWS DataSync</a> 는 데이터 이동을 자동 및 가속화해주는 서비스로 Amazon S3, Amazon Elastic File System(<em>EFS</em>), 온프레미스 간에 데이터를 쉽게 이동시키는 서비스입니다. 10Gbps의 빠른 속도로 데이터를 전송할 수 있어 마이그레이션이나 데이터 처리 작업, 재해 복구 등에 사용할 수 있습니다.</p><h4 id="AWS-Transfer-for-SFTP">AWS Transfer for SFTP</h4><p><img src="https://d1.awsstatic.com/r2018/b/Product-Page-Diagram_Necco_How-it-works.f40e89ca89b3183769613d2407d54858265c43c2.png" alt="https://aws.amazon.com/ko/sftp/"></p><p><a href="https://aws.amazon.com/ko/sftp/">AWS Transfer for SFTP</a> 는 S3에 데이터를 업로드하고 관리할 경우 SFTP(<em>Secure File Transfer Protocol</em>)를 제공하는 서비스입니다. 따로 SFTP 서버를 관리할 필요 없이 제공되는 엔드 포인트를 사용하면 됩니다.</p><h2 id="데이터베이스-Database">데이터베이스 Database</h2><p>AWS는 여러가지 DB 서비스를 제공하고 있습니다. 필요에 따라 쉽게 구성할 수 있고 서버를 관리할 필요 없이 확장성, 가용성, 내구성 등을 누릴 수 있습니다.</p><ul><li><a href="https://aws.amazon.com/ko/rds/">Amazon Relational Database Service</a>(RDS) : Oracle, MySQL 등 관계형 DB 서비스를 제공.<br>특히 MySQL과 PostreSQL과 호환되는 클라우드 최적화 RDB인 <a href="https://aws.amazon.com/ko/rds/aurora/">Amazon Aurora</a> 서비스 제공.</li><li><a href="https://aws.amazon.com/ko/dynamodb/">Amazon DynamoDB</a> : 완전 관리형 NoSQL(<em>Key/Value, Document</em>) DB 서비스</li><li><a href="https://aws.amazon.com/ko/elasticache/">Amazon ElasticCache</a> : 인메모리 DB인 <a href="https://aws.amazon.com/redis/">Redis</a> 와 <a href="https://aws.amazon.com/ko/memcached/">Memcached</a> 를 완전관리형으로 제공</li><li><a href="https://aws.amazon.com/ko/neptune/">Amazon Neptune</a> : 완전 관리형 그래프 데이터베이스.</li></ul><p>이번 행사에서는 시계열 데이터와 블록체인 데이터를 처리할 수 있는 제품이 출시되어 더 다양한 데이터베이스를 선택할 수 있게 되었습니다.</p><h3 id="Amazon-DynamoDB-업데이트">Amazon DynamoDB 업데이트</h3><p>먼저 Amazon DynamoDB 에 몇 가지 기능이 추가되었는데요. 기존에 read/write 용량 산정 문제를 해결하기 위해 트래픽에 따라 자동으로 용량이 조절되는 <a href="https://aws.amazon.com/ko/blogs/korea/amazon-dynamodb-on-demand-no-capacity-planning-and-pay-per-request-pricing/">DynamoDB On-Demand</a> 기능을 추가했습니다. 또한 <a href="https://aws.amazon.com/ko/blogs/aws/new-amazon-dynamodb-transactions/">DynamoDB Transactions</a> 기능 추가로 비관계형 DB에서는 처음으로 ACID 트랜잭션을 지원합니다. 따라서 여러 테이블을 엮어 복잡한 비즈니스 로직을 구현할 수 있게 되었습니다.</p><h3 id="Amazon-Timestream">Amazon Timestream</h3><p>IoT 센서 데이터나 DevOps 로그 데이터 등 시간에 따른 변화를 측정하는 시계열(<em>time-series</em>) 데이터는 일반 RDB로 효율적인 처리가 어렵습니다. <a href="https://aws.amazon.com/ko/timestream/">Amazon Timestream</a> 은 RDB의 1/10 비용으로 하루에 수조 건의 이벤트를 저장하고 분석할 수 있는 완전관리형 시계열 데이터베이스 서비스입니다.</p><h3 id="Amazon-QLDB">Amazon QLDB</h3><p><img src="https://d1.awsstatic.com/r2018/h/99Product-Page-Diagram_AWS-Quantum.f03953678ba33a2d1b12aee6ee530e45507e7ac9.png" alt="https://aws.amazon.com/ko/qldb/"></p><p>AWS 를 활용해 블록체인을 사용하는 사례가 많아지면서 블록체인 원장을 관리하는 완전관리형 데이터베이스가 출시되었습니다. <a href="https://aws.amazon.com/ko/qldb/">Amazon Quantum Ledger Database</a>(<em>QLDB</em>)는 기존 RDB를 이용해 원장을 관리할 경우 구축하기 어려운 감사 기능을 제공합니다. 투명하고 변경 불가능하며 암호화 방식으로 검증 가능한 트랜잭션 로그를 제공하고 이러한 로그는 신뢰할 수 있는 중앙 기관에서 소유합니다. 애플리케이션 데이터의 내역을 정확하게 유지 관리할 피룡가 있는 은행 트랜잭션, 보험 청구 계보 확인, 공급망 네트워크에서의 품목 이동 추적 등에 사용됩니다.</p><h3 id="Amazon-Managed-Blockchain">Amazon Managed Blockchain</h3><p><img src="https://d1.awsstatic.com/r2018/h/Product-Page-Diagram_AWS-Taiga_Final.a0b72383455f676fa9b466305b396811748a7710.png" alt="https://aws.amazon.com/ko/managed-blockchain/?nc2=h_re"></p><p>블록체인 관련해서 하나의 서비스가 더 출시되었는데요. <a href="https://aws.amazon.com/ko/managed-blockchain/?nc2=h_re">Amazon Managed Blockchain</a> 은 Hyberledger Fabric 또는 Ethereum 중에서 선택해 블록체인 네트워크를 쉽게 구축할 수 있는 완전관리형 서비스입니다. 쉽게 확장 가능하고  QLBD와 연동해 데이터를 저장하고 추가 분석할 수 있습니다.</p><h2 id="머신-러닝과-인공-지능-ML-AI">머신 러닝과 인공 지능 ML &amp; AI</h2><p>머신 러닝과 인공 지능은 다양한 분야에서 혁신을 이끌어내고 있습니다. 특히 고성능 컴퓨터와 스토리지가 필요하기 때문에 클라우드컴퓨팅을 활용하는 것이 효율적인데요. 또한 AWS 는 복잡한 머신 러닝 과정을 줄여주는 플랫폼과 머신 러닝 서비스, 그리고 바로 사용할 수 있는 인공 지능 서비스를 제공합니다. 이번 행사에서 공개된 서비스들을 살펴봅니다.</p><h3 id="머신-러닝">머신 러닝</h3><h4 id="Amazon-Elastic-Inference">Amazon Elastic Inference</h4><p>딥 러닝(<em>Deep Learning</em>)은 다양한 정보를 축적하는 학습(<em>Learning</em>)과 그 지식을 기반으로 새로운 정보에 답을 스스로 도출해내는 추론(<em>Inference</em>)으로 이루어집니다. 이 중에서 추론 작업은 학습 작업보다 인프라 비용이 훨씬 많이 듭니다. 특히 학습 작업에 사용하는 GPU를 그대로 사용할 경우 효율성은 절반 정도까지 떨어질 수 있습니다. 왜냐하면 추론 작업은 많은 데이터 샘플을 병렬로 배치 처리하는 학습 작업과 달리, 단일 입력으로 GPU 컴퓨팅을 사용하기 때문에 GPU 성능을 완전히 활용할 수 없습니다. 또한 모델에 따라 탄력적으로 리소스를 사용하기 때문에 무조건 큰 GPU 인스턴스를 사용하는 것은 비효율적입니다.</p><p><a href="https://aws.amazon.com/ko/machine-learning/elastic-inference/">Amazon Elastic Inference</a> 는 기존 Amazon EC2 및 Amazon SageMaker 인스턴스에 필요한 만큼 GPU 가속을 더해 딥 러닝 추론 비용을 최대 75%까지 절감해주는 서비스입니다. 또한 작업량에 따라 인스턴스가 오토스케일링(<em>Auto Scailing</em>)되므로 리소스를 효율적으로 사용할 수 있습니다.</p><h4 id="AWS-Inferentia">AWS Inferentia</h4><p>AWS Inferentia 는 머신 러닝 추론을 위해 AWS 에서 커스터마이징한 칩입니다. 추론 작업의 성능은 높이고 비용은 낮추기 위한 칩으로 TensorFlow, Apache MXNet, PyTorch 등 다양한 딥 러닝 프레임워크를 지원할 예정입니다. 또한 Amazon EC2, Amazon SageMaker 인스턴스, 그리고 Amazon Elastic Interface 와 함께 사용할 수 있습니다.</p><h4 id="Amazon-SageMaker">Amazon SageMaker</h4><p>머신 러닝은 사용하기 위한 프로세스가 상당히 복잡하고 시간이 오래 걸립니다. 먼저 학습 데이터를 수집 및 저장하고, 알고리즘을 선택하고, 데이터를 학습할 인프라를 구축해야 합니다. 오랜 시간 훈련과 학습 모델을 수작업으로 튜닝한 후에 적절한 인프라에 배포하고 운영하는 과정을 거치게 됩니다.</p><p>Amazon SageMaker 는 구축, 학습, 배포까지 복잡한 머신 러닝 과정을 줄여주는 완전관리형 플랫폼입니다. 이번 행사에서도 이를 지원하는 다양한 기능이 출시되었습니다.</p><h4 id="Amazon-SageMaker-Ground-Truth">Amazon SageMaker Ground Truth</h4><p><img src="https://d1.awsstatic.com/r2018/r/Samurai/SamurAI%20Customer%20Assets/Product-Page-Diagram_SamurAI_How-it-works-2.bc19de267c29570783c4add8bb2286ee584fcfbc.png" alt="https://aws.amazon.com/ko/sagemaker/groundtruth/?nc2=h_re"></p><p>머신 러닝 모델이 성공하려면 학습 데이터가 얼마나 품질이 뛰어나고 얼마나 양이 많은지가 중요합니다. 하지만 이런 데이터를 준비하는건 쉽지 않은 일입니다. 특히 모델이 제대로 배울 수 있도록 사람이 수동으로 레이블 작업을 해야합니다. 이는 데이터가 많으면 많수록 시간과 노력이 많이 드는 작업이죠. <a href="https://aws.amazon.com/ko/sagemaker/groundtruth/?nc2=h_re">Amazon SageMaker Ground Truth</a> 는 머신 러닝을 이용해 레이블링을 자동화해서 학습 데이터를 생성하는데 드는 비용을 줄여줍니다. 사용자의 레이블링을 학습해서 점점 더 개선된 레이블링 작업을 수행할 수 있습니다.</p><h4 id="Amazon-SageMaker-Neo">Amazon SageMaker Neo</h4><p><img src="https://d1.awsstatic.com/r2018/r/Neo/Product-Page-Diagram_Neo-How-it-Works.9845ca7e23290bc849f36cb947ef81bd967825ef.png" alt="https://aws.amazon.com/ko/sagemaker/neo/"></p><p>자율 차량의 센서처럼 엣지 디바이스에서 머신 러닝 모델이 동작하려면 작은 사이즈와 빠른 속도가 필요합니다. <a href="https://aws.amazon.com/ko/sagemaker/neo/">Amazon SageMaker Neo</a> 는 모델을 자동으로 최적화해서 최대 2배 빠른 성능을 제공합니다. 이미 학습된 모델에서 하드웨어 플랫폼을 선택하기만 하면 됩니다. 빌드가 끝나면 <a href="https://aws.amazon.com/ko/greengrass/">AWS Greengrass</a> 를 이용해 원하는 엣지로 무선 배포할 수 있습니다. Amazon SageMaker Neo 는 앞으로 오픈 소스로 공개될 예정입니다.</p><h4 id="Amazon-SageMaker-RL">Amazon SageMaker RL</h4><p>딥 러닝은 목표와 데이터에 따라 다양한 학습 방식을 선택할 수 있습니다.</p><ul><li>지도 학습(<em>Supervised Learning</em>) : 이미 분류된 데이터로 답을 주고 학습해 데이터를 식별</li><li>자율 학습(<em>Unsupervised Learning</em>) : 분류되어 있지 않은 데이터 또는 답을 알 수 없는 경우 자동으로 특징을 추출하고 패턴을 찾아냄</li><li>준지도 학습(<em>Semi-supervised Learning</em>) : 지도 + 자율 학습 형태로, 적은 양의 분류된 데이터로 정확성을 향상 시킬 수 있음</li><li>강화 학습(<em>Reinforcement Learning</em>) : 피드백(보상과 페널티)을 이용해 특정한 목표를 달성시키기 위한 최적의 방법을 스스로 찾아내도록 학습시키는 방법</li></ul><p>특히 강화 학습은 게임과 유사한데요, 레이블이 지정된 학습 데이터 없이 게임을 반복하면서 요령을 터득하고 최적의 방법을 스스로 찾아내는 것입니다. 그래서 생각지도 못한 재미있는 행동을 보이기도 한다고 합니다.</p><p><a href="https://aws.amazon.com/ko/blogs/aws/amazon-sagemaker-rl-managed-reinforcement-learning-with-amazon-sagemaker/">Amazon SageMaker RL</a> 은 SageMaker 를 이용해 쉽게 강화 학습을 할 수 있도록 도와주는 툴킷입니다. 인프라는 모두 제공되므로 학습에만 집중할 수 있습니다.</p><h4 id="AWS-Marketplace-for-Machine-Learning">AWS Marketplace for Machine Learning</h4><p>좋은 알고리즘을 선택하는 것도 중요하겠죠? <a href="https://aws.amazon.com/marketplace/solutions/machinelearning/">AWS Marketplace</a> 에서는 SageMaker 에서 바로 사용할 수 있는 알고리즘을 제공합니다. 알고리즘을 검색해 원 클릭으로 신청할 수 있습니다. 또한 가지고 있는 모델을 패키징해서 공유 및 판매할 수도 있습니다.</p><p>이제 데이터셋 구축, 알고리즘 선택, 뛰어난 인프라까지 마련되어 있으니 머신 러닝의 진입 장벽이 한껏 낮아진 것 같네요. 저도 아직 머신 러닝과 딥 러닝에 대한 지식은 부족하지만 뭔가 해보고 싶어집니다.</p><h4 id="AWS-DeepRacer">AWS DeepRacer</h4><p><img src="deep-racer.png" alt="https://aws.amazon.com/ko/deepracer/"></p><p><a href="https://aws.amazon.com/ko/deepracer/">AWS DeepRacer</a> 는 강화 학습을 이용한 자율 주행 경주용 자동차입니다. 1/18 비율의 작은 자동차로 직접 강화 학습을 실험하고 학습 시킬 수 있습니다. 클라우드 기반 3D 경주 시뮬레이터에서 가상 자동차로 학습하고 모델을 AWS DeepRacer 에 배포해 실제로 경주할 수 있습니다. 글로벌 AWS DeepRacer 리그도 열린다고 하는데요, 리전 별로 예선 후 내년 re:Invent 행사에서 결승전을 한다고 합니다. 세계 최초의 자율 주행 레이싱 리그라고 하는데, 친구들과 팀 짜서 해보고 싶네요! 현재 아마존에서 <a href="https://www.amazon.com/dp/B07JMHRKQG">사전 주문</a>이 가능하고 가격은 $249로 약 28만원 정도입니다.</p><h3 id="인공-지능">인공 지능</h3><p>여러 분야에서 머신 러닝과 딥 러닝을 통한 인공지능을 구축해 다양한 서비스를 제공하고 있지만, 아직 많은 기업은 이런 서비스를 만들고 제공하기가 어렵습니다. 그래서 AWS 는 머신 러닝과 딥 러닝을 위한 인프라와 서비스 외에도 직접 사용할 수 있는 AI 서비스도 제공하고 있습니다.</p><h4 id="Amazon-Personalize">Amazon Personalize</h4><p><img src="https://d1.awsstatic.com/r2018/r/Concierge/product-page-diagram_amazon_personalize_how-it-works.3ceac8883c7d6bd67d7cf26d8a7d505520d02a40.png" alt="https://aws.amazon.com/ko/personalize/?nc2=h_re"></p><p>요즘 어디서나 추천 서비스를 많이 볼 수가 있는데요. <a href="https://aws.amazon.com/ko/personalize/?nc2=h_re">Amazon Personalize</a> 는 <a href="http://Amazon.com">Amazon.com</a> 에서 실제로 사용하는 기술을 기반으로 실시간 개인화 및 추천 서비스를 제공합니다. 따라서 API 호출로 간단하게 시작할 수 있고 음악, 비디오, 제품 등 다양한 추천 서비스를 쉽게 구성할 수 있으며 분석한 데이터는 비공개로 안전하게 유지됩니다.</p><h4 id="Amazon-Forecast">Amazon Forecast</h4><p><img src="https://d1.awsstatic.com/r2018/r/seer/diagrams/Seer_HowitWorks_Final.44b02658b17d05e9242b450b220f6e0ca4065638.png" alt="https://aws.amazon.com/ko/forecast/?nc2=h_re"></p><p>Amazon Forecast 는 기존의 데이터를 통해 앞으로를 예측하는 서비스를 제공합니다. 이 또한 <a href="http://Amazon.com">Amazon.com</a> 에서 실제로 사용하는 기술을 기반으로 직접 구축 시의 1/10 비용으로 50% 이상의 정확도를 제공합니다. 따로 머신을 만들어 학습시키지 않아도 제품 수요 계획, 재정 계획, 리소스 계획 등 시계열 데이터 기반의 예측 서비스를 바로 사용할 수 있습니다.</p><h4 id="Amazon-Textract">Amazon Textract</h4><p>Amazon Textract 는 스캔한 문서에서 자동으로 문자를 추출하는 서비스입니다. 단순히 문자를 인식하는 OCR(<em>optical character recognition</em>)에서 AI 를 이용해 문서 내 텍스트와 데이터를 의미적으로 추출할 수 있습니다. 그냥 문자를 추출하는 것이 아니라 내용을 이해하고 추출하는 것이기 때문에 더 정확하게 추출이 가능합니다.</p><h4 id="Amazon-Lake-Formation">Amazon Lake Formation</h4><p><img src="https://d1.awsstatic.com/r2018/h/Product-Page-Diagram_AWS-Michigan_How-it-Works.66bf84184ed47056b25e87f6a23bf3b740336436.png" alt="https://aws.amazon.com/ko/lake-formation/"></p><p>데이터 레이크(<em>Data Lake</em>)는 빅 데이터와 함께 다양한 비정형 데이터(소셜 텍스트, 센서 데이터, 이미지, 동영상 등)를 관리하기 위해 나온 개념입니다. 원형 데이터는 그 자체로는 의미를 찾을 수 없으므로 이를 가공하고 분석할 수 있도록 수집, 정제, 변환 등 데이터를 준비해야 합니다. 이런 작업은 실제 분석 과정보다도 더 오래 걸리고 복잡한 작업으로, 데이터 레이크는 데이터를 분석에 필요한 형태로 저장해주는 중앙 집중식 리파지토리입니다.</p><p>AWS Lake Formation 는 며칠 만에 쉽게 설정할 수 있는 서비스로 데이터 레이크 설정 및 관리에 필요한 기능을 제공합니다. 이를 이용해 머신 러닝과 빅 데이터 분석에 사용할 데이터를 쉽게 관리할 수 있습니다.</p><h2 id="보안과-하이브리드-클라우드-Security-Hybrid-Cloud">보안과 하이브리드 클라우드 Security &amp; Hybrid Cloud</h2><h3 id="보안">보안</h3><p>보안은 클라우드에서 가장 중요한 요소 중 하나입니다. 내 소중한 애플리케이션 코드나 데이터를 내가 모르는 어딘가에 저장해놓는 것은 어떻게 보면 불안한 일이니까요. 이번 행사에서는 중앙에서 보안을 확인하고 통제할 수 있는 서비스가 출시되었습니다.</p><h4 id="AWS-Security-Hub">AWS Security Hub</h4><p><img src="https://d1.awsstatic.com/r2018/b/aws-security-hub/How-it-works-Security_Hub.824eb4a28d19cebfe1f93cb7de75807ce81f6e2b.png" alt="https://aws.amazon.com/ko/security-hub/"></p><p><a href="https://aws.amazon.com/ko/security-hub/">AWS Security Hub</a> 는 AWS 계정 전반에 걸친 보안 경고와 컴플라이언스 상태를 중앙에서 한번에 살펴볼 수 있는 서비스입니다. 산업 표준 및 모범 사례에 따라 검사를 수행하고 컴플라이언스 지수로 확인할 수 있습니다. 따라서 보안 경고를 빠르게 찾아 위험을 제거할 수 있습니다.</p><h4 id="AWS-Control-Tower">AWS Control Tower</h4><p><a href="https://aws.amazon.com/ko/controltower/">AWS Control Tower</a> 는 여러 계정을 관리하는 경우 모범 사례에 따라 안전한 환경을 구성할 수 있습니다.</p><h3 id="하이브리드-클라우드-환경">하이브리드 클라우드 환경</h3><p>얼마 전 AWS 장애 사태나 KT 화재를 보면 하나의 인프라에 종속되는 것이 위험하다는 걸 알 수 있습니다. 또한 클라우드마다 장단점이 있고 온프레미스 환경이 필요한 경우도 있기 때문에 여러 환경을 같이 사용하는 경우가 많아지고 있습니다.</p><ul><li>하이브리드 클라우드 : 하나 이상의 퍼블릭 클라우드와 프라이빗 클라우드 환경을 조합.</li><li>멀티클라우드 : 두 곳 이상의 클라우드 벤더가 제공하는 클라우드를 환경(퍼블릭 또는 프라이빗).</li></ul><h4 id="AWS-Outosts">AWS Outosts</h4><p><img src="https://d1.awsstatic.com/r2018/e/product-page-diagram_frontier_how-it-works_Final.c526697b5426ef2c48b8a945c8458de2e8def3fe.png" alt="https://aws.amazon.com/ko/outposts/"></p><p>무조건 클라우드가 좋은 것은 아니죠. 데이터 센터나 서버를 직접 관리하는 방식인 온프레미스를 유지해야 하는 경우도 있습니다. 서버가 잠시라도 끊어져선 안되는 경우, 기밀성이나 자체 보안 규정이 필요한 경우, 성능이 중요한 경우 등이 있습니다. 이렇게 온프레미스 환경이나 하이브리드 클라우드 환경은 구성 및 관리가 쉽지 않은데요, <a href="https://aws.amazon.com/ko/outposts/">AWS Outosts</a> 는 기존 온프레미스 환경에서 AWS 에서 사용하는 것과 동일한 서비스, 인프라, 관리 도구, 개발 및 배포 모델을 사용할 수 있는 설치형 서비스입니다.</p><h4 id="AWS-Well-Architected">AWS Well-Architected</h4><p><img src="https://d1.awsstatic.com/Well%20Architected/How%20it%20Works.6877191cd131d35300b5b95082e267516dd970df.png" alt="https://aws.amazon.com/ko/well-architected-tool/"></p><p>보통 클라우드를 사용하면 운영하기 편하고, 보안도 좋고, 성능이나 비용 면에서도 유리하다고 합니다. 하지만 그냥 클라우드를 사용한다고 해서 이런 이점을 누릴 수 있는 것은 아닙니다. 클라우드의 이점을 최대한 활용할 수 있는 설계가 중요합니다. AWS 는 <a href="https://d1.awsstatic.com/r2018/e/product-page-diagram_frontier_how-it-works_Final.c526697b5426ef2c48b8a945c8458de2e8def3fe.png">AWS Well-Architected</a> 에서 운영 탁월성, 보안, 신뢰성, 성능, 비용 최적화 총 5가지 항목에 대해서 모범 사례와 백서를 제공합니다. 또한 신청 시 아키텍처 교육이나 컨설팅을 받을 수도 있습니다. 또는 이번에 출시된 <a href="https://aws.amazon.com/ko/well-architected-tool/">AWS Well-Architectued Tool</a> 을 이용해 온라인에서 아키텍처를 검토하고 모범 사례와 비교할 수 있습니다.</p><h2 id="차세대-산업-IoT-로봇-우주-산업">차세대 산업 (IoT, 로봇, 우주 산업)</h2><p>AWS 는 이미 많은 비즈니스 분야를 지원하고 있습니다. 인공지능과 블록체인 외에도 IoT 지원을 강화하고 새롭게 로봇과 우주산업을 지원합니다. 이러한 산업은 아직 가치가 많지만 진입 장벽이 높은 분야입니다. 하지만 AWS의 서비스를 이용해 진입 장벽을 낮추고 투자 비용을 절감할 수 있습니다.</p><h3 id="사물인터넷-IoT">사물인터넷 IoT</h3><p><img src="https://d1.awsstatic.com/r2018/b/IoT%20Category/IoT%20Service%20Overview.157df3656b0dc4d5feb6909657fdd7dd3c5c71fe.png" alt="https://aws.amazon.com/ko/iot/"></p><p>IoT(<em>Internet of Things</em>) 또한 4차 산업혁명의 한 분야로 각광을 받고 있습니다. 다양한 디바이스를 연결하고 데이터를 수집해서 분석할 수 있는데요, 여기에 AI 서비스가 통합되면서 비즈니스 영역은 더 넓어집니다. 이에 맞춰 AWS IoT 는 장비의 엣지 네트워크와 AWS 클라우드에서 사용할 수 있는 다양한 기능을 제공합니다. 이번 행사에서는 세 가지 IoT 관련 서비스를 출시했습니다.</p><h4 id="AWS-IoT-Events">AWS IoT Events</h4><p><img src="https://d1.awsstatic.com/r2018/b/Columbo/product-page-diagram_columbo_how-it-works%20(1).6916f57c486b500160591b5c22a455e1add1f981.png" alt="https://aws.amazon.com/ko/iot-events/?nc2=h_re"></p><p>IoT 센서를 이용해서 받은 여러 이벤트를 사용하기 위해서는 직접 애플리케이션을 만들고 탐지한 후 대응 로직을 트리거해야 했습니다. 대신 <a href="https://aws.amazon.com/ko/iot-events/">AWS IoT Events</a> 는 IoT 센서와 애플리케이션에서 이벤트를 쉽게 탐지하고 대응할 수 있는 완전관리형 서비스입니다. 냉동실의 온도, 호흡 장치의 습도, 모터의 벨트 속도 등 여러 IoT 센서에서 쉽게 이벤트를 탐지하고 트리거할 수 있습니다.</p><h4 id="AWS-IoT-SiteWise">AWS IoT SiteWise</h4><p><img src="https://d1.awsstatic.com/r2018/b/Bifrost/product-page-diagram_bifrost_how-it-works(1).03bcd12f2532e08ef00ed83cb0d8f2df86fd4dd2.png" alt="https://aws.amazon.com/ko/iot-sitewise/"></p><p><a href="https://aws.amazon.com/ko/iot-sitewise/">AWS IoT SiteWise</a> 는 산업용 장비에서 데이터를 클라우드에 안전하게 저장하고 관리할 수 있는 서비스입니다. 또한 모니터링 기능으로 장비 고장, 공정 중단, 제품 결함, 생산 비효율성 등의 상황을 손쉽게 파악할 수 있습니다.</p><h4 id="AWS-IoT-Things-Graph">AWS IoT Things Graph</h4><p><img src="https://d1.awsstatic.com/r2018/b/ThingsGraph/Drag%20and%20Drop%20for%20AWS%20IoT%20Things%20Graph.d8cb954777a3b1a80db932585ecf6d599947c945.png" alt="https://aws.amazon.com/ko/iot-things-graph/"></p><p><a href="https://aws.amazon.com/ko/iot-things-graph/">AWS IoT Things Graph</a> 는 디바이스와 서비스를 그래프 형태로 보여주고 손 쉽게 빌드할 수 있는 기능을 제공하는 서비스입니다. 또한 빌드한 애플리케이션은 몇 번의 클릭을 이용해 디바이스에 간단하게 배포할 수 있습니다.</p><h3 id="AWS-RoboMaker">AWS RoboMaker</h3><p><img src="https://media.amazonwebservices.com/blog/2018/robo_rxvt_view_1.gif" alt="https://aws.amazon.com/ko/blogs/korea/aws-robomaker-develop-test-deploy-and-manage-intelligent-robotics-apps/"></p><p>대학교 때 임베디드 프로그래밍을 하면서 로봇 자동차 키트를 만들었던 기억이 나네요. 하지만 로봇을 만들어서 로봇 산업에 진출한다는 생각은 못해봤습니다. 왜냐하면 로봇과 머신 러닝에 대한 전문 지식 뿐 아니라 작업 설정과 시뮬레이션 환경 구축, 애플리케이션 관리 시스템과 통합하는 등 시간과 비용이 많이 들기 때문입니다.</p><p><a href="https://aws.amazon.com/ko/robomaker/">AWS RoboMaker</a> 는 지능형 로봇을 개발, 테스트, 배포, 관리할 수 있는 서비스입니다. AWS 의 컴퓨팅 인프라를 바탕으로 오픈 소스 로보틱스 프레임워크인 ROS(<em>Robot Operating System</em>)를 포함한 개발환경을 제공합니다. 또한 비싼 하드웨어와 물리적 테스트 환경 대신 3D 시뮬레이션 테스트 환경을 제공하고 빌드한 결과를 실제 로봇에 무선으로 배포할 수 있습니다. 따라서 부담스러운 작업을 제거하고 로보틱스 애플리케이션을 만드는 데 집중할 수 있습니다.</p><h3 id="AWS-Ground-Station">AWS Ground Station</h3><p><img src="https://d1.awsstatic.com/about-aws/Global%20Infrastructure/product-page-diagram_astra_how-it-works.56541b02eaa1cc5a28e3162faeee7d5768a30492.png" alt="https://aws.amazon.com/ko/ground-station/"></p><p>개인적으로 굉장히 놀랐던 부분입니다. 우주에 대한 관심이 많아지고 우주 산업에 대한 이야기도 많아지고 있습니다. 엘론 머스크는 민간 우주 항공 기업인 <a href="https://www.spacex.com">스페이스X</a>(<em>SpaceX</em>)를 설립하기도 했죠. 그리고 이미 수 천개의 소형 위성이 운용 중이거나 발사 예정입니다. 이런 위성의 데이터를 이용해 날씨 예측, 표층 이미지, 통신, 비디오 브로드캐스트 등 다양한 용도로 사용해 비즈니스를 할 수 있습니다.</p><p>하지만 개인이나 작은 회사가 이런 사업에 뛰어들기가 쉽지 않습니다. 핵심은 위성에 명령을 내리고 데이터를 수신하는 그라운드 스테이션인데요. 이 그라운드 스테이션을 직접 건설하거나 장기 임대해야 하고, 데이터를 저장 및 전송하는 서버, 스토리지, 네트워크 등이 필요합니다. 확장을 위해 인프라를 증설하는 것도 어렵습니다.</p><p><a href="https://aws.amazon.com/ko/ground-station/">AWS Ground Station</a> 은 그라운드 스테이션을 서비스 형태(<em>Ground-as-a-Service</em>)로 제공합니다. 따라서 자체 그라운드 스테이션 인프라를 구축하거나 관리할 필요 없이 인공위성 통신을 제어하고 데이터를 처리할 수 있는 완전관리형 서비스입니다. 또한 AWS 에서 제공하는 다른 서비스와 통합하기도 쉽습니다. Amazon S3 에 데이터를 저장하거나, Amazon Kinesis 를 이용해 데이터를 수집하고 Amazon SageMaker 로 머신 러닝 학습을 하는 등 다양한 방식으로 활용할 수 있습니다. 비용도 사용한 만큼만 지불하기 때문에 그라운드 스테이션 운영 비용을 80%까지 절감할 수 있습니다.</p><p><img src="https://d1.awsstatic.com/about-aws/Global%20Infrastructure/product-page-diagram_astra_use-case_natural-disaster%20(1).aa0afc1bb6ebd3f3efef1acf9e600198d3877685.png" alt="https://aws.amazon.com/ko/ground-station/"></p><p>위 그림은 자연재해에 대처하는 사용 사례입니다. 자연재해가 발생했을 때 다운링크된 데이터를 분석해 생존자를 파악하고 구조물 손상을 파악할 수 있습니다. 파악한 내용을 구급대원과 구조 팀에게 전달해서 빠르게 대처할 수 있습니다. 또한 이런 데이터를 분석하고 머신 러닝을 이용해 가장 안전한 탈출 경로, 임시 쉼터와 긴급 의료 시설에 적합한 장소를 파악할 수도 있습니다.</p><h2 id="결론">결론</h2><p>이상으로 AWS re:Invent 2018 에서 소개된 서비스를 대락적으로 살펴봤습니다. 수많은 기존 서비스를 더욱 더 편리하게 만들고 새로운 서비스와 조합하면서 새로운 기회와 가능성이 열렸습니다. 계속해서 발전하는 이 AWS 생태계에서 나는 무엇을 할 수 있을까 생각해보게 됩니다. 특히 로봇이나 우주 산업은 상상력을 자극합니다. 상상은 해봤지만 너무나 전문 영역이라 다가갈 수 없는 분야의 진입 영역을 낮추고 비용을 절감할 수 있는 것이 인상깊었습니다. 그리고 개인적으로 관심 있지만 다가가기 어려웠던 머신 러닝과 인공 지능 개발을 시도해볼 수 있을 것 같습니다.</p><h2 id="참고">참고</h2><ul><li><a href="https://www.slideshare.net/awskorea/aws-reinvent-2018-new-services-channy">AWS re:Invent 2018 신규 서비스 살펴보기 | SlideShare</a></li><li><a href="https://aws.amazon.com/ko/blogs/korea/category/events/reinvent/">Category: AWS re:Invent | AWS 한국 블로그</a></li></ul><h2 id="Related-Posts">Related Posts</h2><ul><li><a href="/2018/11/16/docker-container-basics/" title="도커 Docker 기초 확실히 다지기">도커 Docker 기초 확실히 다지기</a></li><li><a href="/2018/11/09/it-infrastructure-basics/" title="개발자를 위한 인프라 기초 총정리">개발자를 위한 인프라 기초 총정리</a></li><li><a href="/2018/10/25/google-cloud-summit-seoul-2018/" title="구글 클라우드 서밋 서울 2018 후기">구글 클라우드 서밋 서울 2018 후기</a></li><li><a href="/2018/07/04/aws-certified/" title="AWS 자격증 준비하기">AWS 자격증 준비하기</a></li><li><a href="/2019/01/19/spring-boot-containerization-and-ci-cd-to-kubernetes-cluster/" title="스프링 부트 컨테이너와 CI&#x2F;CD 환경 구성하기">스프링 부트 컨테이너와 CI&#x2F;CD 환경 구성하기</a></li><li><a href="/2019/02/25/kubernetes-cluster-on-google-compute-engine-for-developers/" title="개발자를 위한 쿠버네티스(Kubernetes) 클러스터 구성하기(Kubeadm, GCE, CentOS)">개발자를 위한 쿠버네티스(Kubernetes) 클러스터 구성하기(Kubeadm, GCE, CentOS)</a></li></ul><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">https://aws.amazon.com/ko/ec2/instance-types/<a href="#fnref:1" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;p&gt;&lt;a href=&quot;https://reinvent.awsevents.co</summary>
      
    
    
    
    <category term="Cloud" scheme="https://futurecreator.github.io/categories/Cloud/"/>
    
    
    <category term="aws" scheme="https://futurecreator.github.io/tags/aws/"/>
    
    <category term="2018" scheme="https://futurecreator.github.io/tags/2018/"/>
    
    <category term="re-invent" scheme="https://futurecreator.github.io/tags/re-invent/"/>
    
  </entry>
  
  <entry>
    <title>도커 Docker 기초 확실히 다지기</title>
    <link href="https://futurecreator.github.io/2018/11/16/docker-container-basics/"/>
    <id>https://futurecreator.github.io/2018/11/16/docker-container-basics/</id>
    <published>2018-11-15T17:33:48.000Z</published>
    <updated>2025-03-14T16:10:24.238Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>이전 <a href="https://futurecreator.github.io/2018/11/09/it-infrastructure-basics/">개발자를 위한 인프라 기초 총정리</a> 포스트에서 컨테이너와 도커에 대해 간단히 살펴봤습니다. 이해하기 어려운 개념은 아니지만 막상 뭔가를 하려면 막막할 수 있는데요, 이번 포스트에서는 도커의 컴포넌트와 내부 기술을 알아보고 가상 환경을 구축해서 도커를 설치하고 실행해보려고 합니다.</p><h2 id="도커-Docker">도커 Docker</h2><p>애플리케이션은 하드웨어, OS, 미들웨어 등 인프라 환경에 민감하게 반응할 때가 많습니다. 개발 환경과 테스트 환경에서는 동작을 잘 하다가 제품 환경에서는 동작하지 않는 경우도 있습니다. 이럴 경우 고객사의 인프라, 보안 환경, 각종 OS 나 미들웨어의 버전 등 원인이 다양할 수 있어 찾기가 쉽지 않습니다.</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*easlVE_DOqRDUDkVINRI9g.png" alt="https://medium.freecodecamp.org/docker-quick-start-video-tutorials-1dfc575522a0"></p><p>도커는 애플리케이션 뿐만 아니라 실행에 필요한 시스템 환경을 모아서 컨테이너(<em>Container</em>)로 관리합니다. 이렇게 만든 것을 도커 이미지(<em>Docker Image</em>)라고 하는데 이 이미지로 만든 컨테이너는 도커가 설치된 곳이라면 어디든 똑같이 동작합니다. 그곳이 Windows 든, macOS 든, Linux 든 상관이 없고 온프레미스(<em>On-premise</em>) 든 클라우드든 상관 없습니다.</p><p><img src="https://programmaticponderings.files.wordpress.com/2015/06/introdockercompose.png" alt="https://programmaticponderings.files.wordpress.com/2015/06/introdockercompose.png"></p><p>이를 이용하면 개발자가 커밋을 할 때마다 <a href="https://jenkins.io">Jenkins</a> 와 같은 지속적인 통합(<em>Continuous Integration, CI</em>) 툴에서 해당 소스를 도커 이미지로 빌드하고 이미지 리파지토리에서 이미지를 버전 별로 관리할 수 있습니다. 해당 이미지를 어느 환경이든 배포만 하면 독립적으로 동작하기 때문에 지속적인 딜리버리(<em>Continuous Delivery, CD</em>)가 가능합니다.</p><p>도커는 특히 분산 환경을 쉽게 구축할 수 있는 클라우드 서비스와 잘 맞습니다. 그래서 주요 클라우드 프로바이더들은 모두 컨테이너 실행 환경을 쉽게 관리할 수 있는 서비스를 제공합니다.</p><ul><li><a href="https://aws.amazon.com/ko/ecs/">Amazon Elastic Container Service</a></li><li><a href="https://azure.microsoft.com/ko-kr/services/container-instances/">Microsoft Azure Container Instances</a></li><li><a href="https://cloud.google.com/kubernetes-engine/">Google Cloud Platform Kubernetes Engine</a></li></ul><p>또한 각 서비스를 독립적인 배포 단위로 구성하는 마이크로서비스 아키텍처(<em>Microservices Architecture, MSA</em>)와도 잘 맞습니다. 각 서비스를 컨테이너로 배포하는 것이죠.<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[마이크로서비스 배포 전략](https://futurecreator.github.io/2018/10/19/microservices-deployment-strategy/)">[1]</span></a></sup></p><h2 id="도커의-기능">도커의 기능</h2><p>도커는 컨테이너의 리소스, 파일 시스템, 네트워크를 기존 시스템과 격리시키고 도커 이미지를 관리하고 공유하는 기능을 제공합니다. 도커의 대표적인 기능 세 가지(<em>Build, Ship, Run</em>)를 살펴보겠습니다.</p><h3 id="Build-이미지-만들기">Build - 이미지 만들기</h3><p><img src="https://d1.awsstatic.com/product-marketing/containers/Containers_whats_in_a_container.945c530bfe6e19ea90510967fe8c56be746626b8.png" alt="https://aws.amazon.com/ko/containers/"></p><p>도커는 애플리케이션과 실행에 필요한 라이브러리, 미들웨어, OS, 네트워크 설정 등 필요한 모든 파일을 모아서 도커 이미지로 만듭니다. 도커 이미지는 명령어를 이용해 수동으로 만들 수도 있지만 자동으로 빌드와 배포를 하는 CI/CD 환경에서는 도커 설정 파일(<em>Dockerfile</em>)을 이용해 자동으로 만들 수도 있습니다.</p><p>보통 이미지에는 하나의 애플리케이션만 넣고 여러 컨테이너를 조합해서 서비스를 구축하는 방법을 사용합니다. 또한 이미지를 여러 개 같이 사용할 수 있습니다. 예를 들면 CentOS 리눅스 이미지와 Nginx 웹 서버 이미지를 겹쳐서 새로운 이미지를 만들 수 있습니다.</p><h3 id="Ship-이미지-공유">Ship - 이미지 공유</h3><p><img src="https://docs.docker.com/engine/images/architecture.svg" alt="https://docs.docker.com/engine/docker-overview/#docker-architecture"></p><p>도커 이미지를 업로드해서 공유하는 저장소를 도커 레지스트리(<em>Docker Registry</em>)라고 합니다. 대표적으로는 도커의 공식 레지스트리인 <a href="https://hub.docker.com/">Docker Hub</a> 가 있습니다. 도커 허브에서는 업체에서 제공하는 공식 이미지를 받을 수 있습니다.<sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[Explore Official Repositories | Docker Hub](https://hub.docker.com/explore/)">[2]</span></a></sup> Ubuntu 나 CentOS 같은 OS 이미지, MySQL, Redis, MongoDB, Nginx 와 같은 미들웨어, OpenJDK, Golang, NodeJS 와 같은 플랫폼 이미지도 제공합니다.</p><p>이런 베이스 이미지를 활용하면 환경을 빠르고 안전하게, 그리고 자동으로 구축할 수 있습니다. 내가 만든 애플리케이션 또한 이미지로 만들어서 업로드하고 공유할 수 있습니다. Github 와 같은 형상관리툴과 연동해서 Dockerfile 을 관리하고 도커 이미지를 자동으로 빌드해서 도커 허브로 배포도 가능합니다.</p><p><img src="https://d1.awsstatic.com/diagrams/product-page-diagrams/Product-Page-Diagram_Amazon-ECR.bf2e7a03447ed3aba97a70e5f4aead46a5e04547.png" alt="https://aws.amazon.com/ko/ecr/"></p><p>퍼블릭 클라우드에서는 비공개 레지스트리와 CI/CD 를 쉽게 구성할 수 있는 아키텍처를 제공합니다. <a href="https://aws.amazon.com/ko/ecr/">Amazon Elastic Container Registry</a> 나 Google Cloude Platform 의 <a href="https://cloud.google.com/container-registry/">Container Registry</a> 가 있습니다. 사실 이런 도커 이미지는 보안에 취약합니다. 해당 시스템에 보안 취약점이나 악성 코드가 심어져 있다면 어떨까요? GCP 컨테이너 레지스트리는 보안을 강화하기 위해 컨테이너 이미지가 등록되면 취약점을 스캔하고 정책에 위배되는 이미지는 배포를 막고 잠금 처리하고 있습니다.</p><h3 id="Run-컨테이너-동작">Run - 컨테이너 동작</h3><p>도커는 도커 이미지를 가지고 컨테이너를 생성해서 동작시킵니다. 하나의 이미지를 가지고 여러 개의 컨테이너를 만들어낼 수도 있습니다. 도커는 컨테이너를 생성하고 관리하기 위한 여러 명령을 제공합니다.</p><p>실제 업무에서는 보통 한 대의 호스트에 모든 컨테이너를 동작시키는 것이 아니라 여러 호스트로 된 분산 환경인 경우가 많습니다. 이런 분산 환경에서 여러 노드의 컨테이너를 관리하기 위해 쿠버네티스(<em>Kubernetes, k8s</em>)와 같은 컨테이너 오케스트레이션 툴(<em>Container Orchestration Tool</em>)을 주로 사용합니다. 오케스트레이션이란 컨테이너 배포, 장애 복구, 로드 밸런싱 등 여러 기능을 자동으로 처리해주는 것을 말합니다.</p><h2 id="도커를-구성하는-컴포넌트">도커를 구성하는 컴포넌트</h2><p>도커를 구성하고 있는 컴포넌트는 다음과 같습니다.</p><p><img src="docker-component.png" alt="http://kimstar.kr/7695/"></p><ul><li>Docker Engine : 도커 이미지를 생성하고 컨테이너를 실행하는 핵심 기능.</li><li>Docker Registry : 도커 이미지 공개 및 공유. 도커 허브도 도커 레지스트리를 사용.</li><li>Docker Compose : 여러 컨테이너를 관리하기 위한 툴.</li><li>Docker Machine : 로컬의 VirtualBox 나 퍼블릭 클라우드에 도커 실행 환경을 구축하는 툴.</li><li>Docker Swarm : 여러 도커 호스트를 마스터(<em>Master</em>)와 노드(<em>Node</em>) 구조로 클러스터화하는 툴. 쿠버네티스와 비슷한 기능.</li></ul><h2 id="도커를-이루는-기술">도커를 이루는 기술</h2><p>도커는 리눅스 커널 기술을 기반으로 컨테이너를 구성합니다. 도커를 이루는 기술을 간단하게 살펴보겠습니다.</p><h3 id="namespace">namespace</h3><p>먼저 컨테이너라는 가상의 독립된 환경을 만들기 위해 리눅스 커널의 <a href="https://en.wikipedia.org/wiki/Linux_namespaces">namespace</a> 라는 기능을 사용합니다. 쉽게 얘기하면 리눅스 오브젝트에 이름표를 붙여 같은 이름표가 붙여진 것들만 묶어 관리합니다. 아래 내용에서 격리(<em>isolated</em>)라는 의미는 다른 네임스페이스에서는 접근이 불가능하다는 걸 의미합니다.</p><table><thead><tr><th>네임스페이스</th><th>설명</th></tr></thead><tbody><tr><td>PID namespace</td><td>각 프로세스에 할당된 고유한 ID 인 PID 를 기준으로 다른 프로세스를 격리. <br />네임스페이스가 다르면 액세스 불가.</td></tr><tr><td>Network namespace</td><td>네트워크 리소스(IP 주소, 포트 번호, 라우팅 테이블 등)를 네임스페이스마다 독립적으로 가져감. <br />예를 들어 같은 포트라도 네임스페이스가 다르면 사용 가능.</td></tr><tr><td>UID namespace</td><td>사용자 ID(UID)와 그룹 ID(GID)를 네임스페이스 별로 구분. <br />따라서 컨테이너에서는 루트 권한을 가지고 있더라도 호스트의 관리 권한을 가질 수 없도록 격리 가능.</td></tr><tr><td>MOUNT namespace</td><td>리눅스에서 디바이스를 인식하기 위해 마운트가 필요.<br />파일 시스템 등 마운트된 디바이스를 네임스페이스별로 격리.</td></tr><tr><td>UTS namespace</td><td>호스트명이나 도메인명을 네임스페이스별로 독자적으로 설정 가능.</td></tr><tr><td>IPC namespace</td><td>프로세스 간 통신(<em>inter process communication</em>)에 필요한<br /> <a href="https://en.wikipedia.org/wiki/Shared_memory">공유 메모리</a>(<em>Shared Memory</em>), <a href="https://en.wikipedia.org/wiki/Semaphore_(programming)">세마포어</a>(<em>Semaphore</em>), <a href="https://en.wikipedia.org/wiki/Message_queue#Implementation_in_UNIX">메시지 큐</a>(<em>Message Queue</em>) 등을 독자적으로 사용.</td></tr></tbody></table><h3 id="cgroups">cgroups</h3><p>리눅스에서 프로그램은 프로세스로 실행되고, 프로세스는 하나 이상의 쓰레드로 이루어져 있습니다. <a href="https://ko.wikipedia.org/wiki/Cgroups">cgroups</a>(<em>Control Groups</em>) 는 프로세스와 쓰레드를 그룹화해서 관리하는 기술입니다. 호스트 OS의 자원을 그룹별로 할당하거나 제한을 둘 수 있습니다. 즉 컨테이너에서 사용하는 리소스를 제한함으로써 하나의 컨테이너가 자원을 모두 사용해 다른 컨테이너가 영향을 받지 않도록 할 수 있습니다. 또한 그룹에 계층 구조를 적용할 수 있어 체계적으로 리소스를 관리할 수 있습니다.</p><table><thead><tr><th>항목</th><th>설명</th></tr></thead><tbody><tr><td>cpu</td><td>CPU 사용량 제한.</td></tr><tr><td>cpuacct</td><td>CPU 사용량 통계 정보 제공</td></tr><tr><td>cpuset</td><td>CPU 나 메모리 배치 제어.</td></tr><tr><td>memory</td><td>메모리나 스왑(<em>Swap</em>) 사용량 제한.</td></tr><tr><td>devices</td><td>디바이스에 대한 액세스 제어.</td></tr><tr><td>freezer</td><td>그룹 내 프로세스 정지 및 재개.</td></tr><tr><td>net_cls</td><td>네트워크 제어.</td></tr><tr><td>blkio</td><td>블록 디바이스 입출력량 제어.</td></tr></tbody></table><h3 id="네트워크-구성">네트워크 구성</h3><p>컨테이너의 네트워크 구성을 살펴보겠습니다. 먼저 NIC(<em>Network Interface Controller</em>)는 네트워크 신호를 주고받을 때 쓰는 하드웨어로 랜 카드를 생각하시면 됩니다. 리눅스는 이 네트워크 장치를 <code>/dev/eth0</code>, <code>/dev/eth1</code> 이런 식으로 인식합니다. eth0 은 기본 네트워크 장치라고 볼 수 있습니다.</p><p><img src="https://www.kaitoy.xyz/images/docker_network.jpg" alt="https://www.kaitoy.xyz/2015/07/25/how-to-capture-packets-on-a-local-network-with-pcap4j-container/"></p><p>도커 컨테이너가 실행되면 컨테이너에 172.17.0.0/16 이란 프라이빗 IP 주소가 eth0 으로 자동 할당됩니다. 이를 docker0 이라고 합니다. 이 docker0 은 각 컨테이너 네트워크를 연결해주는 네트워크 브리지(<em>network bridge</em>) 역할을 하는데요, 각 컨테이너의 eth0 에 docker0 이 만든 가상 NIC 인 veth 를 할당합니다. 또한 외부에서 요청을 컨테이너로 라우팅합니다.</p><p><img src="nat-napt.png" alt="http://snowdeer.github.io/common-sense/2018/02/02/understanding-about-nat/"></p><p>컨테이너가 외부 네트워크와 통신할 때는 NAPT(<em>Network Address Port Translation</em>)라는 기술을 사용합니다. 퍼블릭 IP 주소와 프라이빗 IP 주소를 일대일로 변환하는 NAT(<em>Network Address Translation</em>)와 달리 NAPT 는 포트 정보까지 활용하기 때문에 하나의 퍼블릭 IP 주소로 여러 대의 머신을 동시에 연결할 수 있습니다.</p><h3 id="컨테이너-데이터-관리">컨테이너 데이터 관리</h3><p><img src="https://docs.docker.com/storage/images/types-of-mounts.png" alt="https://docs.docker.com/storage/#choose-the-right-type-of-mount"></p><p>도커는 컨테이너에서 사용하는 데이터를 호스트 내에 저장하기 위해 세 가지 방법을 제공합니다.</p><ul><li>Volumes : 호스트의 파일 시스템 내에 특정 영역(리눅스의 경우 <code>/var/lib/docker/volumes/</code>)을 도커가 관리하면서 사용. 도커가 아닌 다른 프로세스에서는 해당 영역 접근이 불가능. 가장 추천하는 방식.</li><li>Bind mounts : 호스트의 파일시스템 자체를 사용. 중요한 시스템 파일이나 디렉토리도 접근 가능. 호스트와 컨테이너가 설정 파일을 공유하거나 호스트에서 개발하고 컨테이너로 배포하는 방식으로 사용.</li><li><code>tmpfs</code> mounts : 호스트의 파일시스템 대신 메모리에 저장하는 방식. 파일 시스템에 저장하고 싶지 않을 경우 사용.</li></ul><p><img src="https://docs.docker.com/storage/storagedriver/images/container-layers.jpg" alt="https://docs.docker.com/storage/storagedriver/"></p><p>도커 이미지는 Dockerfile 로 만들어진 여러 레이어로 이루어져 있고 각 레이어는 읽기만 가능(<em>Read-only</em>)합니다. 이미지를 가지고 새로운 컨테이너를 생성하면 읽고 쓸 수 있는(<em>Readable and Writable</em>) 레이어가 추가되는데 이를 컨테이너 레이어(<em>Container Layer</em>)라고 합니다. 컨테이너를 가지고 작업을 수행할 때 생기는 변경 사항을 모두 컨테이너 레이어에 저장하고 읽을 때는 도커 이미지에 변경된 사항을 조합해서 데이터를 읽습니다. 컨테이너가 삭제되면 컨테이너 레이어도 사라지고 기존 이미지는 변경되지 않고 유지됩니다.</p><p><img src="https://docs.docker.com/storage/storagedriver/images/sharing-layers.jpg" alt="https://docs.docker.com/storage/storagedriver/#container-and-layers"></p><p>따라서 하나의 이미지에서 여러 컨테이너를 만들어서 사용할 수 있습니다. 만약 컨테이너가 서로 데이터를 공유해야 한다면 도커 볼륨에 저장하고 컨테이너에 마운트하면 됩니다.</p><p>도커는 <a href="https://en.wikipedia.org/wiki/Copy-on-write#In_virtual_memory_management">Copy-on-Write</a>(<em>CoW or COW</em>) 방식으로 파일을 관리합니다. Copy-on-Wirte 는 효율적으로 파일을 공유하고 복사하는 방법입니다. 파일 또는 디렉토리를 읽기만 할 땐 기존 파일을 참조하도록 하고, 수정해야 하는 경우에만 파일을 컨테이너 레이어로 복사해서 수정하는 방법입니다. 따라서 꼭 필요한 경우에만 복사가 되므로 데이터 중복이 없고 효율적으로 사용할 수 있습니다.</p><p>도커는 이런 방식으로 레이어와 파일을 관리하기 위해 스토리지 드라이버(<em>Storage Driver</em>)를 사용합니다. 다양한 종류의 스토리지 드라이버를 지원하는데 작동하는 방법이 조금씩 다릅니다. 리눅스 배포판 커널에 따라 다른 드라이버를 사용하게 됩니다. 각 스토리지 드라이버에 대한 자세한 설명은 <a href="https://docs.docker.com/storage/storagedriver/select-storage-driver/">공식 문서</a>를 참고하세요.</p><table><thead><tr><th>리눅스 배포판</th><th>스토리지 드라이버</th></tr></thead><tbody><tr><td>Ubuntu</td><td><code>aufs</code>, <code>devicemapper</code>, <code>overlay2</code> (Ubuntu 14.04.4 or later, 16.04 or later), <br /><code>overlay</code>, <code>zfs</code>, <code>vfs</code></td></tr><tr><td>Debian</td><td><code>aufs</code>, <code>devicemapper</code>, <code>overlay2</code> (Debian Stretch), <code>overlay</code>, <code>vfs</code></td></tr><tr><td>CentOS</td><td><code>devicemapper</code>, <code>vfs</code></td></tr><tr><td>Fedora</td><td><code>devicemapper</code>, <code>overlay2</code> (Fedora 26 or later, experimental),<br /> <code>overlay</code> (experimental), <code>vfs</code></td></tr></tbody></table><h2 id="가상-환경-준비">가상 환경 준비</h2><p>이제 도커를 설치할 차례입니다. 그 전에 먼저 가상 머신(<em>Virtual Machine, VM</em>)을 준비하겠습니다. 도커는 리눅스 외에도 로컬 환경의 Windows 나 macOS 에서 사용할 수 있도록 클라이언트를 제공하고 있습니다. 이 방법이 가장 간단한 방법이라서 많은 책이나 튜토리얼에서 로컬에 클라이언트를 설치해서 진행합니다. 하지만 앞으로 도커를 사용할 때 대부분 리눅스가 설치된 VM 상에서 사용할 것임을 생각해본다면 VM에서 해보는 것이 낫습니다. 뭔가 잘못 돼도 VM 만 지우고 다시 생성하면 되니까 실습하기도 편하구요.</p><p>리눅스가 설치된 VM 을 사용하는 방법은 세 가지 정도가 있을 겁니다.</p><ul><li>VirtualBox 로 VM 생성 후 리눅스 설치</li><li>Vagrant 를 이용해 리눅스가 설치된 Box 이미지로 VM 생성</li><li>퍼블릭 클라우드(<em>AWS, GCP</em>)로 리눅스 VM 인스턴스 생성</li></ul><h3 id="VirtualBox">VirtualBox</h3><p><img src="https://futurecreator.github.io/2018/11/09/it-infrastructure-basics/host-server-virtualization.png" alt="http://www.govmlab.com/news-section-3/"></p><p>첫 번째 방법은 호스트 가상화입니다. 호스트 OS 위에 <a href="https://www.virtualbox.org/">VIrtualBox</a> 같은 가상화 SW를 설치하고 이를 이용해 가상 환경을 구축하는 방식입니다. VirtualBox 설치 후 클릭 몇 번이면 로컬 VM 이 만들어지기 때문에 쉬운 방법으로 개발 환경 구축에 많이 사용합니다. 다만 물리 환경의 호스트 OS 와 가상 환경의 게스트 OS 모두 존재하기 때문에 용량이 크고 느린 단점이 있습니다.</p><p>이 방법으로는 VM 을 만들더라도 OS 나 미들웨어를 직접 설치해야 하는 번거로움이 있습니다. 따라서 이 방법은 패스하고 두 번째 방법으로 넘어가겠습니다.</p><h3 id="Vagrant">Vagrant</h3><p><a href="https://www.vagrantup.com/">Vagrant</a> 는 VM 을 손쉽게 만들고 설정할 수 있는 방법입니다.</p><p><img src="vagrant-boxes.png" alt="https://app.vagrantup.com/boxes/search"></p><p>도커에서 공식 이미지를 지원하는 것처럼 Vagrant 도 여러 VM 이미지를 제공하고 있습니다. 우리는 VM 을 만들고 리눅스를 손수 설치하는 대신 원하는 이미지를 받아서 바로 VM 을 사용할 수 있습니다.</p><p>각종 VM 설정을 Vagrantfile 이라는 설정 파일에 작성하는데요. 이 Vagrantfile 만 있으면 똑같은 VM 환경을 바로 만들어낼 수 있습니다. 따라서 여러 개발자가 똑같은 환경을 구축해서 사용할 수 있게 됩니다. 새로운 개발자가 오면 가이드에 따라 이것저것 설치하고 구성하는 대신에 그냥 Vagrant 를 사용해서 이미 환경 구성이 된 이미지를 받으면 됩니다. 환경 구성 시간을 줄일 수 있어 교육용으로도 적합합니다.</p><p>그럼 실제로 만들어 봅시다!</p><p>먼저 VM 이미지를 실행시킬 <a href="https://www.virtualbox.org/">VirtualBox</a> 를 설치합니다. 다양한 툴을 지원합니다만 기본적인 VirtualBox 로 하겠습니다.</p><p>원하는 경로에 폴더를 만들고 해당 폴더에서 초기화합니다.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ vagrant init</span><br><span class="line">A `Vagrantfile` has been placed <span class="keyword">in</span> this directory. You are now</span><br><span class="line">ready to `vagrant up` your first virtual environment! Please <span class="built_in">read</span></span><br><span class="line">the comments <span class="keyword">in</span> the Vagrantfile as well as documentation on</span><br><span class="line">`vagrantup.com` <span class="keyword">for</span> more information on using Vagrant.</span><br></pre></td></tr></table></figure><p>생성된 Vagrantfile을 수정합니다. 이 포스트에서는 <a href="https://app.vagrantup.com/centos/boxes/7">CentOS 7</a> 로 설치해보려고 합니다. CentOS 7의 버전을 지정해주지 않으면 그냥 최신 버전으로 설치합니다. 내부에서 접속할 수 있는 고정 IP 를 할당하고 나중에 웹 서버를 이용하기 위해 포트를 포워딩해줍니다.</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Vagrant</span>.configure(<span class="string">&quot;2&quot;</span>) <span class="keyword">do</span> |<span class="params">config</span>|</span><br><span class="line">  config.vm.box = <span class="string">&quot;centos/7&quot;</span></span><br><span class="line">  config.vm.network <span class="string">&quot;private_network&quot;</span>, <span class="symbol">ip:</span> <span class="string">&quot;192.168.33.10&quot;</span></span><br><span class="line">  config.vm.network <span class="string">&quot;forwarded_port&quot;</span>, <span class="symbol">guest:</span> <span class="number">80</span>, <span class="symbol">host:</span> <span class="number">8080</span></span><br></pre></td></tr></table></figure><p><code>vagrant up</code> 을 입력하면 박스를 다운로드하고 실행합니다. 이미 다운로드한 박스가 있으면 기존 박스를 사용하게 됩니다.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ vagrant up</span><br><span class="line">Bringing machine <span class="string">&#x27;default&#x27;</span> up with <span class="string">&#x27;virtualbox&#x27;</span> provider...</span><br><span class="line">==&gt; default: Importing base box <span class="string">&#x27;centos/7&#x27;</span>...</span><br><span class="line">==&gt; default: Matching MAC address <span class="keyword">for</span> NAT networking...</span><br><span class="line">==&gt; default: Checking <span class="keyword">if</span> box <span class="string">&#x27;centos/7&#x27;</span> is up to <span class="built_in">date</span>...</span><br><span class="line">==&gt; default: Setting the name of the VM: docker_default_1542286628092_61501</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><code>vagrant ssh</code> 로 VM 에 SSH 접속합니다. 기본적으로 vagrant 계정을 사용하며 <code>sudo -i</code> 로 root 계정에 접속할 수 있습니다.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ vagrant ssh</span><br><span class="line">[vagrant@localhost ~]$ <span class="built_in">pwd</span></span><br><span class="line">/home/vagrant</span><br><span class="line">[vagrant@localhost ~]$ <span class="built_in">sudo</span> -i</span><br><span class="line">[root@localhost ~]#</span><br></pre></td></tr></table></figure><p>설치 과정을 <a href="https://futurecreator.github.io/2018/06/16/record-terminal-asciinema/">asciinema</a> 영상으로 확인하실 수 있습니다. asciinema 는 터미널 녹화 서비스로 영상 내 텍스트를 복사할 수 있습니다.</p><script type="text/javascript" src="https://asciinema.org/a/211919.js" id="asciicast-211919" async></script><p>Windows 에서 PuTTY 와 같은 클라이언트로 접속하고 싶으실 경우엔 해당 vagrant 폴더 안에 <code>.vagrant/machines/default/virtualbox</code> 경로 안에 있는 private_key 파일을 가져다 PuTTYgen 로 <code>.ppk</code> 파일을 생성하신 후에 접속 시 사용하시면 됩니다.</p><p>(추가) Vagrant 는 사용하다보면 <code>vagrant up</code> 이 잘 안되는 경우가 있습니다. <code>vagrant status</code> 를 해보면 제대로 실행이 됐는지 확인해볼 수 있습니다. 제 경우는 macOS 는 큰 문제가 없었고 Windows 7 에서 간간히 발생했는데, 이런 경우엔 <code>vagrant halt</code> 와 <code>vagrant up</code> 을 반복하면 신기하게도 잘 올라갑니다. Vagrant 버전을 업그레이드하는 것도 하나의 방법입니다. 또는 그냥 VirtualBox 에서 VM 을 실행 후 접속하는 것이 가장 잘 됩니다.</p><h3 id="클라우드-VM-인스턴스">클라우드 VM 인스턴스</h3><p>세 번째 방법은 클라우드 서비스를 사용하는 겁니다. 사실 학습 환경은 vagrant 로도 충분하지만 Vagrant 를 이용하는 것이 복잡하거나 로컬 리소스를 사용하길 원하지 않을 수도 있습니다. 또는 간단한 프로젝트를 만들어서 서비스하려면 클라우드를 이용하는 것이 좋겠죠. 그래서 AWS(<em>Amazon Web Service</em>)와 GCP(<em>Google Cloud Platform</em>)를 이용해 VM 인스턴스를 생성 후 도커를 설치해보려고 합니다. 일단 Vagrant 기반으로 진행하고 클라우드 기반은 뒤에서 다시 다루겠습니다.</p><h2 id="도커-설치와-실행">도커 설치와 실행</h2><p>환경도 다 준비되었으니 도커를 설치해보겠습니다.</p><h3 id="도커-에디션과-릴리즈">도커 에디션과 릴리즈</h3><p>도커는 무료로 이용할 수 있는 커뮤니티 에디션과 상용인 엔터프라이즈 에디션이 있습니다. 상용 에디션은 고객 지원 및 보안과 플러그인 등 추가 기능을 제공합니다.</p><ul><li>Docker Community Edition(Docker CE)</li><li>Docker Enterprise Edition(Docker EE)</li></ul><p><img src="https://i0.wp.com/blog.docker.com/wp-content/uploads/lifecycle.png?resize=1024%2C376&amp;ssl=1" alt="https://blog.docker.com/2017/03/docker-enterprise-edition/"></p><p>도커의 버전은 연도 두 자리와 월 두 자리로 구분합니다. 예를 들어 <code>v17.09</code> 는 17년 09월에 나온 버전입니다. CE 는 매달 새로운 기능을 먼저 사용해볼 수 있는 Edge 버전과 분기별로 릴리즈되는 Stable 버전이 있습니다. EE 는 CE 의 Stable 과 같이 릴리즈됩니다.</p><p>우리는 CE 버전으로 진행합니다.</p><h3 id="도커-설치">도커 설치</h3><p>필요한 패키지를 설치합니다.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> yum install -y yum-utils \</span><br><span class="line">  device-mapper-persistent-data \</span><br><span class="line">  lvm2</span><br></pre></td></tr></table></figure><p>도커 리파지토리를 설정합니다.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> yum-config-manager \</span><br><span class="line">  --add-repo \</span><br><span class="line">  https://download.docker.com/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure><p>Edge 버전과 Test 버전은 <code>docker.repo</code> 에 포함되어 있으나 기본적으로 disabled 되어 있습니다. 필요한 경우 enable 해서 사용할 수 있습니다. 여기선 그냥 패스합니다.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> yum-config-manager --<span class="built_in">enable</span> docker-ce-edge</span><br><span class="line">$ <span class="built_in">sudo</span> yum-config-manager --<span class="built_in">enable</span> docker-ce-test</span><br></pre></td></tr></table></figure><p>Docker CE 를 설치합니다. 기본적으로 최신 버전(<em>latest</em>)이 설치됩니다.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> yum install docker-ce</span><br></pre></td></tr></table></figure><p>특정 도커 버전이 필요한 경우는 버전까지 입력합니다. 쿠버네티스 버전에 따라 권장하는 도커 버전이 있어서 이럴 땐 특정 버전을 설치해야 하는 경우가 있습니다.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ yum list docker-ce --showduplicates | <span class="built_in">sort</span> -r <span class="comment"># 가능한 버전 확인</span></span><br><span class="line"><span class="comment"># $ sudo yum install docker-ce-&lt;VERSION STRING&gt;</span></span><br><span class="line">$ <span class="built_in">sudo</span> yum install docker-ce-18.06.1.ce-3.el7.x86_64</span><br></pre></td></tr></table></figure><p>도커를 시작합니다.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> systemctl start docker</span><br></pre></td></tr></table></figure><p>(옵션) 도커 데몬은 root 가 소유한 유닉스 소켓을 사용하므로 일반 사용자는 sudo 가 필요합니다. 학습 과정이므로 root 사용자로 사용해도 상관은 없지만 일반 유저로 진행하고 싶다면 다음 과정을 진행합니다.</p><p><code>docker</code> 그룹을 만듭니다. 아마 이미 만들어져 있을 겁니다.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> groupadd docker</span><br></pre></td></tr></table></figure><p>사용자를 <code>docker</code> 그룹에 추가합니다.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> usermod -aG docker <span class="variable">$USER</span></span><br></pre></td></tr></table></figure><p>로그아웃 후 다시 로그인합니다. 만약 그래도 권한이 없다고 나온다면 다음 명령어로 권한을 부여합니다.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> <span class="built_in">chown</span> <span class="string">&quot;<span class="variable">$USER</span>&quot;</span>:<span class="string">&quot;<span class="variable">$USER</span>&quot;</span> /home/<span class="string">&quot;<span class="variable">$USER</span>&quot;</span>/.docker -R</span><br><span class="line">$ <span class="built_in">sudo</span> <span class="built_in">chmod</span> g+rwx <span class="string">&quot;<span class="variable">$HOME</span>/.docker&quot;</span> -R</span><br></pre></td></tr></table></figure><p>(옵션) 시스템 부팅 시 도커를 시작하도록 설정할 수 있습니다.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> systemctl <span class="built_in">enable</span> docker <span class="comment"># 설정 ON</span></span><br><span class="line">$ <span class="built_in">sudo</span> systemctl <span class="built_in">disable</span> docker <span class="comment"># 설정 OFF</span></span><br></pre></td></tr></table></figure><h3 id="도커-상태-확인">도커 상태 확인</h3><p>다음은 도커의 상태를 확인할 수 있는 몇 가지 명령어입니다.</p><p>도커 버전 확인 : <code>docker version</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ docker version</span><br><span class="line">Client:</span><br><span class="line"> Version:           18.09.0</span><br><span class="line"> API version:       1.39</span><br><span class="line"> Go version:        go1.10.4</span><br><span class="line"> Git commit:        4d60db4</span><br><span class="line"> Built:             Wed Nov  7 00:48:22 2018</span><br><span class="line"> OS/Arch:           linux/amd64</span><br><span class="line"> Experimental:      <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">Server: Docker Engine - Community</span><br><span class="line"> Engine:</span><br><span class="line">  Version:          18.09.0</span><br><span class="line">  API version:      1.39 (minimum version 1.12)</span><br><span class="line">  Go version:       go1.10.4</span><br><span class="line">  Git commit:       4d60db4</span><br><span class="line">  Built:            Wed Nov  7 00:19:08 2018</span><br><span class="line">  OS/Arch:          linux/amd64</span><br><span class="line">  Experimental:     <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>도커 실행 환경 확인 : <code>docker system info</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ docker system info</span><br><span class="line">Containers: 0</span><br><span class="line"> Running: 0</span><br><span class="line"> Paused: 0</span><br><span class="line"> Stopped: 0</span><br><span class="line">Images: 0</span><br><span class="line">Server Version: 18.09.0</span><br><span class="line">Storage Driver: overlay2</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>도커 디스크 상태 확인 : <code>docker system df</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ docker system <span class="built_in">df</span></span><br><span class="line">TYPE                TOTAL               ACTIVE              SIZE                RECLAIMABLE</span><br><span class="line">Images              0                   0                   0B                  0B</span><br><span class="line">Containers          0                   0                   0B                  0B</span><br><span class="line">Local Volumes       0                   0                   0B                  0B</span><br><span class="line">Build Cache         0                   0                   0B                  0B</span><br></pre></td></tr></table></figure><p>여기까지 설치 및 확인 과정을 영상으로도 확인해보세요.</p><script type="text/javascript" src="https://asciinema.org/a/211941.js" id="asciicast-211941" async></script><h2 id="Hello-World">Hello, World!</h2><p>도커를 새로 설치했으니 ‘Hello, World’ 한번 찍어보고 가야겠죠?</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run hello-world</span><br></pre></td></tr></table></figure><p><code>docker run</code> 명령어는 컨테이너를 새로 만들고 실행까지 하는 명령어입니다. 먼저 기존에 다운 받은 <code>hello-world</code> 라는 이미지가 있는지 확인하고 없으면 새로 다운로드합니다. 그리고 컨테이너가 실행되면 다음과 같이 메시지가 출력됩니다.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Hello from Docker!</span><br><span class="line">This message shows that your installation appears to be working correctly.</span><br><span class="line"></span><br><span class="line">To generate this message, Docker took the following steps:</span><br><span class="line"> 1. The Docker client contacted the Docker daemon.</span><br><span class="line"> 2. The Docker daemon pulled the <span class="string">&quot;hello-world&quot;</span> image from the Docker Hub.</span><br><span class="line">    (amd64)</span><br><span class="line"> 3. The Docker daemon created a new container from that image <span class="built_in">which</span> runs the</span><br><span class="line">    executable that produces the output you are currently reading.</span><br><span class="line"> 4. The Docker daemon streamed that output to the Docker client, <span class="built_in">which</span> sent it</span><br><span class="line">    to your terminal.</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>여기까지 과정을 영상으로 확인해보세요.</p><script type="text/javascript" src="https://asciinema.org/a/211943.js" id="asciicast-211943" async></script><h2 id="Nginx-설치-및-실행">Nginx 설치 및 실행</h2><p>이번엔 웹 서버를 설치하고 접속해보겠습니다. 대표적인 웹 서버 중 하나인 <a href="https://www.nginx.com/">Nginx</a> 를 설치합니다. 도커에서 제공하는 공식 이미지를 사용하면 아주 쉽게 설치할 수 있습니다.</p><p>Nginx 이미지를 다운로드합니다.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker pull nginx</span><br></pre></td></tr></table></figure><p>다운로드한 이미지는 <code>docker images</code> 로 확인할 수 있습니다.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker images</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">nginx               latest              62f816a209e6        8 days ago          109MB</span><br><span class="line">hello-world         latest              4ab4c602aa5e        2 months ago        1.84kB</span><br></pre></td></tr></table></figure><p>Nginx 컨테이너를 실행합니다. 하나의 Nginx 서버를 띄운 거라고 볼 수 있습니다.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --name webserver -d -p 80:80 nginx</span><br></pre></td></tr></table></figure><ul><li><code>--name</code> : 컨테이너의 이름을 지정.</li><li><code>-d</code> 옵션 : 컨테이너를 백그라운드에서 실행하고 컨테이너 ID 를 출력.</li><li><code>-p</code> 옵션 : 컨테이너의 특정 포트를 호스트로 오픈. <code>-p &lt;host-port&gt;:&lt;container-port&gt;</code> 형식으로 사용 가능.<br>만약 <code>-p &lt;container-port&gt;</code> 형식으로 쓰면 호스트의 포트는 임의로 할당.</li></ul><p><code>docker run</code> 실행 시 다운로드된 이미지가 없으면 이미지를 받아서 컨테이너를 생성하므로 <code>docker pull</code> 명령어는 생략할 수 있습니다.</p><p>컨테이너 목록에서 확인 : <code>docker ps</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker ps</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                NAMES</span><br><span class="line">a13f196d04ac        nginx               <span class="string">&quot;nginx -g &#x27;daemon of…&quot;</span>   4 seconds ago       Up 2 seconds        0.0.0.0:80-&gt;80/tcp   webserver</span><br></pre></td></tr></table></figure><p>컨테이너 상태 확인 : <code>docker container stats</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker stats webserver</span><br><span class="line">CONTAINER ID        NAME                CPU %               MEM USAGE / LIMIT     MEM %               NET I/O             BLOCK I/O           PIDS</span><br><span class="line">a13f196d04ac        webserver           0.00%               1.359MiB / 487.7MiB   0.28%               648B / 0B           4.86MB / 0B         2</span><br></pre></td></tr></table></figure><p>컨테이너 기동과 종료가 필요한 경우는 <code>docker start</code> 와 <code>docker stop</code> 을 사용합니다.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker start webserver</span><br><span class="line">$ docker stop webserver</span><br></pre></td></tr></table></figure><p>여기까지 과정을 영상으로 확인해보세요.</p><script type="text/javascript" src="https://asciinema.org/a/211944.js" id="asciicast-211944" async></script><p>웹 브라우저에서 접속해보겠습니다. 가상머신의 고정 IP를 192.168.33.10 으로 설정했으므로 <a href="http://192.168.33.10:80">http://192.168.33.10:80</a> 으로 접속합니다. 그러면 다음과 같이 잘 접속되는 걸 볼 수 있습니다.</p><p><img src="welcome-nginx.png" alt="Nginx 초기 화면"></p><h2 id="Dockerfile-로-컨테이너-이미지-만들기">Dockerfile 로 컨테이너 이미지 만들기</h2><p>도커 이미지는 Dockerfile 이라는 설정 파일을 이용해 자동으로 빌드할 수 있습니다. 앞에서 실습한 Nginx 를 이용해서 스태틱 사이트를 만들고 이를 컨테이너 이미지로 만들어보겠습니다.</p><p>도커 이미지는 베이스 이미지(<em>base image</em>)를 기반으로 그 위에 변경 사항을 레이어 형태로 쌓습니다. 그래서 Dockerfile 은 <code>FROM</code> 명령어를 이용해 어떤 베이스 이미지와 버전을 사용할지 선택합니다.</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> nginx:latest</span><br></pre></td></tr></table></figure><p>초기 화면을 지정할 index.html 파일을 만들어줍니다. 그냥 간단하게 헤더만 넣었습니다.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, Docker!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>index.html</code> 파일을 컨테이너로 복사하기 위해 <code>COPY</code> 명령어를 추가합니다.</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">COPY</span><span class="language-bash"> index.html /usr/share/nginx/html/index.html</span></span><br></pre></td></tr></table></figure><p>80 포트로 접속할 수 있도록 하기 위해 <code>EXPOSE</code> 명령어를 추가합니다.</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPOSE</span> <span class="number">80</span></span><br></pre></td></tr></table></figure><p><code>EXPOSE 80 443</code> 또는 <code>EXPOSE 3000-4000</code> 처럼 여러 포트를 지정할 수도 있습니다.</p><p><code>CMD</code> 명령어로 실제로 실행할 명령어를 지정할 수 있습니다. Nginx 가 데몬화(<em>daemonize</em>)되어 백그라운드(<em>background</em>)에서 동작하면 컨테이너 기동 시 그냥 종료되기 때문에 포그라운드(<em>foreground</em>)에서 동작할 수 있도록 명령어를 줍니다.</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;nginx&quot;</span>, <span class="string">&quot;-g&quot;</span>, <span class="string">&quot;daemon off;&quot;</span>]</span></span><br></pre></td></tr></table></figure><p><code>CMD</code> 명령어와 비슷한 기능으로는 <code>RUN</code> 명령어가 있습니다.</p><ul><li><code>RUN</code> : 해당 명령어를 이미지가 빌드할 때 실행. e.g. <code>RUN npm install</code></li><li><code>CMD</code> : 해당 명령어를 컨테이너를 기동될 때 실행. e.g. <code>CMD [&quot;nginx&quot;, &quot;-g&quot;, &quot;daemon off;&quot;]</code><br>주로 도커 이미지로 빌드된 애플리케이션을 실행할 때 사용되거나 <code>RUN</code> 명령어로 오버라이딩(<em>overriding</em>)할 수 있어 디폴트 명령어를 지정할 때 쓰이기도 함.</li></ul><p>작성한 Dockerfile 은 다음과 같습니다.</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> nginx:latest</span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> index.html /usr/share/nginx/html/index.html</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">80</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;nginx&quot;</span>, <span class="string">&quot;-g&quot;</span>, <span class="string">&quot;daemon off;&quot;</span>]</span></span><br></pre></td></tr></table></figure><p>현재 폴더 상황은 다음과 같습니다.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./</span><br><span class="line">|- Dockerfile</span><br><span class="line">|- index.html</span><br></pre></td></tr></table></figure><p><code>docker build</code> 명령어를 이용해 이미지를 빌드합니다. 태그를 이용해 이미지의 이름과 버전을 줄 수 있습니다.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker build -t my-nginx-image:latest .</span><br></pre></td></tr></table></figure><p><code>docker images</code> 로 빌드된 이미지를 확인할 수 있습니다.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ docker images</span><br><span class="line">docker images</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">my-nginx-image      latest              ba3effefd2bc        3 seconds ago       54.3MB</span><br><span class="line">nginx               latest              62f816a209e6        8 days ago          109MB</span><br><span class="line">hello-world         latest              4ab4c602aa5e        2 months ago        1.84kB</span><br></pre></td></tr></table></figure><p>도커 이미지를 가지고 컨테이너를 실행합니다.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker stop webserver <span class="comment"># 위에서 실습한 서버 종료</span></span><br><span class="line">$ docker run -d -p 80:80 my-nginx-image:latest</span><br></pre></td></tr></table></figure><p><code>docker ps</code> 로 상태도 확인해봅니다.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker ps</span><br><span class="line">CONTAINER ID        IMAGE                   COMMAND                  CREATED             STATUS              PORTS                         NAMES</span><br><span class="line">14735a3f9e39        my-nginx-image:latest   <span class="string">&quot;nginx -g &#x27;daemon of…&quot;</span>   2 seconds ago       Up 2 seconds        0.0.0.0:80-&gt;80/tcp, 443/tcp   gifted_kilby</span><br></pre></td></tr></table></figure><p><a href="http://192.168.33.10">http://192.168.33.10</a> 으로 접속 확인도 해봅니다.</p><p><img src="hello-docker.png" alt="방금 만든 스태틱 사이트"></p><p>여기까지 과정을 영상으로 확인해보세요.</p><script type="text/javascript" src="https://asciinema.org/a/211945.js" id="asciicast-211945" async></script><p>여기선 간단한 명령어 위주로 살펴봤지만 Dockerfile 을 이용해 다양한 작업을 할 수 있습니다.</p><h2 id="도커와-클라우드">도커와 클라우드</h2><p>이번엔 위에서 말씀드린대로 클라우드 환경에서 VM 인스턴스를 생성하고 도커를 설치해보겠습니다. 먼저 AWS, 그 다음 GCP 를 살펴봅니다.</p><h3 id="AWS-EC2">AWS EC2</h3><p><a href="https://aws.amazon.com/ko/ec2/">AWS EC2</a>(<em>Amazon Elastic Compute Cloud</em>)는 AWS에서 제공하는 컴퓨팅 파워입니다. AWS 아이디를 새로 만들면 <a href="https://aws.amazon.com/ko/free/">프리 티어</a>(무료)로 사용해보실 수 있습니다. 제공되는 서비스에 따라 1년간 무료인 서비스와 상시 무료인 서비스가 나뉘어져 있으니 세부 사항은 홈페이지를 참고하시면 됩니다. EC2 는 1년 동안 t2.micro 인스턴스가 매달 750시간 무료입니다. 성능을 더 높이거나 시간을 넘어가는 경우에는 비용을 지불해야 합니다.</p><p><img src="select-ami.png" alt="AMI 이미지 선택하기"></p><p>EC2 는 AMI(<em>Amazon Machine Image</em>)라는 이미지를 기반으로 VM 을 생성합니다. 다양한 서버 종류와 버전이 있는데요, 저는 프리티어 지원 AMI 중 ‘Red Hat Enterprise Linux 7.5’를 선택했습니다.</p><p><img src="select-ami.png" alt="인스턴스 유형 선택하기"></p><p>용도와 성능에 따라서 인스턴스 유형을 선택할 수 있습니다. 프리 티어 사용 가능 버전인 t2.micro 를 선택합니다. 다른 세부 설정도 가능하지만 ‘검토 및 시작’을 합니다.</p><p><img src="key-pair.png" alt="키 페어 생성"></p><p>인스턴스가 실행되는 동안 해당 인스턴스에 접속할 수 있는 키 페어 파일이 선택합니다. 키 페어를 새로 생성하면 퍼블릭 키(<em>public key</em>)는 AWS 서버에 저장되고 프라이빗 키(<em>private key</em>) 파일은 사용자의 PC 에 저장합니다. 이 프라이빗 키 파일(<em>pem</em> 파일)을 이용해 인스턴스에 SSH 로 접속합니다. 기존에 사용하던 키 페어가 있으면 그대로 사용 가능합니다.</p><p><img src="connect-instance.png" alt="인스턴스 연결"></p><p>친절하게도 가이드에 나오는 명령어를 그대로 사용하면 SSH 연결이 가능합니다. 설치 과정은 로컬 VM에서 사용한 것과 동일합니다.</p><h3 id="GCP-Compute-Engine">GCP Compute Engine</h3><p>Compute Engine 은 GCP 에서 제공하는 컴퓨팅 파워입니다. GCP 는 원하는 제품을 사용해 볼 수 있도록 $300의 크레딧을 제공하고 특정 조건에 따라 <a href="https://cloud.google.com/free/">무료 서비스</a>를 제공합니다.</p><p><img src="gcp-create-vm.png" alt="새 VM 인스턴스"></p><p>프로젝트를 만들고 VM 인스턴스를 새로 생성합니다. 저는 캡쳐와 같이 설정했습니다. GCP 의 경우 VM 생성 시 간단하게 컨테이너 이미지를 배포할 수 있는 기능을 제공합니다. 컨테이너 이미지란에는 마켓플레이스의 컨테이너 이미지에서 Nginx 의 주소( <code>marketplace.gcr.io/google/nginx1:latest</code>)를 가져와서 적어줍니다.</p><p>부팅 디스크는 <a href="https://cloud.google.com/container-optimized-os/">Container-Optimized OS</a> 를 선택할 수 있습니다. 이 컨테이너 최적화 OS는 도커 컨테이너 런타임과 모든 쿠버네티스 구성 요소가 설치되어 있으므로 필요한 컨테이너를 바로 배포할 수 있습니다. 그렇다면 이 OS 는 뭘 기반으로 하고 있을까요? 컨테이너 최적화 OS 는 오픈 소스인 Chromium OS 를 기반으로 하고 있습니다.</p><p><img src="gcp-vm-ssh.png" alt="인스턴스 SSH 접속"></p><p>인스턴스 생성 완료 후 인스턴스 세부 정보에서 SSH 연결을 누르면 새로운 창이 뜨고 바로 접속이 됩니다. 도커는 이미 설치되어 있습니다. 연결도 그렇고 세세한 설정도 그렇고 AWS 보다 간편하네요.</p><p><code>docker images</code> 를 입력하면 설정해서 내려 받은 Nginx 이미지를 확인할 수 있습니다.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ docker images</span><br><span class="line">REPOSITORY                                            TAG                 IMAGE ID            CREATED             S</span><br><span class="line">IZE</span><br><span class="line">marketplace.gcr.io/google/nginx1                      latest              1c9b94f006da        10 days ago         2</span><br><span class="line">17MB</span><br><span class="line">gcr.io/gce-containers/konlet                          v.0.9-latest        da64965a2b28        5 weeks ago         7</span><br><span class="line">3.4MB</span><br><span class="line">gcr.io/stackdriver-agents/stackdriver-logging-agent   0.2-1.5.33-1-1      fcfafd404600        4 months ago        5</span><br><span class="line">48MB</span><br></pre></td></tr></table></figure><h2 id="도커-컨테이너-라이프-사이클">도커 컨테이너 라이프 사이클</h2><p><img src="container-lifecycle.png" alt="http://docker-saigon.github.io/post/Docker-Internals/"></p><p>마지막으로 도커 컨테이너의 라이프 사이클을 살펴보겠습니다. 컨테이너는 도커 명령어에 따라 상태가 변화합니다. 위 그림을 클릭하면 확대해서 볼 수 있습니다.</p><table><thead><tr><th>상태</th><th>명령</th><th>설명</th></tr></thead><tbody><tr><td>생성</td><td><code>docker create</code></td><td>생성만 되고 시작은 아님.</td></tr><tr><td>생성 및 시작</td><td><code>docker run</code></td><td>생성하고 시작.</td></tr><tr><td>시작</td><td><code>docker start</code></td><td>재시작은 <code>docker container restart</code>.</td></tr><tr><td>정지</td><td><code>docker stop</code></td><td>실행 중인 컨테이너를 정지.</td></tr><tr><td>삭제</td><td><code>docker rm</code></td><td>컨테이너를 삭제.</td></tr></tbody></table><h2 id="참고">참고</h2><ul><li><a href="https://kyobobook.co.kr/product/detailViewKor.laf?mallGb=KOR&amp;ejkGb=KOR&amp;barcode=9788956747903">완벽한 IT 인프라 구축을 위한 Docker</a></li><li><a href="http://docker-saigon.github.io/post/Docker-Internals/">Docker Internals</a></li><li><a href="https://blog.docker.com/2016/12/understanding-docker-networking-drivers-use-cases/">Understanding docker networking drivers and their use cases | Docker blog</a></li><li><a href="https://docs.docker.com/storage/">Manage data in Docker | Docker docs</a></li></ul><h2 id="Related-Posts">Related Posts</h2><ul><li><a href="/2018/11/09/it-infrastructure-basics/" title="개발자를 위한 인프라 기초 총정리">개발자를 위한 인프라 기초 총정리</a></li><li><a href="/2018/10/25/google-cloud-summit-seoul-2018/" title="구글 클라우드 서밋 서울 2018 후기">구글 클라우드 서밋 서울 2018 후기</a></li><li><a href="/2019/01/19/spring-boot-containerization-and-ci-cd-to-kubernetes-cluster/" title="스프링 부트 컨테이너와 CI&#x2F;CD 환경 구성하기">스프링 부트 컨테이너와 CI&#x2F;CD 환경 구성하기</a></li><li><a href="/2019/02/25/kubernetes-cluster-on-google-compute-engine-for-developers/" title="개발자를 위한 쿠버네티스(Kubernetes) 클러스터 구성하기(Kubeadm, GCE, CentOS)">개발자를 위한 쿠버네티스(Kubernetes) 클러스터 구성하기(Kubeadm, GCE, CentOS)</a></li></ul><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://futurecreator.github.io/2018/10/19/microservices-deployment-strategy/">마이크로서비스 배포 전략</a><a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://hub.docker.com/explore/">Explore Official Repositories | Docker Hub</a><a href="#fnref:2" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;p&gt;이전 &lt;a href=&quot;https://futurecreator.gith</summary>
      
    
    
    
    <category term="Cloud" scheme="https://futurecreator.github.io/categories/Cloud/"/>
    
    
    <category term="aws" scheme="https://futurecreator.github.io/tags/aws/"/>
    
    <category term="basics" scheme="https://futurecreator.github.io/tags/basics/"/>
    
    <category term="container" scheme="https://futurecreator.github.io/tags/container/"/>
    
    <category term="docker" scheme="https://futurecreator.github.io/tags/docker/"/>
    
    <category term="cloud" scheme="https://futurecreator.github.io/tags/cloud/"/>
    
    <category term="gcp" scheme="https://futurecreator.github.io/tags/gcp/"/>
    
  </entry>
  
  <entry>
    <title>최고의 프로그래밍 폰트는?</title>
    <link href="https://futurecreator.github.io/2018/11/12/my-best-programming-font-top-3/"/>
    <id>https://futurecreator.github.io/2018/11/12/my-best-programming-font-top-3/</id>
    <published>2018-11-12T14:29:09.000Z</published>
    <updated>2025-03-14T16:10:24.238Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>하루 종일 화면을 들여다보며 키보드를 두드리는 개발자에게 빠질 수 없는 것 중 하나가 <strong>프로그래밍 폰트</strong>(개발용 폰트)입니다. 프로그래밍 폰트는 각 문자의 폭이 일정한 <a href="https://en.wikipedia.org/wiki/Monospaced_font">고정폭 글꼴</a>(<em>Monospaced font</em>)을 기반으로 헷갈릴 여지가 있는 글자를 없애도록 설계된 폰트입니다. 아래 그림은 일반 굴림체와 프로그래밍 폰트인 Consolas, D2 Coding 폰트를 비교한 표인데요. 굴림체와 달리 프로그래밍 폰트는 숫자 <code>1</code>, 영어 소문자 <code>l</code>, 한글 <code>ㅣ</code>, 특수기호 <code>|</code> 를 구분할 수 있도록 만든 것을 볼 수 있습니다. 숫자 <code>0</code>, 영어 대문자 <code>O</code>, 한글 <code>ㅇ</code> 도 마찬가지입니다. 마침표와 쉼표도 헷갈리기 쉬운 문자 중 하나인데 프로그래밍 폰트는 좀 더 확실하게 차이점을 보여주고 있습니다. 표에는 없지만 <code>Z</code>와 <code>2</code>, <code>S</code>와 <code>5</code>, <code>G</code>와 <code>6</code> 등도 헷갈리기 쉬운 문자입니다.</p><p><img src="https://cloud.githubusercontent.com/assets/6773678/19587983/8d1a2304-979d-11e6-8320-4e8f0546e716.JPG" alt="https://github.com/naver/d2codingfont"></p><p>코드를 작성할 때는 글자, 숫자 하나에 결과가 크게 달라질 수 있고 오타 에러가 발생하면 디버깅하기 힘들기 때문에 대부분의 개발자가 프로그래밍 폰트를 사용합니다. 이번 포스트에서는 제가 좋아하는 프로그래밍 폰트를 (주관적인 순위와 함께) 가볍게 소개해드리려고 합니다.</p><h2 id="프로그래밍-폰트와-개발자의-취향">프로그래밍 폰트와 개발자의 취향</h2><p>프로그래밍 폰트는 생산성 향상에 필수이면서도 개발자 취향을 많이 탑니다.</p><p>주변 개발자들에게 물어보면 이클립스의 기본 폰트인 <a href="https://en.wikipedia.org/wiki/Consolas">Consolas</a> 를 쓰는 사람이 제일 많았습니다. Consolas 는 Microsoft 에서 개발해 Windows 에 기본 내장되어 있는 폰트입니다. Consolas 는 한글이 표현되지 않다보니 한글도 잘 표현해주는 <a href="https://github.com/naver/d2codingfont">D2 Coding</a> 을 쓰는 사람도 많았습니다. 사실 프로그래밍 폰트는 다양하지만 언뜻 보면 비슷비슷해 보이는 것이 사실이라 굳이 새로운 폰트를 사용할 필요를 못느낄 수도 있습니다.</p><p><img src="consolas.png" alt="Consolas"></p><p>반대로 글씨체를 중요하게 생각하는 개발자도 있습니다. 저도 폰트를 꽤 자주 바꾸는 편입니다. 맨날 보는 화면이라도 테마나 폰트를 바꾸면 기분전환도 되고 집중도 더 잘 되더라구요. 사실 프로그래밍 폰트 외에 각종 에디터, 웹 브라우저도 수시로 폰트를 바꿔가며 사용합니다.</p><h2 id="나만의-프로그래밍-폰트-순위-TOP-3">나만의 프로그래밍 폰트 순위 TOP 3</h2><p>제가 프로그래밍 폰트를 고르는 기준은 얼마나 ‘눈에 잘 들어오는지‘ 입니다.  지금까지 사용해 본 폰트 중에서 제 마음에 든 폰트는 다음과 같습니다.</p><h3 id="IBM-Plex-Mono">IBM Plex Mono</h3><p><img src="ibm-plex-mono.png" alt="IBM Plex Mono"></p><p>1위는 제 최애 폰트인 <a href="https://www.ibm.com/plex/">IBM Plex Mono</a> 입니다. 이름에서 알 수 있듯이 IBM 에서 만든 폰트로 IBM Plex 폰트 중 모노스페이스 폰트입니다. 돋움체(<em>Sans-Serif</em>) 같은 느낌의 폰트 중에서도 단연 눈에 띄는 시원시원한 바탕체(<em>Serif</em>) 스타일의 폰트입니다. 특히 한껏 꺾인 중괄호(Brace, <code>&#123;&#125;</code>)가 매력 포인트입니다. 현재 이 블로그에서 코드를 표현할 때 사용하는 폰트이기도 합니다.</p><h3 id="Hack">Hack</h3><p><img src="hack.png" alt="Hack"></p><p>2위는 <a href="https://sourcefoundry.org/hack/">Hack</a> 입니다. Hack 은 Source Foundry 에서 만든 오픈 소스 폰트로 <a href="https://www.gnome.org/fonts/">Bitstream Vera</a> 와 <a href="http://dejavu-fonts.org/wiki/Main_Page">DejaVu</a> 폰트를 기반으로 만들어졌습니다. 전체적으로 부드럽고 둥글둥글하며 각 글자의 너비가 적당해서 가독성이 높아서 선호합니다. IBM Plex Mono 를 사용하기 전까지 주로 사용한 폰트입니다.</p><h3 id="Source-Code-Pro">Source Code Pro</h3><p><img src="source-code-pro.png" alt="Source Code Pro"></p><p>3위는 <a href="https://github.com/adobe-fonts/source-code-pro">Source Code Pro</a> 입니다. Adobe 에서 만든 오픈 소스 폰트인데요. 너비가 넓고 글자 사이의 간격이 넓어 답답하지 않고 눈에 잘 들어옵니다. 한 때 많이 사용했지만 다른 폰트에 비해 화면에 들어오는 코드가 적기 때문에 불편할 때가 종종 있습니다.</p><h3 id="번외-D2-Coding">(번외) D2 Coding</h3><p><img src="d2-coding.png" alt="D2 Coding"></p><p><a href="https://github.com/naver/d2codingfont">D2 Coding</a> 은 네이버에서 나눔바른고딕을 기반으로 만든 프로그래밍 폰트입니다. 영문자 뿐만 아니라 한글과도 조화롭고 비슷한 글자도 확실하게 구분한 폰트입니다. 그래서 한글 주석이 많거나 fallback 폰트로 사용합니다. 외국 폰트의 경우 한글을 지원하지 않는 경우가 많아 fallback 폰트로 지정해놓으면 한글만 D2 Coding 으로 나오게 됩니다. 사실 한글을 지원하는 프로그래밍 폰트 자체가 많지 않기 때문에 선택지가 (거의) 없습니다. 그래서 Consolas 에 맑은 고딕을 추가해서 사용하는 분들도 있다고 하네요.</p><h2 id="이-외에-인기-있는-폰트">이 외에 인기 있는 폰트</h2><p>좀 더 알아볼까요? 저는 잘 사용하지 않지만 개발자들이 주로 사용하는 폰트는 다음과 같습니다. 한 번 쭉 보시고 마음에 드는 폰트가 있으면 써보셔도 좋을 것 같습니다. 저는 Anonymous Pro 와 Red Hat 에서 만든 Liberation Mono 에 눈이 가네요.</p><h3 id="Fira-Code"><a href="https://github.com/tonsky/FiraCode">Fira Code</a></h3><p><img src="fira-code.png" alt="Fira Code"></p><h3 id="DejaVu-Sans-Mono"><a href="https://dejavu-fonts.github.io/">DejaVu Sans Mono</a></h3><p><img src="dejavu.png" alt="DejaVu Sans Mono"></p><h3 id="Inconsolata-g"><a href="https://en.wikipedia.org/wiki/Inconsolata">Inconsolata-g</a></h3><p><img src="inconsolata-g.png" alt="Inconsolata-g"></p><h3 id="Ubuntu-Mono-by-Ubuntu"><a href="https://design.ubuntu.com/font/">Ubuntu Mono</a> by Ubuntu</h3><p><img src="ubuntu-mono.png" alt="Ubuntu Mono"></p><h3 id="Anonymous-Pro"><a href="https://www.marksimonson.com/fonts/view/anonymous-pro">Anonymous Pro</a></h3><p><img src="anonymous-pro.png" alt="Anonymous Pro"></p><h3 id="M"><a href="https://mplus-fonts.osdn.jp/about-en.html">M+</a></h3><p><img src="m-plus.png" alt="M+"></p><h3 id="PT-Mono"><a href="https://www.fontsquirrel.com/fonts/pt-mono">PT Mono</a></h3><p><img src="pt-mono.png" alt="PT Mono"></p><h3 id="Liberation-Mono-by-Red-Hat"><a href="https://www.fontsquirrel.com/fonts/liberation-mono">Liberation Mono</a> by Red Hat</h3><p><img src="liberation-mono.png" alt="Liberation Mono"></p><h3 id="Iosevka"><a href="http://typeof.net/Iosevka/">Iosevka</a></h3><p><img src="iosevka.png" alt="Iosevka"></p><h3 id="Menlo-by-Apple"><a href="https://en.wikipedia.org/wiki/Menlo_(typeface)">Menlo</a> by Apple</h3><p><img src="menlo.png" alt="Menlo"></p><h3 id="Monaco-by-Apple"><a href="https://en.wikipedia.org/wiki/Monaco_(typeface)">Monaco</a> by Apple</h3><p><img src="monaco.png" alt="Monaco"></p><h3 id="Meslo-LG"><a href="https://github.com/andreberg/Meslo-Font">Meslo LG</a></h3><p><img src="meslo-lg.png" alt="Meslo LG"></p><p>Meslo LG 는 Apple 의 Menlo 를 커스터마이징한 폰트입니다.</p><h2 id="당신의-폰트는-무엇인가요">당신의 폰트는 무엇인가요?</h2><p>여러분이 좋아하는 프로그래밍 폰트는 무엇인가요? 댓글에 남겨주시면 리스트에 추가하도록 하겠습니다. 감사합니다!</p><h2 id="Related-Posts">Related Posts</h2><ul><li><a href="/2018/06/14/variety-of-markdown-and-Implementations/" title="마크다운의 종류와 선택">마크다운의 종류와 선택</a></li><li><a href="/2018/07/07/hexo-change-font-face-no-cdn/" title="일반 폰트를 웹에 적용하기">일반 폰트를 웹에 적용하기</a></li><li><a href="/2018/06/10/medium-writing-paradigm-shift/" title="Medium, 글쓰기의 새로운 패러다임">Medium, 글쓰기의 새로운 패러다임</a></li><li><a href="/2018/06/05/metasyntactic-variables-foo-bar/" title="foo, bar 의 어원을 찾아서">foo, bar 의 어원을 찾아서</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;p&gt;하루 종일 화면을 들여다보며 키보드를 두드리는 개발자에게 빠질 수 없</summary>
      
    
    
    
    <category term="Programming" scheme="https://futurecreator.github.io/categories/Programming/"/>
    
    <category term="Column" scheme="https://futurecreator.github.io/categories/Programming/Column/"/>
    
    
    <category term="font" scheme="https://futurecreator.github.io/tags/font/"/>
    
    <category term="programming_font" scheme="https://futurecreator.github.io/tags/programming-font/"/>
    
    <category term="consolas" scheme="https://futurecreator.github.io/tags/consolas/"/>
    
    <category term="monospaced" scheme="https://futurecreator.github.io/tags/monospaced/"/>
    
  </entry>
  
  <entry>
    <title>개발자를 위한 인프라 기초 총정리</title>
    <link href="https://futurecreator.github.io/2018/11/09/it-infrastructure-basics/"/>
    <id>https://futurecreator.github.io/2018/11/09/it-infrastructure-basics/</id>
    <published>2018-11-08T15:36:39.000Z</published>
    <updated>2025-03-14T16:10:24.228Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>최근 클라우드 관련 부서로 옮겨 클라우드 관련 업무를 맡게 되었습니다. 그동안 개발은 했어도 인프라 지식은 많지 않은 상황에서 업무를 하다보니 어려운 부분이 있어 인프라 기초를 정리해봅니다.</p><h2 id="IT-Infrastructure">IT Infrastructure</h2><p>IT 인프라란 애플리케이션을 가동시키기 위해 필요한 하드웨어나 OS, 미들웨어, 네트워크 등 시스템의 기반을 말합니다. 시스템의 요구사항이라고 하면 먼저 해당 시스템이 어떤 기능을 하는지, 무엇을 할 수 있는지를 생각하게 됩니다. 이를 기능적인 요구사항(<em>functional requirement</em>)이라고 합니다. 이외에 시스템의 성능, 안정성, 확장성, 보안 등과 같은 요구사항을 비기능적인 요구사항(<em>non-functional requirement</em>)라고 합니다. 인프라는 이런 비기능적인 요구사항과 관련이 있습니다.</p><h2 id="개발자가-왜-인프라를-알아야-할까">개발자가 왜 인프라를 알아야 할까?</h2><p>예전에는 애플리케이션 개발은 업무 지식 그리고 프로그래밍과 테스트 스킬을 갖춘 애플리케이션 엔지니어가 담당하고 환경 구축은 네트워크나 하드웨어를 잘 아는 인프라 엔지니어가 담당했습니다. 그런데 데이터센터나 서버실에 서버를 두고 직접 관리하던 온프레미스(<em>On-premise</em>) 방식에서 가상의 서버를 여러 대 띄우는 클라우드 방식으로 옮기게 되었습니다.</p><p>이런 분산 환경에서는 인프라 엔지니어가 수동으로 관리하는 대신 자동화된 툴을 사용해서 오케스트레이션(<em>orchestration</em>)합니다. 따라서 인프라 엔지니어도 자동화를 위해 코드를 작성하는 능력이 필요하게 되었습니다. 또한 애플리케이션 엔지니어도 지금까지 인프라 엔지니어의 업무였던 환경에 대한 배포나 테스트 등을 직접 할 수 있게 되면서 인프라 관련 기초 지식이 필요하게 되었습니다.</p><h2 id="인프라-구성-요소">인프라 구성 요소</h2><p>인프라를 이루는 구성 요소들은 다음과 같습니다.</p><ul><li>하드웨어(<em>Hardware, HW</em>): 서버 장비 본체나 데이터를 저장하기 위한 스토리지, 전원 장치 등입니다. 넓은 의미에서는 이런 하드웨어를 설치하는 데이터 센터의 설비(건물, 공조, 보안 설비, 소화 설비 등)도 포함됩니다.</li><li>네트워크(<em>Network</em>) : 사용자가 원격으로 접근할 수 있도록 서버를 연결하는 도구들입니다. 라우터, 스위치, 방화벽 등 네트워크 장비와 이를 연결하는 케이블 배선 등이 있습니다. 사용자가 단말에서 무선으로 연결할 때 필요한 액세스 포인트(<em>Access Point, AP</em>)도 있습니다.</li><li>운영체제(<em>Operating System, OS</em>) : 하드웨어와 네트워크 장비를 제어하기 위한 기본적인 소프트웨어입니다. 리소스나 프로세스를 관리합니다.<ul><li>클라이언트 OS : 사용자가 사용하기 쉽도록 하는데 초점을 맞추고 있습니다(<em>Windows, macOS</em> 등).</li><li>서버 OS : 시스템을 빠르고 안정적으로 실행하는데 초점을 맞추고 있습니다(<em>Linux, Unix, Windows Server</em> 등).</li></ul></li><li>미들웨어(<em>middleware</em>) : 서버 상에서 서버가 특정 역할을 하도록 기능을 제공하는 소프트웨어입니다.</li></ul><h2 id="온프레미스와-클라우드">온프레미스와 클라우드</h2><h3 id="온프레미스-On-premises">온프레미스 On-premises</h3><p>온프레미스는 데이터 센터나 서버실에 서버를 두고 직접 관리하는 방식입니다. 전통적이고 지금도 널리 사용되는 방식이죠. 집에 개인적으로 NAS나 서브 PC로 작은 서버를 돌리는 분들도 있는데 이런 것도 온프레미스라고 볼 수 있습니다. 이런 환경에서는 서버, 네트워크 장비, OS, 스토리지, 각종 솔루션 등을 직접 사서 설치하고 관리해야 했습니다. 물론 직접 관리하는 것의 장점도 있습니다. 하지만 이런 장비들은 상당히 고가이기 때문에 초기 투자 비용이 크고 이후 사용 예측량을 가늠하기가 힘들며 한번 구축해놓으면 사용량이 적어도 유지 비용은 그대로 나간다는 단점이 있습니다.</p><h3 id="퍼블릭-클라우드-Public-Cloud">퍼블릭 클라우드 Public Cloud</h3><p>인터넷을 통해 불특정 다수에게 서비스 형태로 제공되는 시스템입니다. AWS(<em>Amazon Web Service</em>), Microsoft Azure, GCP(<em>Google Cloud Platform</em>) 등 클라우드 프로바이더가(제공자)가 데이터 센터와 인프라를 보유하고 있습니다. 서비스 형태라는 건 사용자는 원하는 옵션을 선택하고 사용한만큼 비용을 지불하면 된다는 걸 말합니다. 제공하는 서비스에 따라 IaaS, PaaS, SaaS 등으로 나눌 수 있습니다. 이 중 IaaS는 원하는 사양의 가상 머신이나 스토리지를 선택하고 이용한 시간이나 데이터 양에 따라 비용을 지불합니다.</p><h3 id="프라이빗-클라우드-Private-Cloud">프라이빗 클라우드 Private Cloud</h3><p>퍼블릭 클라우드에서 이용자를 한정한 형태입니다. 예를 들면 기업 내 서비스와 같은 것으로 보안이 좋고 독자적인 기능이나 서비스를 추가하기 쉽습니다.</p><h3 id="클라우드가-유리한-경우">클라우드가 유리한 경우</h3><p>회사 직원용 시스템(근태 관리, 회계, 인사 등)은 사용자가 한정되어 있고 트래픽을 예측하기가 쉬워 온프레미스도 큰 문제가 없습니다. 하지만 대외 서비스의 경우 트래픽을 예상하기가 쉽지 않습니다. 이렇게 트래픽 양에 따라 서버 사양이나 네트워크 대역을 가늠하는 것을 사이징(<em>sizing</em>)이라고 하는데 상당히 어려운 작업입니다. 크게 잡으면 낭비가 되고 적게 잡으면 단기간에 증설하기가 어렵기 때문입니다. 이렇게 트래픽의 변동이 많은 시스템은 클라우드 시스템이 유리합니다. 클라우드 시스템에서는 트래픽에 따라 자동으로 증설해주는 오토스케일링(<em>Auto Scaling</em>)이 있어 유리합니다.</p><p><img src="https://cloud.google.com/images/locations/regions.png" alt="https://cloud.google.com/about/locations/#regions-tab"></p><p>또한 클라우드의 데이터센터는 전 세계에 퍼져 있기 때문에 자연 재해로 인해 데이터 시스템이 다운되더라도 다른 곳에서 시스템을 계속 운영할 수 있습니다. 그리고 빨리 서비스를 제공해야 하는 시스템이나 PoC(<em>Proof of Concept</em>)도 클라우드가 용이하며 초기 투자금이 적은 스타트업이나 개인 개발자도 클라우드가 유리합니다.</p><h3 id="온프레미스가-유리한-경우">온프레미스가 유리한 경우</h3><p>하지만 항상 클라우드가 좋은 것은 아닙니다. 무조건 클라우드가 좋으니까 옮기자!가 아니라 상황에 온프레미스가 맞는 경우도 있으니 제대로 검토해야 합니다.</p><p>온프레미스와 클라우드는 모두 가용성을 보장합니다만 개념에서 차이가 있습니다. 온프레미스는 서버가 죽지 않는 것을 목표로 합니다. 반면 클라우드는 많은 인스턴스로 이루어진 분산 환경에서  인스턴스가 죽으면 다른 인스턴스가 빠르게 대체하는 것을 의미합니다. 즉 그냥 클라우드를 사용한다고 해서 가용성이 보장되는 것이 아니라, 가용성을 높이도록 직접 설계해야 합니다. 따라서 잠시라도 끊어져서는 안되는 시스템이나 클라우드 업체가 보장하는 것 이상의 가용성이 필요한 시스템에서는 온프레미스가 유리합니다.</p><p>또한 기밀성이 높은 데이터의 경우에도 온프레미스가 유리합니다. 물론 자사의 보안보다 클라우드 프로바이더가 제공하는 보안이 더 좋을 수 있습니다만 물리적인 저장 장소를 명확히 알 필요가 있을 때는 온프레미스가 유리합니다. 또한 멀티 클라우드를 사용한다면 각 클라우드 프로바이더마다 보안 정책이 다르기 때문에 보안 표준을 구축하기 어렵습니다.</p><p>이 외에도 특정 유료 솔루션을 사용하는 경우나 클라우드가 지원하지 않는 특수한 플랫폼을 사용하는 경우에는 클라우드를 이용할 수가 없습니다.</p><h3 id="하이브리드-클라우드-Hybrid-Cloud">하이브리드 클라우드 Hybrid Cloud</h3><p><img src="https://cloud.google.com/images/solutions/manage-hybrid-cloud/diagrams/analytics-hybrid.svg" alt="https://cloud.google.com/solutions/manage-hybrid-cloud/"></p><p>각자 장단점이 있기 때문에 온프레미스와 클라우드를 함께 사용하기도 합니다. 각 시스템의 특성에 맞게 온프레미스와 클라우드를 함께 사용하는 것입니다. 또한 클라우드 프로바이더들도 각자의 장점이 달라서 여러 클라우드를 함께 사용하기도 합니다. 이를 결정할 때는 특성을 잘 파악하고 있어야 하며 선택의 기준이 명확해야 합니다.</p><h2 id="하드웨어">하드웨어</h2><p>인프라에서 가장 low-level 을 맡고 있는 것이 하드웨어와 네트워크입니다. 온프레미스 시스템은 여러 대의 서버 장비로 구성됩니다. 클라우드에서는 인스턴스의 하드웨어 성능을 필요에 따라 선택하게 됩니다.</p><h3 id="CPU">CPU</h3><p>CPU의 성능은 코어와 캐시에 영향을 받습니다. 코어가 많을수록 동시에 처리하는 연산이 늘어나고 메모리와의 처리 속도를 완화하기 위한 캐시는 크기가 클수록 성능이 좋습니다. 특히 GPU(<em>Graphics Processing Unit</em>)는 그래픽을 처리하는데 특화된 프로세서인데요. CPU가 직렬 처리에 최적화된 몇 개의 코어로 구성된 반면, GPU는 병렬 처리에 최적화된 작고 많은 코어로 이루어져 있습니다.</p><p><img src="https://kr.nvidia.com/content/tesla/images/cpu-and-gpu.jpg" alt="https://kr.nvidia.com/object/what-is-gpu-computing-kr.html"></p><p>따라서 딥러닝이나 수치해석 등 대량의 데이터를 고속으로 처리해야하는 분야에서는 CPU와 GPU를 함께 사용해서 처리 성능을 높이는 GPU 컴퓨팅 방식이 사용됩니다. 이 방식은 연산이 많이 필요한 부분을 GPU에게 넘기고 나머지 코드만을 CPU에서 처리하는 방식입니다.</p><p><img src="https://kr.nvidia.com/docs/IO/123756/how-gpu-acceleration-works.png" alt="https://kr.nvidia.com/object/what-is-gpu-computing-kr.html"></p><h3 id="메모리">메모리</h3><p>주기억장치인 메모리는 데이터 용량이 크거나 전송 속도가 고속일수록 고성능입니다. 서버용으로는 전력 소모가 적고 오류 처리가 탑재되어 있는 것을 주로 선정합니다.</p><h3 id="데이터-스토리지">데이터 스토리지</h3><p>데이터를 저장하는 디바이스입니다. 보통 스토리지의 속도가 제일 느리기 때문에 스토리지의 용량이나 읽기, 쓰기 속도가 시스템 전체의 속도에 영향을 주는 경우가 많습니다. 하드디스크나 SSD 등으로 이루어져 있습니다.</p><p>IT에서 가장 중요한 것은 데이터라고 할 수 있는데요. 이런 데이터가 손실되면 안되기 때문에 대부분 고가용성(<em>High Availability, HA</em>, 오랜 기간 동안 지속적으로 운영될 수 있음)을 위해 이중화(<em>redundancy</em>) 또는 다중화로 구성합니다. 이중화란 같은 장비 또는 시스템이 장애가 나는 것을 대비해 같은 모듈을 2개(또는 그 이상) 준비하는 것을 말합니다.</p><p>아래 그림은 AWS의 RDS를 같은 리전 내 다른 가용 영역에 분산해서 이중화를 구성한 모습입니다. AWS에서는 이를 다중 AZ배포라고 하는데요. 같은 지역이라도 데이터가 나뉘어져 있어서 Master에서 문제가 생기면 Slave에서 이를 복구해서 데이터를 유지합니다.</p><p><img src="https://docs.aws.amazon.com/ko_kr/AmazonRDS/latest/UserGuide/images/con-multi-AZ.png" alt="https://docs.aws.amazon.com/ko_kr/AmazonRDS/latest/UserGuide/Concepts.MultiAZ.html"></p><p>이런 가동률은 퍼센트로 나타내는데 예를 들어 파이브나인스(99.999%)처럼 표시합니다. 소수점 한 자리를 늘릴 때마다 서버 장비 사양이 달라집니다.</p><h3 id="기타-하드웨어">기타 하드웨어</h3><p>이 외에도 전원 차단을 방지하는 무정전 전원공급장치(<em>Uninterruptible Power Supply, UPS</em>)나 여러 대의 서버를 관리하기 위한 KVM 스위치, 서버 장비 설치에 사용하는 서버 랙 등이 있습니다. 서버 랙은 19인치 랙이 많이 사용됩니다.</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/2/29/Chassis-Plans-Rack.jpg/220px-Chassis-Plans-Rack.jpg" alt="https://en.wikipedia.org/wiki/19-inch_rack"></p><p>이러한 하드웨어는 다양한 스펙의 라인업이 있으므로 용도에 따라 선택해서 구축하게 됩니다. 클라우드를 사용하는 경우도 마찬가지로 용도에 따라 가상 머신의 성능을 선택해서 사용할 수 있습니다. 클라우드는 다양한 서비스를 제공하고 있기 때문에 여러 서비스를 조합해서 사용하는 능력이 필요한데요, 클라우드 업체에게 컨설팅을 받는 것도 좋은 방법입니다.</p><h3 id="방화벽">방화벽</h3><p>방화벽은 보안을 위해 내부 네트워크와 외부 네트워크의 통신을 제어하고 불필요한 통신을 차단하는 것입니다.</p><ul><li>패킷 필터형 : 통과하는 패킷을 포트 번호나 IP 주소를 바탕으로 필터링합니다.</li><li>애플리케이션 게이트웨이형 : 애플리케이션 프로토콜 레벨에서 외부와의 통신을 제어하는 방식으로 일반적으로 프록시 서버라고 부릅니다. 세션에 포함되어 있는 정보를 검사하기 위해서 기존 세션을 종료하고 새로운 세션을 만듭니다. 패킷 필터형에 비해서 속도는 느리지만 많은 검사를 수행할 수 있습니다.</li></ul><h2 id="네트워크">네트워크</h2><h3 id="네트워크-주소">네트워크 주소</h3><p>네트워크에서는 각종 장비를 식별하기 위해 네트워크 주소(<em>address</em>)를 사용합니다.</p><h4 id="MAC-주소-물리-주소-이더넷-주소">MAC 주소(물리 주소/이더넷 주소)</h4><p>물리적으로 할당되는 48bit 주소입니다. 앞 24bit 는 네트워크 부품의 제조업체를 식별하고 뒤 24bit는 각 제조업체가 중복되지 않도록 할당합니다. 16진수로 표기하며 2byte씩 구분해서 표기합니다.</p><h4 id="IP-주소">IP 주소</h4><p>인터넷이나 인트라넷 같은 네트워크에 연결된 장비에 할당되는 번호입니다. 주로 많이 사용하는 IPv4의 경우 8bit씩 4개로 구분된 32bit 주소입니다(예를 들어 192.168.1.1). 각 자리는 0~255까지 표현이 가능합니다. IPv4는 하나의 네트워크에 2의 32승(약 42억대)까지밖에 연결할 수가 없어서 인터넷에서 IP 주소가 고갈될 우려가 있습니다. 그래서 IPv6는 128비트의 IP주소를 사용하고 있습니다. 또한 사내 네트워크에서는 임의의 주소를 할당하는 프라이빗 주소를 사용하고 인터넷과의 경계에서 글로벌 주소로 변환하는 NAT 장비를 사용합니다.</p><h3 id="OSI-모델">OSI 모델</h3><p>통신을 할 때에는 서로 어떻게 메시지를 주고 받고 어떤 언어를 사용할지 등 규칙이 필요합니다. 이런 규약을 통신 프로토콜이라고 합니다.</p><p>OSI 모델(<em>Open Systems Interconnection Model</em>)은 국제 표준화 기구(<em>International Organization for Standardization, IOS</em>)에서 만든 컴퓨터의 통신 기능을 계층 구조로 나눈 모델입니다. 이를 이용하면 특정 네트워킹 시스템에서 일어나는 일을 계층을 활용해 시각적으로 이해할 수 있습니다. 총 7계층으로 이루어져 있습니다. 데이터가 네트워크로 나갈 때는 위층에서부터, 네트워크에서 데이터를 받을 때는 아래층에서부터 들어옵니다. 그림에서 오른쪽은 인터넷에서 사용하는 TCP/IP 계층 모델입니다.</p><p><img src="https://www.stemjar.com/wp-content/uploads/2017/12/OSI-vs-TCP-IP-model-What-is-the-difference-1280x640.jpg" alt="https://www.stemjar.com/osi-vs-tcp-ip-model/"></p><h4 id="1-물리-계층-Physical-Layer">1. 물리 계층(<em>Physical Layer</em>)</h4><p>전송 케이블이 직접 연결되는 계층으로 케이블을 통해 전송하는 기능을 합니다. 전압과 전류의 값을 할당하거나 케이블이나 커넥터의 모양 등 통신 장비의 물리적 전기적 특성을 규정합니다. 예를 들어 LAN 케이블로 사용되는 트웨스트 페어 케이블(STP/UTP)이나 이더넷(Ethernet) 규격인 100BASE-T 또는 IEEE802.11 시리즈의 무선 통신 등이 있습니다.</p><h4 id="2-데이터-링크-계층-Data-Link-Layer">2. 데이터 링크 계층(<em>Data Link Layer</em>)</h4><p>동일한 네트워크 간 인접한 두 시스템(노드) 간 통신을 규정합니다. 물리 계층이 데이터를 보내고 받고 하는 기능을 한다면 데이터 링크 게층은 물리 게층이 잘 동작하고 있는지 확인하는 역할입니다. 네트워크 계층에서 데이터 패킷을 받아들여 MAC 주소와 각종 제어 정보를 추가합니다. 이 때 추가적인 정보를 가지고 있는 데이터 단위를 프레임(<em>frame</em>)이라 하고 물리 계층을 통해 전송됩니다.</p><p><img src="https://images.samsung.com/is/image/samsung/p5/sec/business/network/products/switch/img_iES4028G_Featured.jpg?$ORIGIN_JPG$" alt="https://www.samsung.com/sec/business/network/switch/iES4028G/"></p><p>이 레이어에서 동작하는 L2 스위치라는 장비는 통신하고 싶은 노드가 어떤 포트와 연결되어 있는지를 MAC 주소로 판단하고 패킷을 전송하는 장비입니다.</p><h4 id="3-네트워크-계층-Network-Layer">3. 네트워크 계층(<em>Network Layer</em>)</h4><p>서로 다른 네트워크 간 통신을 위한 규정입니다. 특정 서버로 가는 경로를 효율적으로 처리하는 라우팅(<em>routing</em>) 기능이 있습니다. 데이터 링크 계층이 MAC 주소를 기반으로 한다면 네트워크 계층은 IP 주소를 기반으로 합니다.</p><p>데이터 계층이 노드 간 전달을 담당하는 반면 네트워크 계층은 송신지에서 최종 수신지까지 데이터를 안전하게 전달하는 것을 담당합니다. 이를 위해 패킷의 이동량이 많을 때는 패킷의 흐름을 제어하는 흐름제어(<em>flow control</em>) 기능과 전송 중 분실되는 패킷을 감지하고 재전송을 요구하는 오류 제어 기능을 가지고 있습니다.</p><p><img src="https://www.home-network-help.com/images/routing-table.jpg" alt="https://www.home-network-help.com/routing-table.html"></p><p>대표적인 장비로는 라우터나 L3 스위치가 있습니다. 이런 장비는 패킷을 어디에서 어디로 전송할지에 대한 정보를 저장하는 라우팅 테이블(<em>routing table</em>)을 관리합니다. 이 테이블을 기반으로 루트를 정하는 정적 라우트(<em>Static Route</em>)와 라우팅 프로토콜에서 설정된 동적 라우트(<em>Dynamic Route</em>)가 있습니다. L3 스위치는 라우터와 동일한 기능을 하드웨어로 처리하는 장비입니다.</p><h4 id="4-전송-계층-Transport-Layer">4. 전송 계층(<em>Transport Layer</em>)</h4><p>데이터 전송을 제어하는 계층입니다. 보낼 데이터의 용량, 속도, 목적지 등을 처리합니다. 세션 계층에서 보낸 메시지를 세그먼트로 나누고 각 세그먼트의 순서 번호를 기록해서 네트워크 계층으로 보내면 받는 쪽에서는 이를 다시 조립합니다. 이런 방식으로 전송 오류의 검출이나 재전송을 규정합니다. 대표적인 프로토콜로는 TCP와 UDP가 있습니다.</p><h4 id="5-세션-계층-Session-Layer">5. 세션 계층(<em>Session Layer</em>)</h4><p>애플리케이션 간 연결을 유지 및 해제하는 역할을 합니다. 커넥션 확립 타이밍이나 데이터 전송 타이밍 등을 규정합니다.</p><h4 id="6-프레젠테이션-계층-Presentation-Layer">6. 프레젠테이션 계층(<em>Presentation Layer</em>)</h4><p>데이터를 애플리케이션이 이해할 수 있도록 변환해주는 역할을 합니다. 데이터의 저장 형식, 압축, 문자 인코딩 등을 변환하고 데이터를 안전하게 전송하기 위해 암호화, 복호화하는 기능도 이 계층에서 처리합니다.</p><h4 id="7-응용-계층-Application-Layer">7. 응용 계층(<em>Application Layer</em>)</h4><p>최상위 계층으로 웹 브라우저나 아웃룩처럼 사용자가 직접 사용하는 애플리케이션을 의미합니다.</p><h2 id="리눅스-Linux">리눅스 Linux</h2><p>하드웨어와 네트워크를 알아봤으니 이제 운영체제에 대해 알아봅시다.</p><p>리눅스는 Linus Torvalds 가 개발한 Unix 호환 서버 OS입니다. 리눅스 재단에 따르면 퍼블릭 클라우드 워크로드의 90%, 세계 스마트폰의 82%, 임베디드 기기의 62%, 슈퍼컴퓨터 시장의 99%가 리눅스로 동작한다고 합니다. 다만 리눅스는 서버와 모바일 운영체제로는 많이 쓰이지만 애초에 데스크탑 운영체제로 시작했음에도 데스크톱에서는 많이 쓰이지 않는 편입니다.</p><p>리눅스는 오픈소스로 여러 기업이나 개인의 참여로 만들어지고 있습니다. 컴퓨터 역사상 가장 많은 인력이 들어간 오픈 소스 프로젝트라고 합니다. 아래 그림은 Linux Torvalds 가 구글 그룹스에 처음으로 리눅스를 소개하는 글입니다.</p><p><img src="linux.JPG" alt="리눅스의 시작"></p><h3 id="리눅스-커널-Linux-Kernel">리눅스 커널 Linux Kernel</h3><p>커널이란 OS의 코어가 되는 부분을 말합니다. 메모리 관리, 파일 시스템, 프로세스 관리, 디바이스 제어의 역할을 합니다. 안드로이드(<em>Android</em>) 또한 리눅스 커널을 기반으로 만들어졌습니다.</p><h4 id="디바이스-관리">디바이스 관리</h4><p>리눅스 커널은 CPU, 메모리, 디스크, IO 등 하드웨어를 디바이스 드라이버라는 소프트웨어를 이용해 제어합니다.</p><h4 id="프로세스-관리">프로세스 관리</h4><p>리눅스는 프로그램 파일에 쓰여 있는 내용을 읽어서 메모리 상에서 처리하는데 이렇게 실행된 프로그램을 프로세스라고 합니다. 이 프로세스를 식별하기 위해 PID(<em>Process ID</em>)를 붙여서 관리하고 각 프로세스에 필요한 자원을 효율적으로 할당합니다.</p><h4 id="메모리-관리">메모리 관리</h4><p>프로세스에 필요한 메모리를 할당하고 해제합니다. 다만 메모리가 부족한 경우에는 하드디스크와 같은 보조기억장치에 가상 메모리 영역을 만들어 사용하는데 이를 스왑(<em>swap</em>)이라고 합니다.</p><h4 id="쉘-Shell">쉘 Shell</h4><p>사용자는 쉘이라는 커맨드라인 인터페이스를 통해 명령어를 커널로 전달할 수 있습니다. 또한 쉘에서 실행하고자 하는 명령을 모아놓은 것을 쉘 스크립트(<em>shell script</em>)라고 합니다.</p><p>쉘에도 몇 가지 종류가 있습니다. 사용하는 쉘에 따라서 스크립트 작성이 달라질 수 있습니다.</p><table><thead><tr><th>이름</th><th>특징</th></tr></thead><tbody><tr><td>bash</td><td>명령 이력, 디렉토리 스택, 명령이나 파일명의 자동 완성 기능 등을 지원하는 쉘. <br />대부분의 Linux 시스템이나 macOS(OS X)에 표준으로 탑재되어 있다.</td></tr><tr><td>csh</td><td>C 언어와 비슷한 쉘. BSD 계열 OS에서 주로 사용한다.</td></tr><tr><td>tcsh</td><td>csh 를 개선한 버전으로 명령이나 파일명 등의 자동완성 기능 지원.</td></tr><tr><td>zsh</td><td>bash 와 호환성이 있고 고속으로 동작하는 쉘.</td></tr></tbody></table><h4 id="파일-시스템">파일 시스템</h4><p>파일 시스템이란 파일에 이름을 붙여서 어디에 저장할지 나타내는 체계입니다. 즉 파일을 관리하는 시스템입니다. 리눅스 커널은 가상 파일 시스템(<em>Virtual File System, VFS</em>)을 사용합니다. 사용자의 입장에서 각 데이터가 저장되어 있는 위치(하드디스크, 메모리, 네트워크 스토리지 등)와 상관없이 그냥 파일처럼 사용할 수 있도록 하는 것입니다. VFS에서는 각 디바이스를 파일로 취급합니다.</p><p><img src="https://i.stack.imgur.com/N8zbe.png" alt="https://unix.stackexchange.com/questions/437285/is-the-virtual-file-system-vfs-a-program-or-is-it-just-an-interface"></p><table><thead><tr><th>이름</th><th>설명</th></tr></thead><tbody><tr><td>ext2</td><td>리눅스 운영체제에서 널리 이용되던 파일 시스템. 초기 ext 파일 시스템을 확장했기 때문에 ext2로 불림.</td></tr><tr><td>ext3</td><td>리눅스에서 주로 사용되는 파일 시스템. 리눅스 커널 2.4.16부터 사용 가능.</td></tr><tr><td>ext4</td><td>ext3의 후속 파일 시스템. 스토리지는 1EiB까지 지원. <br />파일의 단편화를 방지하는 extent file writing을 지원.</td></tr><tr><td>tmpfs</td><td>Unix 계열 OS 에서 임시 파일을 위한 장치. 메모리상에 저장 가능. <br /><code>/tmp</code> 로 마운트되는 경우가 많으며 메모리 상에 저장되어 있어 서버를 재시작하면 파일은 모두 사라짐.</td></tr><tr><td>UnionFS</td><td>여러 개의 디렉토리를 겹쳐서 하나의 디렉토리로 취급할 수 있는 파일 시스템.</td></tr><tr><td>NFS</td><td>Unix 에서 이용하는 분산 파일 시스템 및 프로토콜.</td></tr></tbody></table><h4 id="디렉토리-구성">디렉토리 구성</h4><p>리눅스의 디렉토리 목록은 FHS(<em>Filesystem Hierarchy Standard</em>)라는 규격으로 표준화되어 있습니다. 대부분의 주요 배포판은 이 FHS를 기반으로 디렉토리를 구성합니다.</p><table><thead><tr><th>디렉토리</th><th>설명</th></tr></thead><tbody><tr><td><code>/</code></td><td>루트 디렉토리</td></tr><tr><td><code>/bin</code></td><td><code>ls</code>, <code>cp</code> 같은 기본 커맨드를 저장하는 디렉토리.</td></tr><tr><td><code>/boot</code></td><td>리눅스 커널(<em>vmlinuz</em>) 등 OS 시작에 필요한 파일을 저장하는디렉토리.</td></tr><tr><td><code>/dev</code></td><td>하드디스크, 키보드, 디바이스 파일을 저장하는 디렉토리.</td></tr><tr><td><code>/etc</code></td><td>OS 나 애플리케이션의 설정 파일을 저장하는 디렉토리.</td></tr><tr><td><code>/home</code></td><td>일반 사용자의 홈 디렉토리. root 사용자는 <code>/root</code> 를 홈 디렉토리로 사용.</td></tr><tr><td><code>/proc</code></td><td>커널이나 프로세스에 대한 정보가 저장하는 디렉토리.<br /><code>/proc</code> 하위에 있는 숫자 폴더는 프로세스 ID를 의미.</td></tr><tr><td><code>/sbin</code></td><td>시스템 관리용 마운트를 저장하는 디렉토리.</td></tr><tr><td><code>/tmp</code></td><td>일시적으로 사용하는 파일을 저장하는 임시 디렉토리. 서버를 재시작하면 사라짐.</td></tr><tr><td><code>/usr</code></td><td>각종 프로그램이나 커널 소스를 저장하는 디렉토리</td></tr><tr><td><code>/var</code></td><td>시스템 기동과 함께 변하는 파일을 저장하는 디렉토리.</td></tr></tbody></table><h4 id="보안-기능">보안 기능</h4><p>보안은 범위가 넓어서 대표적인 보안 기능만 살펴보겠습니다.</p><h5 id="계정에-대한-권한-설정">계정에 대한 권한 설정</h5><p>리눅스는 사용자 계정에 권한을 설정할 수 있습니다. 시스템 전체를 관리하는 root 사용자와 그 외 일반 사용자가 있습니다. 또한 미들웨어와 같은 데몬을 작동시키기 위한 시스템 계정도 있습니다. 계정은 그룹으로 묶을 수도 있습니다. 이런 계정과 그룹을 바탕으로 파일이나 디렉토리에 대한 액세스 권한(<em>permission</em>)을 설정할 수 있습니다.</p><h5 id="네트워크-필터링">네트워크 필터링</h5><p>리눅스는 원래 네트워크 상에서 여러 사용자가 이용하는 것을 전제로 만든 OS 이므로 네트워크 관련 기능이 많습니다. iptables는 리눅스에 내장된 패킷 필터링 및 NAT를 설정할 수 있는 기능입니다.</p><h5 id="SELinux-Security-Enhanced-Linux">SELinux(Security-Enhanced Linux)</h5><p>SELinux는 미국 국가안전보장국이 제공하는 리눅스 커널에 강제 액세스 제어 기능을 추가한 기능입니다. 리눅스는 root 사용자가 퍼미션에 상관없이 모든 액세스가 가능해서 root 계정이 도난당하면 시스템에 치명적인 영향을 줄 수 있는 단점이 있는데요. SELinux는 프로세스마다 액세스 제한을 거는 TE(<em>Type Enforcement</em>)와 root 를 포함한 모든 사용자에게 제어를 거는 RBAC(<em>Role-based Access Control</em>) 등으로 root 에게 권한이 집중되는 것을 막아줍니다.</p><h3 id="리눅스-배포판-Linux-Distribution">리눅스 배포판 Linux Distribution</h3><p>보통 리눅스는 커널 위에 각종 커맨드, 라이브러리, 애플리케이션 등을 포함해 배포판이라는 패키지 형태로 배포됩니다. 굉장히 다양한 배포판이 있는데요. 그도 그럴것이 사람마다 원하는 프로그램이 다르고 오픈소스라서 개인 또는 기업이 직접 수정해서 사용할 수 있기 때문입니다.</p><table><thead><tr><th></th><th>배포판</th><th style="text-align:left">설명</th></tr></thead><tbody><tr><td>Debian 계열</td><td><a href="https://www.debian.org/index.ko.html">Debian</a></td><td style="text-align:left">GNU/LInux 커뮤니티에서 개발한 리눅스</td></tr><tr><td></td><td><a href="http://www.knoppix.org/">KNOPPIX</a></td><td style="text-align:left">CD 부팅으로 이용할 수 있는 리눅스</td></tr><tr><td></td><td><a href="https://www.ubuntu.com/">Ubuntu</a></td><td style="text-align:left">풍부한 데스크톱 환경을 제공하는 리눅스</td></tr><tr><td>Red Hat 계열</td><td><a href="https://getfedora.org/ko/workstation/">Fedora</a></td><td style="text-align:left">Red Hat 이 지원하는 커뮤니티 Fedora Project 의 리눅스</td></tr><tr><td></td><td><a href="https://www.redhat.com/ko/technologies/linux-platforms/enterprise-linux">Red Hat Enterprise Linux</a></td><td style="text-align:left">Red Hat이 제공하는 상용 리눅스. RHEL.</td></tr><tr><td></td><td><a href="https://www.centos.org/">CentOS</a></td><td style="text-align:left">RHEL 과 완전한 호환을 지향하는 리눅스</td></tr><tr><td></td><td><a href="https://www.vinelinux.org/">Vine Linux</a></td><td style="text-align:left">일본에서 개발된 리눅스</td></tr><tr><td>Slackware 계열</td><td><a href="https://www.opensuse.org/">openSUSE</a></td><td style="text-align:left">Novell 이 지원하는 커뮤니티에서 개발된 리눅스</td></tr><tr><td></td><td><a href="https://www.suse.com/products/server/">SUSE Linux Enterprise</a></td><td style="text-align:left">openSUSE 를 기반으로 한 안정화된 상용 리눅스</td></tr><tr><td>기타 배포판</td><td><a href="https://www.archlinux.org/">Arch Linux</a></td><td style="text-align:left">패키지 관리 시스템에 Pacman 을 사용하는 리눅스</td></tr><tr><td></td><td><a href="https://www.gentoo.org/">Gentoo Linux</a></td><td style="text-align:left">Portage 라는 패키지 관리 시스템을 사용하는 리눅스</td></tr></tbody></table><p>리눅스 배포판과 관련해 더 다양한 정보가 궁금하시다면 <a href="https://upload.wikimedia.org/wikipedia/commons/1/1b/Linux_Distribution_Timeline.svg">GNU/Linux Distributions Timeline</a> 를 참고하세요. 각 배포판을 타임라인으로 정리해놓은 자료입니다.</p><h2 id="미들웨어-Middleware">미들웨어 Middleware</h2><p>미들웨어는 OS와 비즈니스를 처리하는 애플리케이션 사이에 들어가는 각종 소프트웨어를 말합니다. 웹 서버, DBMS, 시스템 모니터링 툴 등이 있습니다. 오픈 소스부터 상용 솔루션까지 다양하므로 꼼꼼히 검토 후 필요한 요건에 따라 선정해야 합니다.</p><h3 id="웹-서버-Web-Server">웹 서버 Web Server</h3><p>웹 서버는 클라이언트가 보낸 HTTP 요청을 받아 웹 콘텐츠를 응답으로 반환하거나 서버쪽 애플리케이션을 호출하는 기능을 가진 서버입니다.</p><table><thead><tr><th>이름</th><th>설명</th></tr></thead><tbody><tr><td><a href="https://httpd.apache.org/">Apache HTTP Server</a></td><td>폭 넓게 사용되는 전통의 오픈소스 웹 서버.</td></tr><tr><td><a href="https://www.iis.net/">Internet Information Services</a></td><td>Microsoft에서 제공하는 웹 서버. <br />Windows Server 시리즈와 같은 OS 제품에 들어 있음.</td></tr><tr><td><a href="https://www.nginx.com/">Nginx</a></td><td>소비 메모리가 적으며 리버스 프록시와 로드밸런서 기능을 갖추고 있는 오픈 소스 웹 서버.</td></tr></tbody></table><h3 id="DBMS">DBMS</h3><p>데이터 베이스 관리 시스템(<em>Database Management System, DBMS</em>)은 데이터베이스를 관리하는 미들웨어입니다. 데이터의 CRUD(<em>Create, Read, Update, Delete</em>)와 같은 기본 기능과 트랜잭션 처리 등 많은 기능을 포함합니다.</p><p>다양한 종류의 DBMS 가 있는데요. ANSI SQL 이라는 표준이 있으나 벤더마다 구문이 상당히 다릅니다. 또한 DBMS 마다 지원하는 기능과 성능, 가격이 천차만별이므로 필요한 용도에 따라 선택하게 됩니다.</p><table><thead><tr><th>이름</th><th>설명</th></tr></thead><tbody><tr><td><a href="https://www.oracle.com/kr/database/index.html">Oracle Database</a></td><td>Oracle 이 제공하는 상용 RDBMS. 주로 기업에서 많이 사용되는 데이터베이스로 글로벌 DB시장 점유율 1위. 상당히 고가인만큼 많은 기능을 제공.</td></tr><tr><td><a href="https://www.mysql.com/">MySQL</a></td><td>Oracle 이 제공하는 오픈 소스 관계형(<em>Releational</em>) DBMS. 가장 많이 사용되는 오픈 소스 RDBMS로 MySQL AB라는 제작사를 썬이 인수하고 이후 오라클이 썬을 인수하면서 오라클이 소유주가 됭. 무료인 커뮤니티 버전과 유료인 상용 버전으로 나뉘어져 있음. 이후 오픈 소스 진영에서 MySQL을 기반으로 한 MariaDB를 만들었음.</td></tr><tr><td><a href="https://www.microsoft.com/ko-kr/sql-server/">Microsoft SQL Server</a></td><td>Microsoft 에서 제공하는 상용 RDBMS. Windows 에 특화되어 있음.</td></tr><tr><td><a href="https://www.postgresql.org/">PostgreSQL</a></td><td>Oracle, MySQL, SQL Server 에 이어 글로벌 점유율 4위인 오픈 소스 RDBMS.</td></tr></tbody></table><p>위 표에는 RDBMS 만 정리해놨지만 NoSQL(<em>Not Only SQL</em>)도 많이 사용됩니다. NoSQL은 SQL만을 사용하지 않는 DBMS 를 말하는데요. 데이터를 저장할 때 테이블 대신 다른 형태로 저장하는 방식입니다. RDB와 비교해서 어느 것이 더 좋다기 보다 용도에 맞게 사용하는 것이 중요합니다.</p><table><thead><tr><th>형태</th><th>설명</th><th>종류</th></tr></thead><tbody><tr><td>Key-value</td><td>단순한 형태의 NoSQL. 간단해서 속도가 빠르고 익히기 쉬움.<br />값의 내용을 사용한 쿼리가 불가능해서 애플리케이션 레벨에서 처리가 필요.</td><td><a href="https://redis.io/">Redis</a><br /><a href="https://aws.amazon.com/ko/dynamodb/">Amazon DynamoDB</a><br /><a href="https://memcached.org/">Memcached</a></td></tr><tr><td>Document</td><td>Key-Value 와 비슷하나 단순한 Value가 아닌 계층구조인 도큐먼트로 저장됨.<br />쿼리를 사용할 순 있으나 일반 SQL 과는 다름.</td><td><a href="https://www.mongodb.com/">MongoDB</a><br /><a href="https://www.couchbase.com/">Couchbase</a></td></tr><tr><td>Wide column stores</td><td>테이블, 로우, 컬럼을 사용하지만 RDB 와는 달리 컬럼의 이름과 포맷은 같은 로우라도 다를 수 있다. 2차원 Key-Value 형태.</td><td><a href="http://cassandra.apache.org/">Cassandra</a><br /><a href="https://hbase.apache.org/">HBase</a></td></tr><tr><td>Graph</td><td>데이터를 그래프처럼 연속적인 노드, 엣지, 프로퍼티의 형태로 저장. <br />SNS 나 추천 엔진, 패턴 인식 등 데이터 간의 관계를 위주로할 때 적합.</td><td><a href="https://neo4j.com/">Neo4j</a></td></tr></tbody></table><p>DBMS 의 글로벌 점유율과 다양한 모델을 <a href="https://db-engines.com/en/ranking_trend">DB-Engines</a> 에서 확인할 수 있습니다.</p><p><img src="db-engines-ranking.png" alt="https://db-engines.com/en/ranking_trend"></p><h3 id="시스템-모니터링-System-Monitoring">시스템 모니터링 System Monitoring</h3><p>시스템 운영을 위해서는 여러 상태를 지속적으로 감시해야 합니다. 네트워크, 서버, 클라우드, 애플리케이션, 서비스, 트랜잭션 등 다양한 레벨에서 모니터링을 하면서 이상 여부를 확인하고 원인을 분석합니다.</p><table><thead><tr><th>이름</th><th>설명</th></tr></thead><tbody><tr><td><a href="https://www.zabbix.com/">Zabbix</a></td><td>Zabbix SIA 가 개발한 오픈 소스 모니터링 툴. 다양한 서버의 상태를 모니터링 가능</td></tr><tr><td><a href="https://www.datadoghq.com/">Datadog</a></td><td>Datadog 가 개발한 서버 모니터링 SaaS. 따로 서버를 도입할 필요 없이 웹 브라우저에서 모니터링 가능. 멀티 클라우드 환경에서도 손쉽게 모니터링이 가능.</td></tr><tr><td><a href="https://mackerel.io/">Mackerel</a></td><td>Hatena 가 개발한 서버 모니터링 SaaS. 클라우드 서버 모니터링에 유용.</td></tr></tbody></table><h2 id="인프라-구성-관리">인프라 구성 관리</h2><p>인프라 구성 관리란 인프라를 구성하는 하드웨어, 네트워크, OS, 미들웨어, 애플리케이션 등의 구성 정보를 관리하고 적절한 상태로 유지하는 작업을 의미합니다. Docker 를 이해하는데 필요한 몇 가지 개념을 살펴봅니다.</p><h3 id="Immutable-Infrastructure">Immutable  Infrastructure</h3><p>온프레미스 환경에서는 인프라 환경을 구축하는 것도 큰 일이고, 일단 구축하면 변경 이력을 정리하면서 상당히 오랜 기간 사용합니다. 하지만 클라우드는 가상 환경이기 때문에 필요하면 구축하고 불필요하면 바로 폐기해도 상관 없습니다. 즉 서비스가 업데이트되면 기존 운영 환경을 변경하는 대신 이미지를 새로 생성해 배포합니다. 이를 변경하지 않는다는 뜻의 Immutable Infrastructure 라고 합니다.</p><p><img src="https://d3ansictanv2wj.cloudfront.net/immutable_infrastructure-8346d81e892e98c1308f707a037f4040.gif" alt="https://www.oreilly.com/ideas/an-introduction-to-immutable-infrastructure"></p><p>Immutable 인프라는 이미지 하나로 서버를 쉽게 찍어낼 수 있고 해당 이미지만 관리하면 되기 관리도 용이합니다. 또한 환경 자체를 배포하기 때문에 동일한 환경에서 테스트도 쉽습니다.</p><h3 id="Infrastructure-as-Code">Infrastructure as Code</h3><p>새로 서버를 설치한다고 합시다. 온프레미스 환경에서는 물리 서버나 네트워크 장비를 데이터 센터에 설치한 후 여러가지 설정을 해야 합니다. 만약 서버 100대를 수작업으로 설정한다면 어떨까요? 단순 반복 작업이라 시간도 오래 소요될 뿐더러 수작업으로 하다보면 실수가 나올 수도 있습니다.</p><p>또한 이후 OS 와 미들웨어의 버전 관리 및 보안 패치 적용을 생각했을 때 구성 관리를 효율적으로 하는 것이 앞으로의 운영 효율을 높이는 데 중요합니다. 이력이 제대로 관리되지 않으면 버전 정보와 설정 항목을 적어놓은 파라미터 시트와 값이 맞질 않아서 제대로 동작하지 않는 경우가 있습니다.</p><p>그래서 수작업 대신 프로그램 코드를 기반으로 관리하는 것이 좋습니다다. 이렇게 하면 편하고 작업 실수도 줄일 수 있을 뿐더러 Git 과 같은 버전 관리 소프트웨어를 이용해 변경 이력을 관리할 수 있습니다. 이렇게 코드 기반으로 인프라 구성을 관리하는 방식을 Infrastructure as Code 라고 합니다.</p><h3 id="인프라-구성-관리-툴">인프라 구성 관리 툴</h3><ul><li>Bootstrapping : OS 시작을 자동화<ul><li>서버 OS 를 설치, 가상 환경 설정, 네트워크 구성 설정 등</li><li><a href="https://www.vagrantup.com/">Vagrant</a></li></ul></li><li>Configuration : OS 나 미들웨어의 설정을 자동화<ul><li>OS 설정, 각종 미들웨어 설치 및 설정</li><li><a href="https://www.ansible.com/">Ansible</a>, <a href="https://www.chef.io/chef/">Chef</a>, <a href="https://puppet.com/">Puppet</a></li></ul></li><li>Orchestration : 여러 서버 관리를 자동화<ul><li><a href="https://kubernetes.io/">Kubernetes</a> : 컨테이너 오케스트레이션의 사실 살 표준(<em>de facto standrad</em>). 줄여서 k8s 라고도 부름.</li></ul></li></ul><h3 id="Continuous-Integration-와-인프라">Continuous Integration 와 인프라</h3><p><img src="ci.png" alt="http://www.pepgotesting.com/continuous-integration/"></p><p>지속적인 통합은 제대로 동작하는 코드를 자동으로 유지하기 위한 방법입니다. CI 환경이 구성되어 있지 않으면 빌드가 깨지는 경우도 많고 심지어 깨진 걸 모르는경우도 있습니다.  CI 환경에서 개발자가 코드를 커밋하면 Jenkins 와 같은 인테그레이션 툴이 코드 커밋을 감지해 자동으로 빌드와 테스트를 수행하고 코드 품질을 점검합니다. 문제가 있을 경우 해당 개발자에게  피드백이 가서 빠르게 조치하고 좋은 품질의 코드를 계속 유지할 수 있습니다.</p><p>단위 테스트를 통과한 모듈이 다른 환경에서도 똑같이 동작한다는 보장은 없습니다. 각종 설정이나 네트워크, 권한 등 인프라 환경에 의존하는 부분이 많은데요, 이러한 부분을 코드로 관리한다면 개발 멤버가 항상 동일한 환경에서 개발할 수 있어 테스트가 쉽고 환경 구성 관리가 더욱 쉬워집니다.</p><h3 id="Continuous-Delivery-와-인프라">Continuous Delivery 와 인프라</h3><p><img src="waterfall.png" alt="http://www.pepgotesting.com/continuous-integration/"></p><p>폭포수 모델에서는 처음 요구사항을 정의하는 시기와 실제로 SW를 고객에게 전달(<em>delivery</em>)하는 시기가 워낙 차이가 나다보니 문제가 생기곤 합니다. 물론 그 과정에서 고객이 아예 관여하지 않는 것은 아니지만, 대규모 프로젝트의 경우 몇 년이 소요되기도 하다보니 계속 변화하는 고객의 생각과 니즈를 충족시키기 어렵습니다.</p><p>고객의 입장에서는 시간이 지나면서 다른 기능이 계속 눈에 들어오다보니 실제 결과물이 마음에 차지 않게 되고, 개발하는 입장에서는 처음에 말한대로 다 만들었는데 개발 막바지에 수정이나 추가 개발을 해야하는 상황이 되는 것이죠.</p><p><img src="cd.png" alt="http://www.pepgotesting.com/continuous-integration/"></p><p>그래서 서로를 만족시키기는 방법은 고객의 니즈는 변한다는 것을 인정하고, 그 대신 개발 사이클 자체를 짧게 해서 개발과 릴리즈를 반복하는 것입니다. 실제로 동작하는 SW 를 고객에게 주기적으로 딜리버리함으로써 고객의 피드백을 받고 반영하는 것을 Continuous Delivery 라고 합니다.</p><p>그런데 지속적으로 딜리버리하는 과정에서 테스트 환경과 실제 운영 환경이 달라서 문제가 발생하기도 합니다. 인프라 환경도 포함한 애플리케이션 실행 환경을 그대로 제품 환경에 딜리버리할 수 있다면 안전하게 버전업을 할 수 있게 됩니다.</p><h2 id="가상화-Virtualization">가상화 Virtualization</h2><p>가상화란 쉽게 말해 컴퓨터 안에 독립적인 컴퓨터를 만드는 것입니다. 왜 컴퓨터 안에 컴퓨터를 만들까요? 주요한 목적 중 하나는 물리적인 리소스를 여러 사용자 또는 환경에 배포해서 제한된 리소스를 최대한 활용하기 위함입니다.</p><p>예를 들어 다음과 같이 세 개의 물리 서버가 있는데 사용량이 크지 않은 경우를 봅시다.</p><p><img src="https://www.redhat.com/cms/managed-files/server-usage-500x131.png" alt="https://www.redhat.com/ko/topics/virtualization/what-is-virtualization"></p><p>이럴 때는 가상화를 이용해 하나의 서버에 두 개의 서버를 독립적으로 분리하면 영향을 받지 않고 리소스를 더 효율적으로 사용할 수 있습니다.</p><p><img src="https://www.redhat.com/cms/managed-files/server-usage-for-virtualization-500x131.png" alt="https://www.redhat.com/ko/topics/virtualization/what-is-virtualization"></p><p>특히 하나의 서버 자원을 여러 사용자들이 나눠서 사용하는 클라우드 컴퓨팅의 기반이 됩니다.</p><h3 id="호스트형-서버-가상화">호스트형 서버 가상화</h3><p><img src="host-server-virtualization.png" alt="http://www.govmlab.com/news-section-3/"></p><p>하드웨어 위에 호스트 OS 를 설치하고 OS에서 가상화 SW를 이용해 게스트 OS를 작동시키는 기술입니다. 가상화 SW 를 설치하면 쉽게 가상 환경을 구축할 수 있기 때문에 개발 환경 구축 등에 주로 사용합니다. 오라클의 Virtual Box 나 VMware 가 있습니다.</p><p>하지만 OS 상에서 또 다른 OS 가 돌아가므로 자원이 많이 소비되고 느리다는 단점이 있습니다.</p><h3 id="하이퍼바이저형-가상화">하이퍼바이저형 가상화</h3><p><img src="https://www.docker.com/sites/default/files/styles/content_6_6/public/compare/container-vm-whatcontainer_2.png?itok=0eNn5aap" alt="https://www.docker.com/resources/what-container"></p><p>하드웨어 상에 가상화를 전문적으로 수행하는 SW 인 하이퍼바이저(<em>Hypervisor</em>)를 올라가는 방식입니다. 이 하이퍼바이저가 하드웨어와 가상 환경을 제어합니다. 호스트 OS 가 없어져서 조금 덜 부담되지만 그래도 각 VM(<em>Virtual Machine</em>)마다 게스트 OS 가 돌아가기 때문에 가상 환경 시작에 걸리는 오버헤드가 커집니다. 클라우드의 가상 머신에서도 사용하는 방법입니다.</p><h3 id="컨테이너-Container">컨테이너 Container</h3><p><img src="https://www.docker.com/sites/default/files/styles/content_6_6/public/compare/docker-containerized-appliction-blue-border_2.png?itok=lsxRQ9HU" alt="https://www.docker.com/resources/what-container"></p><p>컨테이너는 오버헤드를 최소화하기 위한 방법입니다. 호스트 OS 상에 독립적인 공간을 만들고 별도의 서버인 것처럼 사용합니다. 따라서 각 컨테이너는 같은 호스트 OS 를 공유하기 때문에 오버헤드가 적고 고속으로 동작합니다. 항구의 컨테이너처럼 안에 필요한 것을 모두 담고 다른 컨테이너와 격리시켜놓은 것이라고 볼 수 있습니다.</p><p>컨테이너는 애플리케이션 실행에 필요한 모듈을 하나로 모을 수 있기 때문에 여러 개의 컨테이너를 조합해서 하나의 애플리케이션을 구축하는 마이크로서비스와 잘 맞습니다.</p><h3 id="도커-Docker">도커 Docker</h3><p><img src="docker.png" alt="https://www.docker.com/"></p><p><a href="https://www.docker.com/">도커</a>는 애플리케이션 실행에 필요한 환경을 이미지로 만들고 해당 이미지를 활용해 다양한 환경에서 실행 환경을 구축하기 위한 오픈소스 플랫폼입니다. 도커는 내부에서 컨테이너를 사용합니다.</p><p>일반적인 개발 환경에서는 잘 동작하다가 갑자기 스테이징이나 운영 환경으로 가면 동작하지 않는 경우가 있습니다. 이런 인프라 환경을 도커를 이용해 컨테이너로 관리하면 어떨까요? 필요한 것을 모두 컨테이너로 모아서 이미지로 만드는 것입니다.</p><p><img src="https://i2.wp.com/foxutech.com/wp-content/uploads/2017/05/How-to-Build-a-Docker-image-using-Jenkins.png?fit=1344%2C916&amp;ssl=1" alt="https://foxutech.com/how-to-build-a-docker-image-using-jenkins/how-to-build-a-docker-image-using-jenkins-2/"></p><p>좀 더 자세히 보면 개발자가 커밋을 할 때마다 CI 를 통해 도커 이미지로 빌드를 하고 해당 이미지를 관리합니다. 그리고 개발 환경이든 테스트 환경이든, 실제 운영 환경이든 해당 이미지를 배포하면 컨테이너에서 독립적으로 배포된 환경에서 동작하기 때문에 오류 없이 동작할 수 있습니다.</p><h3 id="쿠버네티스-Kubernetes">쿠버네티스 Kubernetes</h3><p>실제 애플리케이션은 여러 컨테이너에 걸쳐 있고 이러한 컨테이너는 여러 서버에 배포되어 있습니다. 이렇게 여러 대의 서버나 하드웨어를 모아서 한 대처럼 보이게 하는 기술을 클러스터링(<em>clustering</em>)이라고 합니다. 이를 통해서 가용성과 확장성을 향상시킬 수 있습니다.</p><p>이런 멀티호스트 환경에서 컨테이너를 클러스터링하기 위한 툴을 컨테이너 오케스트레이션 툴이라고 합니다. 오케스트레이션 툴은 컨테이너들을 클러스터링하기 위해 컨테이너 시작 및 정지와 같은 조작, 호스트 간 네트워크 연결, 스토리지 관리, 컨테이너를 어떤 호스트에서 가동시킬지와 같은 스케줄링 기능을 제공합니다.</p><p><img src="https://d33wubrfki0l68.cloudfront.net/1567471e7c58dc9b7d9c65dcd54e60cbf5870daa/dba14/ko/_common-resources/images/flower.png" alt="https://kubernetes.io/ko/"></p><p>위에서 잠시 살펴봤지만 컨테이너 오케스트레이션 툴의 사실 상 표준은 <a href="https://kubernetes.io/">쿠버네티스</a>입니다. 쿠버네티스는 구글을 중심으로 한 오픈소스로 다양한 기업이 개발에 참여하고 있습니다. 하지만 온프레미스 환경에서 쿠버네티스 환경을 대규모로 구축하고 운영하는 것은 쉽지 않습니다. 내부적으로 인프라 기술자가 없다면 퍼블릭 클라우드에서 제공하는 서비스를 이용하는 것도 좋습니다.</p><ul><li><a href="https://docs.aws.amazon.com/ko_kr/AmazonECS/latest/developerguide/Welcome.html">Amazon EC2 Container Service</a></li><li><a href="https://aws.amazon.com/ko/eks/">Amzon EKS (Amazon Elastic Container Service for Kubernetes)</a></li><li><a href="https://azure.microsoft.com/ko-kr/overview/containers/">Azure Container Service</a></li><li><a href="https://cloud.google.com/kubernetes-engine/">Google Kubernetes Engine</a></li></ul><h2 id="참고">참고</h2><ul><li><a href="https://kyobobook.co.kr/product/detailViewKor.laf?mallGb=KOR&amp;ejkGb=KOR&amp;barcode=9788956747903">완벽한 IT 인프라 구축을 위한 Docker</a></li><li><a href="https://www.redhat.com/ko/topics/virtualization/what-is-virtualization">가상화란? | Red Hat</a></li></ul><h2 id="Releated-Posts">Releated Posts</h2><ul><li><a href="/2018/11/16/docker-container-basics/" title="도커 Docker 기초 확실히 다지기">도커 Docker 기초 확실히 다지기</a></li><li><a href="/2018/10/25/google-cloud-summit-seoul-2018/" title="구글 클라우드 서밋 서울 2018 후기">구글 클라우드 서밋 서울 2018 후기</a></li><li><a href="/2018/12/15/aws-reinvent-2018-summary/" title="AWS re:Invent 2018 한 방에 정리하기">AWS re:Invent 2018 한 방에 정리하기</a></li><li><a href="/2018/07/04/aws-certified/" title="AWS 자격증 준비하기">AWS 자격증 준비하기</a></li><li><a href="/2019/01/19/spring-boot-containerization-and-ci-cd-to-kubernetes-cluster/" title="스프링 부트 컨테이너와 CI&#x2F;CD 환경 구성하기">스프링 부트 컨테이너와 CI&#x2F;CD 환경 구성하기</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;p&gt;최근 클라우드 관련 부서로 옮겨 클라우드 관련 업무를 맡게 되었습니다</summary>
      
    
    
    
    <category term="Cloud" scheme="https://futurecreator.github.io/categories/Cloud/"/>
    
    
    <category term="linux" scheme="https://futurecreator.github.io/tags/linux/"/>
    
    <category term="basics" scheme="https://futurecreator.github.io/tags/basics/"/>
    
    <category term="docker" scheme="https://futurecreator.github.io/tags/docker/"/>
    
    <category term="kubernetes" scheme="https://futurecreator.github.io/tags/kubernetes/"/>
    
    <category term="cloud" scheme="https://futurecreator.github.io/tags/cloud/"/>
    
    <category term="infrastructure" scheme="https://futurecreator.github.io/tags/infrastructure/"/>
    
    <category term="server" scheme="https://futurecreator.github.io/tags/server/"/>
    
    <category term="network" scheme="https://futurecreator.github.io/tags/network/"/>
    
    <category term="middleware" scheme="https://futurecreator.github.io/tags/middleware/"/>
    
    <category term="virtualization" scheme="https://futurecreator.github.io/tags/virtualization/"/>
    
  </entry>
  
  <entry>
    <title>스프링 부트 Spring Boot 2.1.0 릴리즈!</title>
    <link href="https://futurecreator.github.io/2018/11/02/spring-boot-2-1-0-release/"/>
    <id>https://futurecreator.github.io/2018/11/02/spring-boot-2-1-0-release/</id>
    <published>2018-11-02T14:54:09.000Z</published>
    <updated>2025-03-14T16:10:24.228Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>2018년 10월 30일자로 스프링 부트 2.1이 공개되었습니다. 어떤 점이 달라졌는지 살펴보겠습니다.</p><p><img src="spring-boot.png" alt="Spring boot 2.1.0"></p><h2 id="써드파티-라이브러리-업그레이드">써드파티 라이브러리 업그레이드</h2><p>스프링부트에서 사용하는 써드파티(<em>third-party</em>) 라이브러리들의 버전이 업그레이드 되었습니다. 안정된(<em>stable</em>) 버전 중에서는 최신 버전이죠.</p><ul><li><a href="http://hibernate.org/">Hibernate 5.3</a> : ORM</li><li><a href="https://micrometer.io/">Micrometer 1.1</a> : 애플리케이션 모니터링</li><li><a href="https://projectreactor.io/docs">Reactor (Californium)</a> : JVM 기반 non-blocking 애플리케이션을 만들기 위한 4세대 리액티브 라이브러리</li><li><a href="https://spring.io/projects/spring-data">Spring Data (Lovelace)</a></li><li><a href="https://spring.io/blog/2018/09/21/spring-framework-5-1-goes-ga">Spring Framework 5.1</a></li><li><a href="https://tomcat.apache.org/tomcat-9.0-doc/index.html">Tomcat 9</a></li><li><a href="https://github.com/undertow-io/undertow">Undertow 2</a> : Non-blocking IO 기반 자바 웹 서버</li></ul><h2 id="성능-향상">성능 향상</h2><p>더 빠르고 더 적은 메모리를 사용하게 되었습니다.</p><h2 id="자바-11-지원">자바 11 지원</h2><p>스프링 프레임워크 5.1이 자바 11을 지원하면서 스프링 부트 2.1도 자바 11을 지원하게 되었습니다.</p><h2 id="DataSize">DataSize</h2><p><code>10MB</code>, <code>512Byte</code> 같은 데이터 크기를 쉽게 다룰 수 있는 <code>DataSize</code> 클래스를 지원합니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(&quot;app.io&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppIoProperties</span> &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@DataSizeUnit(DataUnit.MEGABYTES)</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">DataSize</span> <span class="variable">bufferSize</span> <span class="operator">=</span> DataSize.ofMegabytes(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> DataSize <span class="title function_">getBufferSize</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.bufferSize;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBufferSize</span><span class="params">(DataSize bufferSize)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.bufferSize = bufferSize;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Actuator-엔드포인트">Actuator 엔드포인트</h2><p><a href="https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#production-ready">Spring Boot Actuator</a> 는 애플리케이션 모니터링에 필요한 정보를 제공합니다. 스프링 부트 2.1에서는 두 개의 새로운 정보가 추가되었습니다.</p><ul><li><code>/actuator/caches</code> : 애플리케이션 캐시 관련 정보.</li><li><code>/actuator/integrationgraph</code> : Spring Integration 컴포넌트를 그래프로 보여줌.</li></ul><h2 id="각종-정보">각종 정보</h2><p>스프링 부트 Actuator 는 Micrometer 를 자동설정 해주고 다양한 모니터링 시스템을 지원합니다. Micrometer 가 1.1로 업그레이드 된 것 뿐만 아니라 <a href="https://www.appoptics.com/">AppOptics</a>, <a href="https://cloud.humio.com/">Humio</a>, <a href="https://kairosdb.github.io/">KariosDB</a> 의 자동설정도 추가되었습니다. 그리도 다음과 같은 정보들도 추가로 관리할 수 있습니다.</p><ul><li>Hibernate 정보</li><li>스프링 프레임워크의 <code>WebClient</code></li><li>Kafka 컨슈머 정보</li><li>Log4j2 정보</li><li>Jetty 서버 쓰레드 풀 정보</li><li>서버 사이드 <a href="https://jersey.github.io/">Jersey</a> HTTP 요청 정보</li></ul><p>이 외에도 많은 변화가 있었습니다. 여기엔 500여명의 개발자와 1만9천건 이상의 커밋이 있었습니다.<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="https://github.com/spring-projects/spring-boot/commits/master">[1]</span></a></sup></p><h2 id="참고">참고</h2><ul><li><a href="https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-2.1-Release-Notes">Spring Boot 2.1 Release Notes</a></li><li><a href="https://spring.io/blog/2018/10/30/spring-boot-2-1-0">Spring Boot 2.1.0 | Spring blog</a></li></ul><h2 id="Related-Posts">Related Posts</h2><ul><li><a href="/2018/09/29/java-11-released/" title="Java 11 릴리즈!">Java 11 릴리즈!</a></li><li><a href="/2016/06/18/spring-boot-get-started/" title="스프링 부트 (Spring Boot) 로 시작하는 프레임워크 (Framework)">스프링 부트 (Spring Boot) 로 시작하는 프레임워크 (Framework)</a></li></ul><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">https://github.com/spring-projects/spring-boot/commits/master<a href="#fnref:1" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;p&gt;2018년 10월 30일자로 스프링 부트 2.1이 공개되었습니다. 어</summary>
      
    
    
    
    <category term="Programming" scheme="https://futurecreator.github.io/categories/Programming/"/>
    
    <category term="Web" scheme="https://futurecreator.github.io/categories/Programming/Web/"/>
    
    
    <category term="spring" scheme="https://futurecreator.github.io/tags/spring/"/>
    
    <category term="release" scheme="https://futurecreator.github.io/tags/release/"/>
    
    <category term="spring_boot" scheme="https://futurecreator.github.io/tags/spring-boot/"/>
    
  </entry>
  
  <entry>
    <title>구글 클라우드 서밋 서울 2018 후기</title>
    <link href="https://futurecreator.github.io/2018/10/25/google-cloud-summit-seoul-2018/"/>
    <id>https://futurecreator.github.io/2018/10/25/google-cloud-summit-seoul-2018/</id>
    <published>2018-10-25T12:59:47.000Z</published>
    <updated>2025-03-14T16:10:24.208Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>구글 클라우드 서밋(<em>Google Cloud Summit</em>)은 구글이 우리나라에서 처음으로 진행하는 대규모 클라우드 공식 행사입니다. 지난 번 AWS Summit 2018 Seoul 에서는 AWSome Day 교육에 참가하느라 다양한 세션을 듣지 못해서 이번 행사에 기대가 컸는데요. 구글이 아마존을 따라잡기 위해 어떤 전략을 쓰고 있을지도 궁금했습니다.</p><p><img src="cloudsummit.jpg" alt="http://cloudsummit.co.kr/"></p><p>저는 사전 예약 페이지만 보고 갔는데 <a href="http://cloudsummit.co.kr/">행사 홈페이지</a>가 따로 있어서 다양한 정보를 제공하고 있었습니다. 특정 프로그램은 사전에 선착순 예약으로 진행했습니다.</p><p>도착해보니 다양한 프로그램과 부스가 있었는데요. 물론 AWS 서밋에 비하면 작은 규모였지만 흥미로운 프로그램이 많았습니다.</p><ul><li>주제가 있는 런치 : Tech for Social Impact 라는 주제의 점심 시간 내 세션(사전 예약 진행)</li><li>구글 클라우드 플랫폼 실습 : 사전 예약으로 최대 1시간 실습 가능.</li><li>연사와의 대화 : 각 세션이 끝난 후 연사와 질문 및 대화할 수 라운지 운영.</li><li>골드 파트너 토크 : 골드 파트너사가 준비한 세션.</li><li>구글 클라우드 플랫폼 사용자 그룹 멤버 라운지(네트워킹) 및 해커톤(<em>Hackathon</em>) 결과 발표</li><li>포인트 적립 - 세션 및 부스 참가 시 포인트가 쌓이고 포인트를 간식이나 기념품으로 교환.</li></ul><p>트랙은 총 4개 주제로 진행됩니다.</p><ol><li>데이터를 활용한 머신러닝과 IoT</li><li>인프라에 대한 새로운 생각</li><li>더 쉽고 스마트한 앱 개발 - 구글 클라우드를 이용한 개발</li><li>생산성을 높이는 업무 환경 - G Suit 이용하기</li></ol><p>머신러닝과 IoT 가 1번 트랙으로 나온 것이 인상깊었습니다. 클라우드를 이용해 대형 연구 기반을 가지고 있지 않더라도 쉽게 머신러닝과 AI를 사용할 수 있게 되었기 때문인 것 같네요. 3번 트랙은 서비스 사용법 위주일 것 같아서 클라우드 인프라 자체에 대한 이야기를 좀 더 듣기 위해 2번 트랙을 위주로 들었습니다.</p><ul><li>구글 클라우드 퀵스타트! 고객과의 패널토크</li><li>클라우드 플랫폼 정글에서 살아남기</li><li>마이크로서비스 아키텍처 구성하기</li><li>SRE 로 더 신뢰할 수 있는 시스템 구축하기</li><li>구글의 하이브리드 클라우드 전략</li></ul><h2 id="구글-클라우드-퀵스타트-고객과의-패널-토크">구글 클라우드 퀵스타트! 고객과의 패널 토크</h2><p>GCP 를 처음 접하는 사람들을 위해 구글 클라우드 플랫폼에 대한 전반적인 설명이 있었습니다.</p><ul><li>라이브 마이그레이션 - 무정지 상태에서 마이그레이션. 최소의 다운타임을 자랑.</li><li>커스터마이징 가능한 인스턴스 타입 - 리소스 사용 최적화</li><li>CPU Core 당 네트워크 할당량 (1vCPU=~16Gbps)</li><li>다양한 컨테이너와 서버리스 지원 서비스</li></ul><p><img src="google-talk.jpg" alt="구글 고객과의 패널 토크"></p><p>그리고 후반부에는 실제 GCP 를 사용 중인 국내 업체들과 간단한 패널 토크가 진행되었습니다. 넷마블, 쏘카, 신한카드에서 담당자가 나왔는데 실제 적용 사례를 들을 수 있어서 흥미로운 시간이었습니다.</p><p>넷마블은 처음엔 아기자기한 게임부터 시작했지만 점점 대규모 서비스를 하면서 데이터를 집계하고 분석하는 인프라를 확장해야 하는 상황이 되었고 글로벌 서비스에도 유리한 구글 클라우드를 선택했다고 합니다. 그런데 마이그레이션 시 빅 쿼리와 스키마가 좀 다른 점이 있어서 시간이 소요되었다고 하네요.</p><p>쏘카는 비트윈 개발사 VCNC 를 인수하면서 회사가 커지고 환경이 바뀌는 상황에서 구글 클라우드를 적용했는데요. 기존 오라클 기반의 인프라를 확장 시 비용이 너무 많이 들어서 클라우드를 선택했다고 하네요. 쏘카가 다루는 데이터는 복잡하지만 사이즈가 작기 때문에 클라우드 사용 시 비용도 아낄 수 있었다고 합니다.</p><p>신한카드의 경우 신한카드 챗봇을 만드는데 GCP 를 사용했는데 구글 클라우드의 한국어 자연어 처리 기능이 많이 개선되어 GCP 를 선택했다고 합니다. 하지만 아직 한글 지원이 부족한 면이 있어서 개선이 필요하다고 하네요.</p><p>고객 패널들이 향후 클라우드 도입 시 고려할 사항이라고 뽑은 것은 다음과 같습니다.</p><ul><li>무조건 도입보다는 충분히 사전 검토를 하고 선택하는 걸 추천합니다.</li><li>스몰 사이즈로 PoC 부터 해보는 것이 좋습니다.</li><li>구글의 전문가 지원을 적극 활용해야 적용 시간을 줄일 수 있습니다.</li><li>새로운 기술(빅데이터, 머신 러닝, AI, IoT 등)을 도입 시 활용을 추천합니다.</li></ul><p>20분 정도로 시간이 짧고 조금 딱딱한 면도 있었지만 그래도 여러 회사의 이야기를 들을 수 있어서 좋았습니다.</p><h2 id="주제가-있는-런치">주제가 있는 런치</h2><p>주제가 있는 런치는 사전 예약으로 진행되었지만 식사 시 스트리밍을 이용해 보여줘서 신청 안해도 볼 수 있었습니다. 점심 시간 내 가볍게 진행된 세션이었는데 상당히 흥미로웠습니다.</p><p><img src="lunch.jpg" alt="Tech for social impact"></p><ul><li>3D 프린터로 만드는 전자 의수</li><li>시각장애인 안내 AI 모바일 애플리케이션</li><li>파킨슨 병 검진 모델과 디바이스 + 모바일 앱</li></ul><p>특히 흥미로웠던 것은 시각장애인 안내 AI 모바일 앱이었습니다. 동탄고 2학년 고등학생이 만든 앱인데 시각 AI 가 인도와 차도를 구분하고 장애물을 식별해서 길을 안내해주는 앱이었습니다. 하지만 대부분의 데이터가 인도에 대한 데이터였기 때문에 자전거로 동네를 돌아다니면서 데이터를 수집하고 학습시켰다고 하네요. 아이디어도 대단하고 실제로 만들어보는 실행력도 대단합니다.</p><p>파킨슨 병 검진 모델도 인상 깊었습니다. 파킨슨 병은 찾아내기 쉽지 않은 병 중 하나인데 목소리로 파킨슨 병을 검진하는 기술이 나왔다고 합니다. 하지만 이 기술은 영어 기반으로 한국어는 같은 모음이라도 발음이나 발성이 달라서 적용하기 어렵다고 합니다. 이를 해결하기 위해 고등학생이 아이디어를 내서 텐서플로 모델을 만들고 사람들과 모여서 디바이스와 모바일 앱을 만들었다고 하네요.</p><p>사람에게 도움을 주는 아이디어와 단지 아이디어에서 그치지 않고 구현해낸 사람들, 그리고 쉽게 구현할 수 있도록 서비스를 제공한 GCP 모두 좋았습니다. GCP 에 대한 이미지도 좋아질 수 있는 세션이었습니다.</p><h2 id="클라우드-플랫폼-정글에서-살아남기">클라우드 플랫폼 정글에서 살아남기</h2><p>하이브리드 클라우드 구성 가이드에 대한 세션입니다. 이 세션은 파트너사 세션이었는데 상당히 유용한 세션이었습니다. 무조건 클라우드가 좋다가 아니라 실제 적용시 발생할 수 있는 사례들을 들어서 좋았습니다. 단편적인 고민보다 장기적이고 심층적인 고민을 통해 도입하는 것이 핵심입니다.</p><p><img src="cloud-platform.jpg" alt="클라우드 플랫폼 정글에서 살아남기"></p><h3 id="클라우드-도입-시-문제">클라우드 도입 시 문제</h3><p>일반적으로 클라우드로 마이그레이션하면서 기대하는 바는 가격, 확장성, 기술 등인데요. 그냥 도입한다고 되는게 아닙니다.</p><p>먼저 비용은 막연하게 싸다는 생각이 있지만, 실제로 장기간 운영해보면 줄어들지 않습니다. 확장성은 그냥 서버를 그대로 클라우드로 옮기는 Lift &amp; Shift 방식으로 옮길 경우엔 확장성을 누리지 못하는 경우가 많습니다. 다양한 최신 기술을 적용 시에도 사전 설계가 뒷받침되어 있지 않으면 오히려 병목(<em>bottleneck</em>)이 되기도 합니다. 보안에 대한 기준도 클라우드 프로바이더가 가지고 있기 때문에 내 마음대로 조율하기가 어렵습니다.</p><p>다 좋을 것 같지만 실제로 해보면 예상하지 못했던 일도 많고 실제로 많이 발생하고 있습니다. 개발과 테스트 단계에선 알 수 없지만 잠재되어 있던 이슈가 운영 단계에서는 나타나기 시작합니다.</p><p>멀티 클라우드는 온프레미스(<em>On-premise</em>)<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="온프레미스(On-premise)란 자체적으로 보유한 서버에 솔루션을 설치해 운영하는 방식.">[1]</span></a></sup>와 여러 클라우드 서비스를 함께 사용하는 방식인데요. 이것도 득보다 실이 많을 수 있습니다.</p><ul><li>아웃 바운드 트래픽 요금이 발생합니다.</li><li>하나만 느려도 전체 성능이 저하됩니다.</li><li>프로바이더마다 보안 기준이 달라 보안 표준을 구축하기 어렵습니다.</li><li>선택지가 많아지면서 좋은 점만을 보고 도입하게 됩니다.</li></ul><h3 id="사전-필수-고려사항">사전 필수 고려사항</h3><p>먼저 어디에 사용할지 용도를 정확하게 정의해야 합니다. 먼저 이 기준을 명확하게 잡아야 여러 상황에서 기준이 뒤집히지 않습니다. 예를 들어 여러 문제가 있는데도 비용이 적다고 해서 도입한다면 기준이 뒤집히는 것이죠.</p><p>그리고 마이그레이션은 단순하지가 않습니다. 그냥 있는 그대로 옮긴다고 클라우드가 아니죠. 온프레미스에서는 장애가 아예 발생하지 않는 것을 목표로 하지만, 클라우드는 언제나 시스템이 죽을 수 있습니다. 하지만 서비스를 죽지 않게 설계하는 것이죠. 여기에 맞춰서 설계해야 합니다.</p><p>또한 운영과 비용에 대해서 감당할 수 있어야만 선택할 수 있습니다. 비용의 경우 당장은 아니더라도 장기적으로 비즈니스는 계속 변하기 때문에 이러한 변경에 대해서도 대비를 해야 합니다. 안그러면 갑자기 폭탄 요금을 맞는 경우가 있습니다.</p><p>또한 오픈 소스의 도입 및 전환도 검토해야 합니다. 상용 솔루션의 경우 종속성 때문에 클라우드의 장점이 사라지기 때문입니다. 오픈 소스를 쓰면 다른 클라우드 서비스 전환 시에도 그대로 구성해서 사용할 수 있습니다.</p><h3 id="5-Things">5 Things</h3><ol><li>오픈 소스를 사용하세요.</li><li>서비스간 종속성 없는 클라우드 서비스를 사용하세요 (GCP는 모든 서비스가 독립적임).</li><li>새로운 기술을 적용할 때는 먼저 벤더에서 제공하는 기술을 가져다 사용하되 장기적으로는 내재화해서 종속성에서 벗어날 수 있도록 하세요.</li><li>당장은 아니더라도 궁극적으로는 하이브리드 구성을 하는 것이 좋습니다. 사업자마다 장점이 다르기 때문입니다. 클라우드 운영 및 관리 기술을 내재화해야 합니다.</li><li>마이크로서비스 아키텍처를 적용하세요. MSA(<em>Microservices Architecture</em>)는 서비스 레벨에서 종속성을 탈출할 수 있지만 운영 및 관리가 어렵기 때문에 장기적으로 준비하면서 점차 적용해나가는 것이 좋습니다(<a href="/2018/09/14/what-is-microservices-architecture/" title="마이크로서비스 Microservices (1) 아키텍처 소개">마이크로서비스 Microservices (1) 아키텍처 소개</a>).</li></ol><h2 id="마이크로서비스-아키텍처-구성하기">마이크로서비스 아키텍처 구성하기</h2><p>마이크로서비스 아키텍처를 GCP 에서 구성하기 위한 여러가지 툴(<em>Kubernetes, Istio, Spinnaker, Knative</em> 등)에 대한 세션이었습니다.</p><p><img src="msa.jpg" alt="마이크로서비스 아키텍처 구성하기"></p><p>기존의 모놀리식(<em>monolithic</em>) 아키텍처는 통으로 개발하는 방식이죠. 그 대신 각 기능을 개별로 개발, 배포, 운영할 수 있는 서비스로 분산하는 것이 마이크로서비스 아키텍처입니다. 하지만 분산한만큼 독립적이라는 장점도 있지만 관리, 테스트, 로깅 등 운영하는 것이 어려워집니다. 그래서 자동화된 플랫폼을 구축하고 개발자가 플랫폼을 이용해 개발과 배포를 실행하는 것을 DevOps 가 필수입니다. 모니터링, CI, CD 등을 지원합니다.</p><p>마이크로서비스에 적합한 기술은 컨테이너도 있죠. VM 으로 가상화하고 그 위에 컨테이너를 한 단계 더 올려서 자원을 효율적으로 사용할 수 있게 됩니다. 각 컨테이너에 서비스를 배포하게 됩니다(<a href="/2018/10/19/microservices-deployment-strategy/" title="마이크로서비스 Microservices (6) 배포 전략">마이크로서비스 Microservices (6) 배포 전략</a>).</p><p>마이크로서비스는 수십에서 수백 개의 많은 서비스로 이루어져 있는데요. 이 많은 컨테이너를 어떻게 관리할까요? 해당 서비스를 어느 컨테이너에서 실행할지 관리해주는 것이 컨테이너 스케쥴러입니다. 바로 쿠버네티스죠.</p><p>이러한 컨테이너의 취약점은 보안입니다. 구글 쿠버네티스 엔진은 보안이 강하다는 장점이 있습니다. 컨테이너 이미지를 등록하면 자동으로 취약점을 스캔해주고 복잡한 보안 설정을 간단하게 할 수 있으며 노드 보안 패치를 자동으로 하는 등 이 외에도 여러 서비스를 지원합니다.</p><p>컨테이너 그 다음은 무엇일까요? 보통의 서버는 1천 대가 있으면 1천 대가 모두 동일하지 않습니다. 왜냐면 서버를 계속해서 수정하는 부분적으로 서버에 배포되기 때문입니다. 눈에서 내리는 눈송이는 모두 눈이지만 제각각 모양이 다른 것처럼요. 이런 특징은 잠재적인 장애의 요인이 되는데 이런 서버를 스노우 플레이크 서버(<em>Snowflakes Server</em>)라고 합니다.</p><p>이런 점을 해결하기 위한 방법이 피닉스 서버(<em>Phoenix Server</em>)입니다. 피닉스(불사조)는 죽지 않는 건 아닙니다만 죽으면 알로 돌아가 불 속에서 다시 태어납니다. 이렇게 서버를 수정하는 대신에 서버를 아예 죽이고 다시 생성하는 방식입니다. 매번 서버 이미지를 구워서(<em>baking</em>) 다시 하나하나 배포합니다.</p><p>배포하는 것도 일인데 <a href="https://www.spinnaker.io/">Spinnaker</a> 는 클라우드 상에서 배포 관리와 클러스터 관리를 제공합니다. 이를 이용하면 다양한 배포 전략을 사용해 자동으로 배포할 수 있습니다.</p><p>이렇게 분산된 환경에서는 관리할 것도 많다고 말씀드렸는데요, <a href="https://www.envoyproxy.io/">Envoy</a> 라는 똑똑한 프록시 서버를 이용하면 다음과 같은 작업을 자동화할 수 있습니다. 이런 작업을 인프라 레벨로 내린 겁니다.</p><ul><li>지능형 라우팅<ul><li>동적으로 라우팅 경로 변경</li><li>A/B 테스트</li><li>카날리 테스트</li></ul></li><li>서비스 안정성<ul><li>타임 아웃</li><li>재시도</li><li>헬스 체크</li><li>써킷브레이커 패턴 (문제 생길 시 다른 서비스로 여파가 전파되지 않도록 끊음)</li></ul></li><li>보안과 정책<ul><li>양방향 TLS</li><li>조직 정책</li><li>접근 권한 제어</li><li>접근양 제어</li></ul></li><li>모니터링<ul><li>서비스간 의존성</li><li>트래픽 흐름 모니터링</li><li>분산 트렌젝션 모니터링</li></ul></li></ul><p>이 프록시 서버는 서비스 옆에 붙어서 기능을 지원하는데요 마이크로서비스는 서비스가 워낙 많다보니 Envoy 도 많이 필요합니다. 이 많은 프록시 서버를 중앙에서 관리하는 툴이 <a href="https://istio.io/">Istio</a> 입니다. Istio 는 자동으로 프록시 서버를 붙여서 배포하고 중앙에서 관리합니다.</p><p><img src="k8s-tools.jpg" alt="쿠버네티스 관련 툴"></p><p>이 많은 컨테이너를 모니터링하는 것도 쉽지 않죠. 컨테이너 모니터링은 다음과 같이 분산되어 있습니다.</p><ul><li>하드웨어 레벨</li><li>컨테이너 레벨</li><li>애플리케이션 레벨</li><li>쿠버네이트 모니터링</li></ul><p>복잡하고 모니터링 솔루션도 많습니다. 구글 클라우드는 멀티 <a href="https://cloud.google.com/stackdriver/">Stackdriver</a> 라는 종합 모니터링 툴을 제공합니다. 타사 클라우드 및 온프레미스까지 통합해서 모니터링하는 툴입니다. 게다가 여러 서비스 간 의존, 응답 시간 및 장애까지 시각화 분석이 가능합니다(베타 기능).</p><p>마지막으로 서버리스 서비스를 위한 쿠버네티스의 추가 컴포넌트인 <a href="https://cloud.google.com/knative/">Knative</a> 도 있습니다.</p><ul><li>바로 배포하고 실행</li><li>자동화된 운영 기능</li></ul><p>기술적인 것도 흥미로웠고 연사 분이 재미있게 발표해주셔서 재밌게 들은 세션입니다.</p><h2 id="SRE로-더-신뢰할-수-있는-시스템-구축하기">SRE로 더 신뢰할 수 있는 시스템 구축하기</h2><p>SRE(<em>Site Reliability Engineering</em>)는 신뢰할 수 있는 시스템을 구축하는 핵심입니다. 개발자는 민첩성을 중요시하고 운영자는 안정성을 중요시합니다. 그래서 이 둘 사이에는 벽이 생기기 마련인데요 이 둘의 균형을 찾고 두 가지 모두 이뤄내야 합니다. 구글은 ‘사이트 신뢰성 엔지니어’라는 직무가 있어서 이러한 벽을 무너뜨리고 공동의 책임 하에 시스템을 구축할 수 있도록 도와준다고 합니다.</p><ul><li>측정항목 모니터링 및 경고</li><li>용량 계획</li><li>변경 관리</li><li>비상 대응</li><li>문화</li></ul><p>인상 깊었던 점은 ‘장애가 발생한 것은 사람의 문제가 아니라 시스템의 문제다’라는 점이었습니다. 장애 발생 시 사람에게 책임을 묻지 말고 시스템과 프로세스에 문제가 있으니 그것을 고쳐나가야 한다는 것입니다.</p><h2 id="구글의-하이브리드-클라우드-전략">구글의 하이브리드 클라우드 전략</h2><p>위에서도 잠깐 나왔지만 하이브리드 클라우드에 대한 다양한 설계 방식을 알아보는 세션이었습니다. 내용이 너무 많은데 시간이 짧아서 급하게 진행되는 것이 좀 아쉬웠습니다. 나중에 발표자료가 나오면 천천히 살펴보고 싶은 세션입니다.</p><p>한번에 클라우드로 마이그레이션 하는 것은 쉽지가 않습니다. 크게 두 가지 방법이 있는데요.</p><ul><li>Lift &amp; Modernize : 시스템을 먼저 클라우드에 그대로 올린 후 클라우드 네이티브 기술들을 활용하도록 변경.</li><li>Improve &amp; Move : 먼저 VM 또는 컨테이너 등 클라우드 네이티브 기술을 활용해보고 시스템을 그대로 클라우드로 이전.</li></ul><p>기업 IT는 기본적으로 복합 환경이기 때문에 이에 대응할 수 있는 하이브리드는 실용적인 방법입니다. 퍼블릭 클라우드, 온프레미스, 모더나이즈(클라우드 네이티브), 타사 클라우드 등 이 네 가지를 섞어서 사용하는 것이 바로 하이브리드 클라우드 입니다.</p><h2 id="구글-클라우드의-미래는">구글 클라우드의 미래는?</h2><p>구글을 대표하는 키워드 중 하나가 개방적 혁신입니다. <a href="https://www.tensorflow.org/?hl=ko">TensorFlow</a> 와 쿠버네티스도 모두 오픈소스화 했고 표준이 되었습니다. 이런 오픈소스 전환은 생태계가 확장될 수 있도록 합니다.</p><p><img src="cloud-vendors-2018.png" alt="Enterprise Public Cloud Adoption 2018 vs. 2017"></p><p>이런 맥락에서 구글 클라우드의 모든 서비스는 독립적이고 종속적이지 않습니다. 각 서비스가 독립적이라는 뜻은 해당 서비스 전처리 또는 후처리에 다른 서비스를 필요로 하지 않는다는 뜻입니다. 클라우드 시장에서 AWS 와 MS 보다 뒤쳐진 구글은 하이브리드 클라우드를 강조하며 이에 적합한 서비스를 제공하는 것으로 보입니다. 통합 모니터링 툴인 Stakdriver 도 마찬가지죠. 전 세계에 검색 엔진 서비스를 지원하는 구글은 인프라도 있고 오픈소스 텐서플로와 쿠버네티스의 기술도 가지고 있으니 클라우드 시장에서 앞으로 구글이 어떤 모습을 보여줄지 기대해봅니다.</p><h2 id="Related-Posts">Related Posts</h2><ul><li><a href="/2018/11/09/it-infrastructure-basics/" title="개발자를 위한 인프라 기초 총정리">개발자를 위한 인프라 기초 총정리</a></li><li><a href="/2018/11/16/docker-container-basics/" title="도커 Docker 기초 확실히 다지기">도커 Docker 기초 확실히 다지기</a></li><li><a href="/2018/09/14/what-is-microservices-architecture/" title="마이크로서비스 Microservices (1) 아키텍처 소개">마이크로서비스 Microservices (1) 아키텍처 소개</a></li><li><a href="/2018/10/19/microservices-refactoring-for-monolith/" title="마이크로서비스 Microservices (7) 모놀리스 리팩토링">마이크로서비스 Microservices (7) 모놀리스 리팩토링</a></li><li><a href="/2018/07/04/aws-certified/" title="AWS 자격증 준비하기">AWS 자격증 준비하기</a></li><li><a href="/2019/01/19/spring-boot-containerization-and-ci-cd-to-kubernetes-cluster/" title="스프링 부트 컨테이너와 CI&#x2F;CD 환경 구성하기">스프링 부트 컨테이너와 CI&#x2F;CD 환경 구성하기</a></li></ul><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">온프레미스(On-premise)란 자체적으로 보유한 서버에 솔루션을 설치해 운영하는 방식.<a href="#fnref:1" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;p&gt;구글 클라우드 서밋(&lt;em&gt;Google Cloud Summit&lt;/em</summary>
      
    
    
    
    <category term="Cloud" scheme="https://futurecreator.github.io/categories/Cloud/"/>
    
    
    <category term="google" scheme="https://futurecreator.github.io/tags/google/"/>
    
    <category term="aws" scheme="https://futurecreator.github.io/tags/aws/"/>
    
    <category term="kubernetes" scheme="https://futurecreator.github.io/tags/kubernetes/"/>
    
    <category term="cloud" scheme="https://futurecreator.github.io/tags/cloud/"/>
    
    <category term="gcp" scheme="https://futurecreator.github.io/tags/gcp/"/>
    
    <category term="google_cloud_summit" scheme="https://futurecreator.github.io/tags/google-cloud-summit/"/>
    
    <category term="seoul" scheme="https://futurecreator.github.io/tags/seoul/"/>
    
  </entry>
  
  <entry>
    <title>마이크로서비스 Microservices (7) 모놀리스 리팩토링</title>
    <link href="https://futurecreator.github.io/2018/10/19/microservices-refactoring-for-monolith/"/>
    <id>https://futurecreator.github.io/2018/10/19/microservices-refactoring-for-monolith/</id>
    <published>2018-10-19T12:40:06.000Z</published>
    <updated>2025-03-14T16:10:24.208Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="모놀리스에서-마이크로서비스로">모놀리스에서 마이크로서비스로</h2><p>모놀리식(<em>monolithic</em>) 애플리케이션을 마이크로서비스(<em>microservices</em>) 애플리케이션으로 바꾸고 싶다면 어떻게 하시겠습니까? 처음부터 마이크로서비스 기반으로 다시 작성해야 할까요?</p><blockquote><p>폭파시키고 처음부터 작성해야 할 때는 진짜로 폭파했을 때 뿐이다.</p><footer><strong>Martin Fowler</strong></footer></blockquote><p>아닙니다. 처음부터 다시 만드는 일은 너무나 어려운 작업이고 큰 위험이 따르는 작업이죠. 대신에 점차적으로 개선해나가야 합니다. 하나의 큰 애플리케이션을 작은 서비스로 조금씩 쪼개나가야 합니다. 열대우림을 상상해봅시다. 여기엔 Strangler vine 이라는 식물이 있는데 아래 사진처럼 생겼습니다. 열대우림은 나무가 너무 많다보니 땅에 있으면 햇빛을 많이 받을 수가 없습니다. 그래서 이 식물은 햇빛을 받기 위해 다른 나무를 타고 올라갑니다. 결국 원래 나무는 죽고 이 식물만 남게 됩니다.</p><p><img src="https://www.nginx.com/wp-content/uploads/2016/03/Richardson-microservices-part7-fig.png" alt="https://www.nginx.com/blog/refactoring-a-monolith-into-microservices/"></p><p>갑자기 왜 나무 이야기냐구요? 우리는 바로 이 식물의 전략을 따라 리팩토링 하려고 합니다. 기존 애플리케이션을 따라 새로운 마이크로서비스를 만들고 기존 애플리케이션은 자연스럽게 없어집니다.</p><p>이를 위한 세 가지 전략을 한 번 살펴보겠습니다.</p><h2 id="1-삽질은-그만">1. 삽질은 그만!</h2><p>우리가 구덩이에 있다면 삽질을 멈춰야 합니다.<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[Law of holes](https://en.wikipedia.org/wiki/Law_of_holes)">[1]</span></a></sup> 파면 팔수록 더 깊이 빠지게 되죠. 관리되지 않는 모놀리식 애플리케이션에 딱 맞는 말이죠. 즉 모놀리스 애플리케이션이 더 커지는 걸 막아야 합니다. 커지면 커질수록 더 관리하기 어려워지기 때문입니다. 그래서 여기에 새로운 코드를 추가하면 안됩니다! 대신 새로운 코드를 새로운 마이크로서비스로 만드는 것이 이 전략의 핵심입니다.</p><p><img src="https://www.nginx.com/wp-content/uploads/2016/03/Adding_a_secure_microservice_alongside_a_monolithic_application-1024x865.png" alt="https://www.nginx.com/blog/refactoring-a-monolith-into-microservices/"></p><p>새로운 기능을 새로운 서비스로 만들고 나면 요청을 라우팅해줄 라우터(<em>router</em>)가 필요합니다. 마치 API 게이트웨이처럼 말이죠. 그리고 모놀리스와 새로운 서비스 사이에 글루 코드(<em>glue code</em>)가 필요합니다. 글루 코드는 두 서비스를 연결해주는 코드를 말하는데요, 서비스를 새로 만들긴 했지만 아직 완전히 분리되기엔 데이터가 완전하지 않기 때문에 글루 코드를 이용해 모놀리스에서 데이터를 가져와야 합니다. 이런 글루 코드는 아직 오염되지 않은 서비스와 오염된 모놀리스 사이를 나눠주기 때문에 오염 방지 레이어(<em>anti-corruption layer</em>)라고도 합니다. 글루 코드는 다음과 같이 구현할 수 있습니다.</p><ul><li>모놀리스가 제공하는 API 사용</li><li>모놀리스의 DB에 바로 접근</li><li>모놀리스 DB를 복사해서 새로운 서비스에서 관리</li></ul><p>이 전략은 좋지만 모놀리스가 아직 건재합니다. 이제 모놀리스를 쪼갤 전략을 살펴보겠습니다.</p><h2 id="2-레이어-분리하기">2. 레이어 분리하기</h2><p>모놀리스 로직을 줄여가기 위해서 프론트엔드와 백엔드를 분리하겠습니다. 보통 엔터프라이즈 애플리케이션은 3계층 구조로 이루어져 있습니다.</p><ul><li>프레젠테이션 레이어(<em>Presentation layer</em>): HTTP 요청을 다루는 계층. REST API 를 제공하거나 HTML 기반의 웹  UI를 제공.</li><li>비즈니스 로직 레이어(<em>Business logic layer</em>): 애플리케이션의 비즈니스 로직이 들어있는 핵심 계층.</li><li>데이터 액세스 레이어(<em>Data-access layer</em>): 데이터베이스나 메시지 브로커(<em>message brokers</em>)에 접근하는 계층.</li></ul><p>여기서 프레젠테이션 레이어와 나머지 비즈니스 로직 레이어 + 데이터 액세스 레이어는 쉽게 분리할 수 있습니다. 따라서 프레젠테이션 레이어로 하나의 서비스를 만들고, 나머지 비즈니스 로직 레이어와 데이터 액세스 레이어를 하나의 서비스로 해서 두 개의 서비스로 분리할 수 있습니다. 그리고 나서 프레젠테이션 레이어가 호출할 수 있는 API 를 제공합니다.</p><p><img src="https://www.nginx.com/wp-content/uploads/2016/04/Richardson-microservices-part7-refactoring.png" alt="https://www.nginx.com/blog/refactoring-a-monolith-into-microservices/"></p><p>프레젠테이션 레이어에는 비즈니스 로직이 없기 때문에 쉽게 분리할 수 있습니다. 그리고 자연스럽게 비즈니스 로직 쪽에서 API 를 제공할 수 있게 됩니다. 그럼 마지막 세 번째 전략으로 나머지 부분도 모두 마이크로서비스로 바꿔봅시다.</p><h2 id="3-서비스-뽑아내기">3. 서비스 뽑아내기</h2><h3 id="서비스-고르기">서비스 고르기</h3><p>세 번째 전략은 기존의 모놀리스 속 모듈을 하나의 독립적인 마이크로서비스로 만드는 것입니다. 모두 서비스로 분리하고 나면 모놀리스는 완전히 사라지게 됩니다.</p><p>모놀리스 안에는 수십에서 수백 개의 모듈이 있습니다. 어떤 모듈을 서비스로 뽑아내야 할까요?</p><p>우선 뽑아내기 쉬운 모듈부터 작업을 해나가면 뽑아내는 작업에 익숙해질 수 있습니다. 그리고 변경이 자주 일어나는 모듈을 먼저 뽑아내는 것이 좋습니다. 왜냐하면 마이크로서비스로 뽑아내고 나면 독립적으로 개발하고 배포가 가능하기 때문에 시간을 아낄 수 있습니다.</p><p>자원을 많이 사용하는 모듈은 따로 뽑아내서 관리하는 것이 좋습니다. 예를 들면 인메모리 DB 를 사용하는 모듈이 있다면 메모리를 많이 잡아먹을 것이고, 복잡한 알고리즘을 수행하는 로직이 있다면 CPU 자원을 많이 사용할 겁니다. 이런 모듈은 따로 뽑아서 관리하는 것이 좋습니다.</p><p>서비스가 뭉쳐있는 부분도 뽑아내기 쉽습니다. 예를 들어 특정 모듈들이 다른 모듈들과 비동기 메시지 방식으로 통신하는 경우에는 분리가 쉽습니다.</p><h3 id="서비스-뽑아내기">서비스 뽑아내기</h3><p>먼저 뽑아낼 모듈과 모놀리스 사이에 인터페이스를 정의합니다. 서비스와 모놀리스는 서로 데이터가 필요해서 양방향 API 인 경우가 많고, 종속성이 얽혀 있어서 인터페이스를 정의하기 어려울 수 있습니다. 특히 도메인 모델 패턴(<em>Domain Model pattern</em>)을 이용해 구현한 경우라면 도메인 모델 클래스를 나누기가 어렵습니다. 이런 종속성을 끊으려면 중요한 코드를 변경해야 할 때가 있습니다.</p><p>인터페이스를 정의하고 난 후에 이를 이용해서 모놀리스 모듈을 마이크로서비스로 분리합니다. 아래 그림은 인터페이스를 정의하고 분리하는 모습을 보여줍니다. 호출 관계에 따라서 API 의 방향이 정해집니다.</p><p><img src="https://www.nginx.com/wp-content/uploads/2016/04/Richardson-microservices-part7-extract-module.png" alt="https://www.nginx.com/blog/refactoring-a-monolith-into-microservices/"></p><p>이런 작업을 반복해서 마이크로서비스를 늘려갈수록 모놀리스는 작아지고 개발 속도는 빨라지게 됩니다.</p><h2 id="참고">참고</h2><ul><li><a href="https://www.nginx.com/blog/refactoring-a-monolith-into-microservices/">Refactoring a Monolith into Microservices | NGINX Blog</a></li></ul><h2 id="Related-Posts">Related Posts</h2><ul><li><a href="/2018/09/14/what-is-microservices-architecture/" title="마이크로서비스 Microservices (1) 아키텍처 소개">마이크로서비스 Microservices (1) 아키텍처 소개</a></li><li><a href="/2018/09/14/microservices-with-api-gateway/" title="마이크로서비스 Microservices (2) API 게이트웨이">마이크로서비스 Microservices (2) API 게이트웨이</a></li><li><a href="/2018/10/04/inter-process-communication-in-microservices/" title="마이크로서비스 Microservices (3) 프로세스 간 통신">마이크로서비스 Microservices (3) 프로세스 간 통신</a></li><li><a href="/2018/10/18/service-discovery-in-microservices/" title="마이크로서비스 Microservices (4) 서비스 디스커버리">마이크로서비스 Microservices (4) 서비스 디스커버리</a></li><li><a href="/2018/10/19/microservices-and-event-driven-data-management/" title="마이크로서비스 Microservices (5) 이벤트 주도 데이터 관리">마이크로서비스 Microservices (5) 이벤트 주도 데이터 관리</a></li><li><a href="/2018/10/19/microservices-deployment-strategy/" title="마이크로서비스 Microservices (6) 배포 전략">마이크로서비스 Microservices (6) 배포 전략</a></li><li><a href="/2018/10/19/microservices-refactoring-for-monolith/" title="마이크로서비스 Microservices (7) 모놀리스 리팩토링">마이크로서비스 Microservices (7) 모놀리스 리팩토링</a></li></ul><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://en.wikipedia.org/wiki/Law_of_holes">Law of holes</a><a href="#fnref:1" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h2 id=&quot;모놀리스에서-마이크로서비스로&quot;&gt;모놀리스에서 마이크로서비스로&lt;</summary>
      
    
    
    
    <category term="Programming" scheme="https://futurecreator.github.io/categories/Programming/"/>
    
    <category term="MSA" scheme="https://futurecreator.github.io/categories/Programming/MSA/"/>
    
    
    <category term="microservices" scheme="https://futurecreator.github.io/tags/microservices/"/>
    
    <category term="monolith" scheme="https://futurecreator.github.io/tags/monolith/"/>
    
    <category term="refactoring" scheme="https://futurecreator.github.io/tags/refactoring/"/>
    
  </entry>
  
  <entry>
    <title>마이크로서비스 Microservices (5) 이벤트 주도 데이터 관리</title>
    <link href="https://futurecreator.github.io/2018/10/19/microservices-and-event-driven-data-management/"/>
    <id>https://futurecreator.github.io/2018/10/19/microservices-and-event-driven-data-management/</id>
    <published>2018-10-19T12:39:55.000Z</published>
    <updated>2025-03-14T16:10:24.208Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="분산-데이터-관리의-어려움">분산 데이터 관리의 어려움</h2><p>보통 모놀리식(<em>monolithic</em>) 애플리케이션에서는 하나의 관계형 DB(<em>Relational database</em>)를 사용합니다. DB 작업은 트랜잭션(<em>transaction</em>)이라는 단위로 수행이 되는데 RDB의 장점은 트랜잭션이 <a href="https://en.wikipedia.org/wiki/ACID_(computer_science)">ACID</a>하도록 만들어줍니다.</p><ul><li>원자성(<strong>A</strong>tomicity): 작업이 완전히 성공하든지 또는 완전히 실패하도록 만들어서 애매한 상태가 없는 것을 보장.</li><li>일관성(<strong>C</strong>onsistency): 데이터를 일관된 상태로 유지하는 것을 보장.</li><li>격리성(<strong>I</strong>solation): 다른 작업과 꼬이지 않도록 트랜잭션이 동시에 실행되지 않는 것을 보장.</li><li>지속성(<strong>D</strong>urable): 데이터를 안전하게 보관하기 위해 트랜잭션을 커밋(<em>commit</em>)하면 되돌릴 수 없는 것을 보장.</li></ul><p>SQL을 사용할 수 있는 것도 RDB의 장점입니다. 여러 테이블에서 데이터를 쉽게 가져올 수 있고 최적화된 방법으로 데이터를 조회할 수 있습니다.</p><h3 id="폴리글랏-퍼시스턴스">폴리글랏 퍼시스턴스</h3><p>마이크로서비스 아키텍처에선 어떨까요? 각 마이크로서비스는 각자의 DB를 가지고 있고 다른 서비스의 DB 에 접근할 수 없습니다. 제공된 API 를 통해서만 접근이 가능합니다. 따라서 데이터를 캡슐화하고 결합도를 낮출 수 있습니다.</p><p>또한 이런 구조는 각자의 서비스의 기능과 역할에 맞는 DB 를 선택할 수 있는 장점도 있습니다. RDB 뿐만 아니라 NoSQL 을 섞어서 사용할 수 있고, 분산형 검색 엔진인 <a href="https://www.elastic.co/kr/products/elasticsearch">Elasticserach</a> 나 그래프 데이터베이스인 <a href="https://neo4j.com/product/">Neo4j</a> 를 사용할 수도 있습니다. 이렇게 각 서비스의 기능에 따라 적합한 데이터베이스를 선택해서 사용하는 방식을 <a href="https://martinfowler.com/bliki/PolyglotPersistence.html">폴리글랏 퍼시스턴스</a>(<em>Polyglot Persistence</em>)라고 합니다.</p><p>하지만 데이터가 분산되어 있기 때문에 관리하기가 어렵습니다. 같은 데이터를 여러 서비스에서 사용한다면 데이터 중복도 발생하고 업데이트 시 여러 서비스의 DB 에 함께 반영해야 하므로 일관성을 유지하기 어렵습니다. 각자 사용하는 DBMS 가 다른 것도 문제가 되겠죠.</p><h3 id="일관된-데이터">일관된 데이터</h3><p>먼저 어떻게 일관된 데이터를 유지할 수 있을까요? B2B 스토어를 예로 들어보겠습니다. 고객(<em>Customer</em>) 서비스는 신용 정보를 포함한 고객 정보를 관리하고, 주문(<em>Order</em>) 서비스는 주문 정보를 관리합니다. 그런데 주문 시 해당 고객의 신용 한도(<em>CREDIT_LIMIT</em>)가 넘지 않아야 하기 때문에 고객의 신용 한도 정보가 필요합니다.</p><p><img src="https://cdn.wp.nginx.com/wp-content/uploads/2015/12/Richardson-microservices-part5-separate-tables-e1449727641793.png" alt="https://www.nginx.com/blog/event-driven-data-management-microservices/"></p><p>하지만 주문 서비스는 고객 테이블(<em>CUSTOMER</em>)에 바로 접근할 수가 없습니다. 그리고 주문을 하는 경우 고객의 신용 정보까지수정을 해야 하는데 이런 경우에 <a href="https://en.wikipedia.org/wiki/Two-phase_commit_protocol">2단계 커밋</a>(<em>two-phase commit protocol</em>)이라는 분산 트랜잭션을 사용할 수 있습니다.</p><p>분산 컴퓨팅 환경의 이론 중 하나인 <a href="https://en.wikipedia.org/wiki/CAP_theorem">CAP 정리</a> 에 따르면 다음과 같은 세 가지 조건을 모두 만족하는 분산 컴퓨터 시스템은 없다고 합니다.</p><ul><li>일관성(<strong>C</strong>onsistency): 모든 노드가 같은 순간에 같은 데이터를 볼 수 있음.</li><li>가용성(<strong>A</strong>vailability): 모든 요청이 성공 또는 실패 결과를 반환할 수 있음.</li><li>분할내성(<strong>P</strong>artition tolerance): 메시지 전달이 실패하거나 시스템 일부가 망가져도 시스템이 계속 동작할 수 있음.</li></ul><p>따라서 이 조건들 중에 선택을 해야하는데, 대부분의 경우 일관된 데이터를 위해서 가용성이나 분할내성을 포기할 수는 없습니다. 시스템이 멈추지 않고 동작하게 하는 것이 더 중요하다고 보기 때문입니다. 게다가 대부분의 NoSQL DB는 2단계 커밋을 지원하지 않습니다.</p><h3 id="분산된-데이터-조회">분산된 데이터 조회</h3><p>두 번째 문제는 여러 서비스에서 데이터를 조회하는 일입니다. 위의 예에서 고객 정보와 함께 고객의 최근 주문 내역을 보여줘야 한다고 해봅시다. RDB 모놀리식이라면 각 테이블을 <code>JOIN</code> 해서 구할 수 있겠지만  마이크로서비스에서는 각 서비스에서 가져온 데이터를 가져와 직접 데이터를 조인해야 합니다. 게다가 NoSQL 은 PK(<em>Primary Key</em>) 기반의 조회밖에 할 수 없어서 더 어려워질 수 있습니다.</p><h2 id="이벤트-주도-아키텍처">이벤트 주도 아키텍처</h2><p>이런 문제점들을 해결하기 위해 <a href="http://martinfowler.com/eaaDev/EventNarrative.html">이벤트 주도 아키텍처</a>(event‑driven architecture)를 적용할 수 있습니다. 이벤트 형태로 여러 서비스에게 메시지를 동시에 전달할 수 있기 때문에 일관되게 데이터를 수정할 수 있습니다. 해당 데이터를 수정해야 하는 이벤트가 발생하면 연관된 서비스들이 이벤트를 구독하고 있다가 메시지를 받아서 데이터를 갱신하는 것이죠. 위에서 살펴본 예제에 이벤트 주도 아키텍처를 적용해보겠습니다.</p><h3 id="일관성">일관성</h3><p>먼저 주문서비스에서 주문을 만들고 <code>Order Created</code> 이벤트를 발행합니다.</p><p><img src="https://cdn.wp.nginx.com/wp-content/uploads/2015/12/Richardson-microservices-part5-credit-check-1-e1449727610972.png" alt="https://www.nginx.com/blog/event-driven-data-management-microservices/"></p><p>해당 이벤트를 구독하고 있던 고객 서비스가 예약한 신용 정보를 추가하고 <code>Credit Reserved</code> 이벤트를 발행합니다.</p><p><img src="https://cdn.wp.nginx.com/wp-content/uploads/2015/12/Richardson-microservices-part5-credit-check-2-e1449727579423.png" alt="https://www.nginx.com/blog/event-driven-data-management-microservices/"></p><p>해당 이벤트를 구독하고 있는 주문 서비스가 주문의 상태를 OPEN 으로 변경합니다.</p><p><img src="https://cdn.wp.nginx.com/wp-content/uploads/2015/12/Richardson-microservices-part5-credit-check-3-e1449727548440.png" alt="https://www.nginx.com/blog/event-driven-data-management-microservices/"></p><p>이런 구조라면 여러 서비스에서 동시에 데이터를 수정하면서 일관성을 유지될 수 있습니다. 물론 각 서비스의 DB 가 원자성을 보장하고 메시지 브로커가 각 이벤트를 최소한 한번 전달하는 것이 보장되어야 합니다. 하지만 ACID 트랜잭션만큼은 아닙니다.</p><h3 id="분산된-데이터-조회-v2">분산된 데이터 조회</h3><p>다음은 데이터를 조인하는 문제를 해결해봅시다. 앞서 살펴본 고객 주문 내역을 볼까요? 두 서비스를 하나로 합쳐서 생각할 수 없으니 새로운 서비스를 하나 만듭니다. 따로 고객의 주문 내역을 저장하는 서비스(고객 주문 내역 뷰 서비스)를 하나 만드는 겁니다. 이 서비스는 고객 주문 내역 자체를 수정하지는 않고 조회 시 보여주는 역할만 합니다. 따라서 필요한 이벤트(고객, 주문)를 모두 구독하고 해당 데이터가 수정이 될 때마다 자신의 데이터를 갱신합니다.</p><p><img src="https://cdn.wp.nginx.com/wp-content/uploads/2015/12/Richardson-microservices-part5-subscribe-e1449727516992.png" alt="https://www.nginx.com/blog/event-driven-data-management-microservices/"></p><p>그림에서는 고객 주문 내역 조회 서비스를 따로 만들었지만 고객 내역 뷰 서비스에서 조회 API 를 제공하는게 나아보이네요.</p><p>이처럼 이벤트 주도 아키텍처를 이용해서 문제를 해결할 수 있었는데요, 단점도 있습니다.</p><ul><li>ACID 트랜잭션에 비해 구조가 복잡합니다.</li><li>오류가 발생하면 애플리케이션 레벨에서 반영한 내용을 취소하는 트랜잭션을 구현해야 합니다.</li><li>뷰를 사용하는 경우 반영되기 전에 데이터가 불일치할 수 있습니다.</li><li>이벤트가 여러 번 발생하는 경우를 탐지해서 중복된 이벤트는 무시해야 합니다.</li></ul><h3 id="원자성">원자성</h3><p>위에서 살펴본 단점 중 하나가 원자성입니다. 데이터를 수정하고 이벤트를 발행했을 때 이벤트를 받은 쪽에서도 데이터를 수정해줘야 원자성이 보장됩니다. 하지만 데이터를 수정은 했는데 이벤트를 생성하기 전에 에러가 나서 이벤트를 생성하지 못하면 성공도 아니고 실패도 아닌 어정쩡한 상태가 됩니다. 원자성을 잃어버리게 되죠. 어떻게 하면 해결할 수 있을까요?</p><h4 id="로컬-트랜잭션을-이용해-이벤트-발행하기">로컬 트랜잭션을 이용해 이벤트 발행하기</h4><p>첫 번째 방법은 로컬 트랜잭션을 이용해서 이벤트를 발행하는 방법입니다. 로컬 트랜잭션은 원자성이 보장되기 때문에 이를 이용해서 이벤트를 확실하게 발생시키는 방법입니다. 구현하는 방법은 이벤트 테이블(<em>EVENT</em>)를 따로 만들어서 로컬 트랜잭션을 이용해서 이벤트 테이블에 데이터를 넣고 이벤트 퍼블리셔가 이벤트 테이블을 확인해서 메시지 브로커에 이벤트를 발행합니다.</p><p><img src="https://cdn.wp.nginx.com/wp-content/uploads/2015/12/Richardson-microservices-part5-local-transaction-e1449727484579.png" alt="https://www.nginx.com/blog/event-driven-data-management-microservices/"></p><p>하지만 개발자가 두 테이블에 데이터를 insert 해야 하는데 실수로 빼먹을 가능성이 있습니다. 그리고 RDB 가 아닌 NoSQL 에서는 ACID 트랜잭션이 아니기 때문에 한계가 있습니다.</p><h4 id="DB-트랜잭션-로그를-모아서-이벤트-발행하기">DB 트랜잭션 로그를 모아서 이벤트 발행하기</h4><p>두 번째 방법은 DB 의 트랜잭션 로그를 모아서 이벤트를 발행하는 방법입니다. 트랜잭션 로그를 모아서 분석한 후 이벤트를 발행하면 이벤트 발행을 보장할 수 있고 비즈니스 로직과 이벤트 발행 기능을 분리할 수 있습니다.</p><p><img src="https://cdn.wp.nginx.com/wp-content/uploads/2015/12/Richardson-microservices-part5-transaction-log-e1449727434678.png" alt="https://www.nginx.com/blog/event-driven-data-management-microservices/"></p><p>이를 구현한 예로는 오픈소스인 <a href="https://github.com/linkedin/databus">LinkedIn Databus</a> 가 있습니다. Databus 는 오라클(<em>Oracle</em>) 트랜잭션 로그를 모아서 수정이 있는 경우 이벤트를 발행합니다. NoSQL 쪽에서는 <a href="https://docs.aws.amazon.com/ko_kr/amazondynamodb/latest/developerguide/Streams.html">AWS DynamoDB 의 스트림 매커니즘</a> 이 있습니다. 이 스트림에는 지난 24시간 동안 DynamoDB 테이블 항목의 변경 정보(<em>create, update, delete</em>)가 기록되며 각 스트림 기록은 한 번만 나타나고 실제 항목 수정과 동일한 순서로 나타납니다. 애플리케이션은 이 정보를 읽어서 이벤트를 발행하는 등 처리를 할 수 있습니다.</p><p><img src="https://docs.aws.amazon.com/ko_kr/amazondynamodb/latest/developerguide/images/streams-endpoints.png" alt="https://docs.aws.amazon.com/ko_kr/amazondynamodb/latest/developerguide/Streams.html"></p><p>하지만 각 DB마다 로그 포맷이 다르기 때문에 적용하기 쉽지 않을 수 있고, low-level 인 로그에서 high-level 인 비즈니스 이벤트를 만들어야 한다는 점이 어렵습니다.</p><h4 id="이벤트-소싱-사용하기">이벤트 소싱 사용하기</h4><p><a href="https://github.com/cer/event-sourcing-examples/wiki/WhyEventSourcing">이벤트 소싱</a>(<em>Event Sourcing</em>)은 근본적으로 저장하는 개념이 다릅니다. 비즈니스 개체의 현재 상태를 저장하는대신 상태를 변경하는 이벤트 내역을 목록으로 저장합니다. 그리고 이 이벤트 내역을 순서대로 재생하면서 개체의 현재 상태를 재구성합니다. 이벤트 하나를 저장하는 것은 원자성이 유지되기 때문에 이벤트 소싱을 이용해 원자성을 유지할 수 있습니다.</p><p>앞서 살펴본 예제에 적용해보겠습니다. 주문 서비스가 주문 테이블에 데이터를 저장했던 것과 달리 이벤트 소싱을 이용해서 상태를 변경하는 이벤트(<em>Created, Approved, Shipped, Cancelled</em>)를 저장합니다. 각 이벤트는 나중에 주문 상태를 재구성하기에 충분한 데이터를 가지고 있습니다. 이벤트 정보는 추가만 가능하고 수정이나 삭제는 할 수 없습니다.</p><p><img src="https://cdn.wp.nginx.com/wp-content/uploads/2015/12/Richardson-microservices-part5-event-sourcing-e1449711558668.png?_ga=2.226211730.983957787.1539764238-931831265.1536563442" alt="https://www.nginx.com/blog/event-driven-data-management-microservices/"></p><p>이벤트 스토어(<em>Event Store</em>)는 이벤트를 저장하는 DB 를 가지고 있고 이벤트를 저장 및 조회하기 위한 API 를 제공합니다. 그리고 이벤트 스토어는 이벤트를 전달하는 메시지 브로커의 역할도 합니다.</p><p>이 이벤트 스토어가 이벤트 주도 마이크로서비스의 핵심입니다. 상태를 저장하지 않고 이벤트를 저장함으로써 이벤트가 유실되지 않고 이벤트 스토어에서 이벤트를 관리하기 떄문에 여러 서비스에서 다른 값이 파편화되어 저장되는 것도 피할 수 있습니다. 게다가 따로 이력을 관리하는 테이블 없이도 특정 시점의 상태를 조회할 수 있습니다.</p><p>하지만 특정 시점의 데이터를 조회하기 위해서 전체 이벤트 내역을 게속해서 반복해야 한다면 비합리적이죠. 그래서 명령(데이터를 변경하는 <em>create, delete, update</em>)과 쿼리(데이터를 조회하는 <em>read</em>)의 책임을 분리하는 모델인 <a href="https://docs.microsoft.com/ko-kr/azure/architecture/patterns/cqrs">CQRS</a>(<em>Command Query Responsibility Segregation</em>, 명령 및 쿼리 책임 분리)를 사용해야 합니다. 간단하게 이벤트를 저장만하는 명령 모델과 복잡하게 데이터를 재구성해야 하는 쿼리 모델을 분리하고 쿼리 모델에서는 특정 시점 데이터를 스냅샷으로 기록해 데이터 재구성 작업이 줄어듭니다.</p><h2 id="참고">참고</h2><ul><li><a href="https://www.nginx.com/blog/event-driven-data-management-microservices/">Event-Driven Data Management for Microservices | NGINX Blog</a></li><li><a href="https://docs.microsoft.com/ko-kr/azure/architecture/patterns/cqrs">CQRS(명령 및 쿼리 책임 분리) 패턴 | Microsoft Azure</a></li></ul><h2 id="Related-Posts">Related Posts</h2><ul><li><a href="/2018/09/14/what-is-microservices-architecture/" title="마이크로서비스 Microservices (1) 아키텍처 소개">마이크로서비스 Microservices (1) 아키텍처 소개</a></li><li><a href="/2018/09/14/microservices-with-api-gateway/" title="마이크로서비스 Microservices (2) API 게이트웨이">마이크로서비스 Microservices (2) API 게이트웨이</a></li><li><a href="/2018/10/04/inter-process-communication-in-microservices/" title="마이크로서비스 Microservices (3) 프로세스 간 통신">마이크로서비스 Microservices (3) 프로세스 간 통신</a></li><li><a href="/2018/10/18/service-discovery-in-microservices/" title="마이크로서비스 Microservices (4) 서비스 디스커버리">마이크로서비스 Microservices (4) 서비스 디스커버리</a></li><li><a href="/2018/10/19/microservices-and-event-driven-data-management/" title="마이크로서비스 Microservices (5) 이벤트 주도 데이터 관리">마이크로서비스 Microservices (5) 이벤트 주도 데이터 관리</a></li><li><a href="/2018/10/19/microservices-deployment-strategy/" title="마이크로서비스 Microservices (6) 배포 전략">마이크로서비스 Microservices (6) 배포 전략</a></li><li><a href="/2018/10/19/microservices-refactoring-for-monolith/" title="마이크로서비스 Microservices (7) 모놀리스 리팩토링">마이크로서비스 Microservices (7) 모놀리스 리팩토링</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h2 id=&quot;분산-데이터-관리의-어려움&quot;&gt;분산 데이터 관리의 어려움&lt;/h</summary>
      
    
    
    
    <category term="Programming" scheme="https://futurecreator.github.io/categories/Programming/"/>
    
    <category term="MSA" scheme="https://futurecreator.github.io/categories/Programming/MSA/"/>
    
    
    <category term="microservices" scheme="https://futurecreator.github.io/tags/microservices/"/>
    
    <category term="event_driven" scheme="https://futurecreator.github.io/tags/event-driven/"/>
    
    <category term="event_sourcing" scheme="https://futurecreator.github.io/tags/event-sourcing/"/>
    
    <category term="cqrs" scheme="https://futurecreator.github.io/tags/cqrs/"/>
    
    <category term="data_management" scheme="https://futurecreator.github.io/tags/data-management/"/>
    
  </entry>
  
  <entry>
    <title>마이크로서비스 Microservices (6) 배포 전략</title>
    <link href="https://futurecreator.github.io/2018/10/19/microservices-deployment-strategy/"/>
    <id>https://futurecreator.github.io/2018/10/19/microservices-deployment-strategy/</id>
    <published>2018-10-19T12:39:42.000Z</published>
    <updated>2025-03-14T16:10:24.208Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="마이크로서비스-배포-전략">마이크로서비스 배포 전략</h2><p>모놀리식 애플리케이션은 통째로 배포되기 때문에 애플리케이션 복사본을 여러 개 실행하는 형식으로 배포합니다. 따라서 N개의 서버에 M개의 애플리케이션 인스턴스가 실행됩니다. 마이크로서비스 배포에 비하면 단순하죠.</p><p>마이크로서비스 애플리케이션은 수십에서 수백 개의 서비스로 이루어져 있습니다. 각 서비스는 다양한 언어와 프레임워크로 만들어져있고 각 서비스는 독립적으로 배포, 스케일링, 모니터링 되고 각자의 리소스를 사용합니다. 각 서비스가 하나의 작은 애플리케이션이라고 볼 수 있습니다.</p><p>이런 마이크로서비스 애플리케이션을 어떻게 하면 빠르고 안정적이면서 비용효율적으로 배포할 수 있을까요?</p><h2 id="호스트-하나에-여러-개의-서비스-배포">호스트 하나에 여러 개의 서비스 배포</h2><p>첫 번째 방법은 (물리적 또는 가상의)호스트 하나에 서비스를 여러 개 배포하는 패턴입니다. 가장 쉽게 생각해볼 수 있는 방법이죠. 각 호스트는 고정적이기 때문에 네트워크 정보를 알고 있는 상태입니다.</p><p><img src="https://www.nginx.com/wp-content/uploads/2016/02/Richardson-microservices-architecture-part6-host-1002x1024.png" alt="https://www.nginx.com/blog/deploying-microservices/"></p><p>이런 구조에서는 각 서비스 인스턴스가 하나의 프로세스로서 같은 같은 호스트의 자원을 공유할 수 있습니다. 예를 들어 여러 웹 애플리케이션이 같은 Apache Tomcat 서버와 JVM 을 공유할 수 있어 자원을 효율적으로 사용할 수 있습니다. 그리고 쉽고 빠르게 배포할 수 있습니다. 자바의 경우 JAR 나 WAR 파일을 복사하기만 하면 되고 Node.js 나 Ruby 의 경우 소스 코드를 복사하기만 하면 됩니다. 실행 또한 간단합니다.</p><p>이렇게 하나로 묶여있는 것은 양날의 검입니다. 각 서비스 인스턴스는 프로세스로 분리되어있다 하더라도 완전히 분리시킬 수는 없습니다. 각 서비스 별로 자원을 제한할 수 없기 때문에 특정 서비스가 CPU나 메모리 등 자원을 많이 소비한다면 다른 서비스에 영향을 주게 됩니다.</p><p>운영 측면에서 보자면 하나의 운영팀이 서버를 관리하기 때문에 각 서비스 별로 다른 배포 방법을 모두 알고 있어야 합니다. 이런 복잡함 때문에 배포 중 에러가 발생할 확률이 높습니다.</p><h2 id="호스트마다-서비스-하나씩-배포">호스트마다 서비스 하나씩 배포</h2><p>두 번째 방법은 호스트마다 서비스를 하나씩만 배포하는 패턴입니다. 호스트를 분리시켜서 각 서비스를 분리해놓은 방식입니다. 이 호스트를 가상 머신(<em>Virtual Machine, VM</em>)과 컨테이너(<em>Container</em>)에 따라 나눠 살펴보겠습니다.</p><h3 id="가상-머신-기반">가상 머신 기반</h3><p>각 서비스는 VM 이미지로 패키징 되고 이 VM 이미지를 이용해서 VM 상에서 동작하는 서비스 인스턴스를 배포합니다. 예를 들어 AMI(<em>Amazon Machine Image</em>)를 이용해 서비스 인스턴스가 실행되는 EC2 인스턴스를 생성하는 식이죠.</p><p><img src="https://www.nginx.com/wp-content/uploads/2016/02/Richardson-microservices-architecture-part6-vm.png" alt="https://www.nginx.com/blog/deploying-microservices/"></p><p>이 방식은 Netflix 가 스트리밍 서비스를 배포하는 방식이기도 합니다. 각 서비스를 <a href="https://github.com/Netflix/aminator">Aminator</a> 를 이용해서 EC2 AMI 로 패키징해서 각 서비스는 EC2 인스턴스 위에서 동작하게 됩니다.</p><p>이런 툴을 사용하면 자신만의 VM 을 쉽게 만들 수 있습니다. <a href="https://jenkins-ci.org">Jenkins</a> 같은 CI(<em>Continuous Integration</em>) 서버에서 빌드 과정에 Animator 를 포함시켜서 서비스를 EC2 AMI 로 패키징할 수도 있습니다. <a href="https://www.packer.io/">Packer.io</a> 는 Animator 와 달리 EC2 뿐만 아니라 DigitalOcean, VirtualBox, VMware 같은 다양한 가상화 기술을 지원합니다. 자바 애플리케이션이라면 <a href="https://boxfuse.com/">Boxfuse</a> 를 고려해볼 수도 있습니다.</p><p>호스트에 여러 서비스를 배포하던 방식과 달리 각 서비스가 호스트별로 나뉘어져 캡슐화되었습니다. 자원을 따로 쓰기 때문에 한 서비스가 자원을 많이 먹어도 다른 서비스에 영향이 없습니다. 그리고 마이크로서비스는 클라우드 환경과 아주 잘 맞는데다가 AWS 같은 클라우드에서 제공하는 유용한 기능(로드밸런싱, 오토스케일링)을 사용할 수 있습니다. VM 이미지를 이용해서 블랙박스처럼 배포하기 때문에 훨씬 더 간단하고 안정적으로 배포할 수 있습니다.</p><p>하지만 VM 자체가 가지는 한계가 있습니다. VM 은 운영체제를 포함하고 있는데, 이 때문에 이미지 크기도 커지고 실행 시간도 더 소요됩니다. 시작 시 운영 체제를 시작하는 시간도 필요합니다. 그리고 IaaS 에서 제공하는 VM 은 크기가 고정되어 있어 유연하게 사용하기 어렵습니다. 따라서 오토스케일링 시 시간도 더 소요되고 자원 활용의 효율성도 떨어집니다.</p><h3 id="컨테이너-기반">컨테이너 기반</h3><p>VM 대신 각 서비스를 컨테이너에 올리는 방식입니다. 컨테이너는 운영 체제 수준 가상화(<em>operating-system-level virtualization</em>) 방식으로 운영체제 커널을 공유합니다. 따라서 각자 OS 를 가지고 있는 VM 과 달리 하나의 OS 에 여러 컨테이너가 올라가게 되므로 크기도 작고 리소스를 훨씬 적게 사용합니다. 컨테이너는 프로세스를 묶어서 샌드박스 형태로 제공하고 각자의 포트 네임스페이스와 파일 시스템을 가지고 있습니다. 컨테이너 별로 메모리와 CPU 등 리소스를 제한할 수도 있죠. 대표적으로는 <a href="https://www.docker.com/">Docker</a> 가 있습니다.</p><p><img src="container.png" alt="https://docs.docker.com/get-started/#containers-and-virtual-machines"></p><p>서비스를 컨테이너 이미지로 패키징해서 하나의 호스트 안에 여러 컨테이너를 실행할 수 있습니다. 그리고 <a href="http://kubernetes.io/">Kubernetes</a> 같은 클러스터 매니저를 이용해 컨테이너를 관리할 수 있습니다.</p><p><img src="https://www.nginx.com/wp-content/uploads/2016/02/Richardson-microservices-architecture-part6-container.png" alt="https://www.nginx.com/blog/deploying-microservices/"></p><p>컨테이너를 사용하면 VM 의 장점을 활용하면서 단점을 보완할 수 있습니다. VM 에 비해 빠르고 경량화된 기술로 컨테이너 이미지는 매우 빠르게 빌드되고 OS 부팅 없이 빠르게 실행됩니다. 하지만 OS 커널을 공유하기 때문에 안전하지 않은 단점이 있습니다.</p><h2 id="서버리스-배포">서버리스 배포</h2><p>서버리스 배포(<em>Serverless Deployment</em>) 방식은 VM 이나 컨테이너와는 또 다른 방식입니다. <a href="https://aws.amazon.com/lambda/">AWS Lambda</a> 가 대표적인 예인데요. 마이크로서비스를 배포하기 위해서는 각 서비스를 패키징한 압축파일(<em>ZIP</em>)을 메타 데이터와 함께 AWS Lambda 에 업로드만 하면 됩니다. 서버리스는 실제 서버가 없는 것은 아니지만 서버, VM, 컨테이너 등에 대해서 고민하지 않고 애플리케이션 개발에 집중할 수 있어서 서버가 없다(<em>serverless</em>)라고 표현합니다. 그리고 시간과 메모리, 네트워크 등 사용량에 따라 비용을 지불합니다.</p><p>여기서 각 서비스는 람다 함수(<em>Lambda function</em>)가 됩니다. 람다 함수는 상태를 저장하지 않는(<em>stateless</em>) 서비스로 몇 가지 요청이 있을 때 실행됩니다.</p><ul><li>웹 서비스 요청을 이용해 <strong>직접</strong> 실행</li><li>다른 AWS 서비스(<em>S3, DynamoDB, SES</em> 등)에서 발생하는 요청에 의해 <strong>자동</strong> 실행(이벤트처럼).</li><li>API 게이트웨이가 HTTP 요청을 받아서 해당 람다함수를 <strong>자동</strong>으로 실행</li><li>스케줄러를 이용해 <strong>주기적으로</strong> 실행</li></ul><p>마이크로서비스를 배포하기 편리하고 좋은 방법이지만 각 서비스가 상태를 저장할 수 없다는 점에 주의해야 합니다. 요청이 있을 때마다 별도의 인스턴스가 실행되는 방식이죠. 써드파티 메시지 브로커에서 메시지를 받는 방식과는 맞지 않고 AWS Lambda 에서 지원하는 언어만 사용해야 하는 것도 제약사항입니다. 마지막으로 각 서비스는 작은 단위로 빠르게 실행되지 않으면 타임 아웃으로 종료되니 주의해야 합니다.</p><h2 id="참고">참고</h2><ul><li><a href="https://www.nginx.com/blog/deploying-microservices/">Choosing a Microservices Deployment Strategy | NGINX blog</a></li><li><a href="https://docs.aws.amazon.com/ko_kr/lambda/latest/dg/welcome.html">AWS Lambda 란 무엇입니까? | AWS Docs</a></li></ul><h2 id="Related-Posts">Related Posts</h2><ul><li><a href="/2018/09/14/what-is-microservices-architecture/" title="마이크로서비스 Microservices (1) 아키텍처 소개">마이크로서비스 Microservices (1) 아키텍처 소개</a></li><li><a href="/2018/09/14/microservices-with-api-gateway/" title="마이크로서비스 Microservices (2) API 게이트웨이">마이크로서비스 Microservices (2) API 게이트웨이</a></li><li><a href="/2018/10/04/inter-process-communication-in-microservices/" title="마이크로서비스 Microservices (3) 프로세스 간 통신">마이크로서비스 Microservices (3) 프로세스 간 통신</a></li><li><a href="/2018/10/18/service-discovery-in-microservices/" title="마이크로서비스 Microservices (4) 서비스 디스커버리">마이크로서비스 Microservices (4) 서비스 디스커버리</a></li><li><a href="/2018/10/19/microservices-and-event-driven-data-management/" title="마이크로서비스 Microservices (5) 이벤트 주도 데이터 관리">마이크로서비스 Microservices (5) 이벤트 주도 데이터 관리</a></li><li><a href="/2018/10/19/microservices-deployment-strategy/" title="마이크로서비스 Microservices (6) 배포 전략">마이크로서비스 Microservices (6) 배포 전략</a></li><li><a href="/2018/10/19/microservices-refactoring-for-monolith/" title="마이크로서비스 Microservices (7) 모놀리스 리팩토링">마이크로서비스 Microservices (7) 모놀리스 리팩토링</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h2 id=&quot;마이크로서비스-배포-전략&quot;&gt;마이크로서비스 배포 전략&lt;/h2&gt;</summary>
      
    
    
    
    <category term="Programming" scheme="https://futurecreator.github.io/categories/Programming/"/>
    
    <category term="MSA" scheme="https://futurecreator.github.io/categories/Programming/MSA/"/>
    
    
    <category term="deployment" scheme="https://futurecreator.github.io/tags/deployment/"/>
    
    <category term="microservices" scheme="https://futurecreator.github.io/tags/microservices/"/>
    
    <category term="strategy" scheme="https://futurecreator.github.io/tags/strategy/"/>
    
    <category term="virtual_machine" scheme="https://futurecreator.github.io/tags/virtual-machine/"/>
    
    <category term="container" scheme="https://futurecreator.github.io/tags/container/"/>
    
    <category term="docker" scheme="https://futurecreator.github.io/tags/docker/"/>
    
    <category term="kubernetes" scheme="https://futurecreator.github.io/tags/kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>마이크로서비스 Microservices (4) 서비스 디스커버리</title>
    <link href="https://futurecreator.github.io/2018/10/18/service-discovery-in-microservices/"/>
    <id>https://futurecreator.github.io/2018/10/18/service-discovery-in-microservices/</id>
    <published>2018-10-18T12:46:04.000Z</published>
    <updated>2025-03-14T16:10:24.208Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="서비스-디스커버리">서비스 디스커버리</h2><p>REST API 를 이용해서 다른 서비스를 호출한다고 해봅시다. 요청을 보내기 위해서는 서비스 인스턴스가 있는 곳의 네트워크 정보를 알아야 합니다. IP 주소와 포트 정보가 되겠죠. 물리적 서버에서 돌아가는 경우라면 미리 설정 파일로 빼서 관리할 수 있으므로 큰 문제는 없습니다.</p><p>하지만 클라우드에서는 어떨까요?</p><p><img src="https://www.nginx.com/wp-content/uploads/2016/04/Richardson-microservices-part4-1_difficult-service-discovery.png" alt="https://www.nginx.com/blog/service-discovery-in-a-microservices-architecture/"></p><p>클라우드에서 인스턴스는 동적으로 할당되기 때문에 IP주소나 포트 정보가 정해지지 않은 데다가 오토스케일링도 일어나고 중지되고 복구되면서 네트워크 위치가 계속해서 바뀌게 됩니다.</p><p>따라서 클라이언트나 API 게이트웨이가 호출할 서비스를 찾는 매커니즘이 필요하고 이를 서비스 디스커버리(<em>Service Discovery</em>)라고 합니다. 이러한 로직을 구현하는 쪽에 따라서 두 가지 방식으로 나뉩니다.</p><ul><li><a href="https://microservices.io/patterns/client-side-discovery.html">클라이언트 사이드 디스커버리 패턴</a>(<em>Client-Side Discovery Pattern</em>)</li><li><a href="https://microservices.io/patterns/server-side-discovery.html">서버 사이드 디스커버리 패턴</a>(<em>Server-Side Discovery Pattern</em>)</li></ul><h3 id="클라이언트-사이드-디스커버리">클라이언트 사이드 디스커버리</h3><p>서비스 인스턴스의 네트워크 위치를 찾고 로드밸런싱하는 역할을 클라이언트가 담당하는 방식입니다.</p><p><img src="https://www.nginx.com/wp-content/uploads/2016/04/Richardson-microservices-part4-2_client-side-pattern.png" alt="https://www.nginx.com/blog/service-discovery-in-a-microservices-architecture/"></p><p>서비스 인스턴스는 시작될 때 자신의 네트워크 주소를 서비스 레지스트리(<em>Service Registry</em>)에 등록하고, 서비스 레지스트리는 각 서비스 인스턴스의 상태를 계속해서 체크합니다. 클라이언트는 서비스 레지스트리에 등록된 인스턴스 중 하나를 골라서 요청을 보내는 방식으로 로드밸런싱이 이루어집니다. 인스턴스가 종료되면 서비스 레지스트리에 등록된 정보는 삭제됩니다.</p><p><a href="https://netflix.github.io/">Netflix OSS</a> 가 클라이언트 사이드 디스커버리 패턴의 좋은 예입니다. <a href="https://github.com/Netflix/eureka">Netflix Eureka</a> 는 서비스 레지스트리로 서비스 인스턴스의 등록과 가용한 인스턴스를 찾는 REST API 를 제공합니다. <a href="https://github.com/Netflix/ribbon">Netflix Ribbon</a> 은 Eureka 와 같이 동작하는 IPC 클라이언트로 가능한 서비스 인스턴스 간 로드밸런싱을 해줍니다.</p><p>이러한 방식의 장점은 서비스 디스커버리 로직을 클라이언트가 가지고 있기 때문에 서비스에 맞는 로드밸런싱 방식을 각자 구현할 수 있다는 점입니다. 하지만 반대로 각 서비스마다 서비스 레지스트리를 구현해야 하는 종속성이 생깁니다. 만약 서비스마다 다른 언어를 사용하고 있다면 언어별 또는 프레임워크별로 구현해야겠죠.</p><h3 id="서버-사이드-디스커버리">서버 사이드 디스커버리</h3><p>이번엔 반대로 서버 쪽에서 디스커버리 로직을 구현한 방식입니다.</p><p><img src="https://www.nginx.com/wp-content/uploads/2016/04/Richardson-microservices-part4-3_server-side-pattern.png" alt="https://www.nginx.com/blog/service-discovery-in-a-microservices-architecture/"></p><p>클라이언트는 로드밸런서로 요청을 보냅니다. 로드밸런서는 서비스 레지스트리를 조회해서 가용한 인스턴스를 찾고 그 중 선택해서 요청을 라우팅하는 방식입니다. 서비스 레지스트리에 등록되는 방식은 클라이언트에 있을 때와 같습니다.</p><p><a href="https://aws.amazon.com/elasticloadbalancing/">AWS Elastic Load Balancer</a>(<em>ELB</em>)가 서버 사이드 서비스 디스커버리 패턴의 좋은 예입니다. ELB는 일반적으로 인터넷에서 들어오는 외부 트래픽을 로드밸런싱하는 데 사용되고, VPC(<em>Virtual Private Cloud</em>)에서 내부 트래픽을 처리할 때 사용되기도 합니다. 클라이언트에서 DNS 이름을 이용해 ELB로 요청(<em>HTTP</em> 또는 <em>TCP</em>)을 보내면 ELB는 등록된 EC2(<em>Elastic Compute Cloud</em>) 인스턴스나 ECS(<em>EC2 Container Service</em>) 컨테이너 사이에서 부하를 분산합니다. 여기서 서비스 레지스트리 역할도 ELB가 합니다.</p><p><a href="https://github.com/kubernetes/kubernetes/">Kubernetes</a> 와 <a href="https://mesosphere.github.io/marathon/docs/service-discovery-load-balancing.html">Marathon</a> 같은 환경에서는 클러스트 내 호스트 별로 프록시(<em>proxy</em>)를 실행합니다. 이 프록시는 서버 쪽 서비스 디스커버리의 역할을 하는데요, 클러스트 내에 가용한 서비스 인스턴스로 요청을 포워딩합니다.</p><p>서버 사이드 서비스 디스커버리 방식은 디스커버리 로직을 클라이언트에서 분리할 수 있습니다. 따라서 클라이언트 쪽에선 이런 로직을 몰라도 되고 따로 구현할 필요도 없습니다. 그리고 위에서 언급한 몇몇 배포 환경에서는 이런 로직을 무료로 제공하고 있습니다. 반면에 이 서비스 디스커버리가 죽으면 전체 시스템이 동작하지 않기 때문에 고가용성 등 더 많은 관리가 필요합니다.</p><h2 id="서비스-레지스트리">서비스 레지스트리</h2><p>서비스 레지스트리는 각 서비스 인스턴스의 네트워크 위치 정보를 저장하는 데이터베이스로 항상 최신 정보를 유지해야 하며 고가용성이 필요합니다.</p><p>앞서 얘기한 서비스 레지스트리인 <a href="https://github.com/Netflix/eureka">Netflix Eureka</a> 는 서비스 인스턴스를 등록하고 조회하는 API를 제공합니다. 각 서비스 인스턴스는 <code>POST</code> 요청으로 자신의 네트워크 위치를 등록하고 30초마다 <code>PUT</code> 요청으로 자신의 정보를 갱신해야 합니다. 등록된 서비스 정보는 <code>DELETE</code> 요청이나 타임 아웃으로 삭제됩니다. 그리고 등록된 서비스 정보는 <code>GET</code> 요청으로 조회할 수 있습니다.</p><p>Netflix 는 Eureka 서비스를 여러 개의 Amazon EC2 위에 실행하고 가용 영역(<em>Availability Zones</em>)에 배포합니다. 이렇게 여러 인스턴스가 각자 격리된 위치에서 실행되도록 구성하면 고가용성을 유지할 수 있습니다. 각 Eureka 서버가 실행되는 EC2 인스턴스는 Elastic IP 주소를 가지고 있고 DNS 의 <code>TEXT</code> 레코드는 클러스터 정보를 저장합니다. Eureka 서버가 시작되면 DNS 에 Eureka 클러스터 설정 정보를 조회하고 사용하지 않는 주소에 스스로 Elastic IP 를 할당합니다.</p><p>따라서 Eureka 클라이언트는 DNS 를 이용해 Eureka 서버의 네트워크 위치를 조회할 수 있습니다. 같은 가용 영역에 있는 Eureka 서버에 먼저 접속하겠지만 가능한 인스턴스가 없으면 다른 가용 영역의 인스턴스에 접속하게 됩니다.</p><p>서비스 레지스트리를 사용하는 다른 예는 다음과 같습니다.</p><ul><li><a href="https://github.com/coreos/etcd">etcd</a></li><li><a href="https://www.consul.io/">consul</a></li><li><a href="http://zookeeper.apache.org/">Apache Zookeeper</a></li></ul><h2 id="서비스-등록">서비스 등록</h2><p>마지막으로 서비스 등록 패턴에 대해 살펴보겠습니다. 각 서비스는 서비스 레지스트리에 각자의 정보를 등록하고 해제해야 한다고 설명드렸는데요, 여기에는 두 가지 방식이 있습니다.</p><ul><li><a href="https://microservices.io/patterns/self-registration.html">셀프 등록 패턴</a> (<em>Self Registration Pattern</em>) : 서비스 스스로 등록을 관리.</li><li><a href="https://microservices.io/patterns/3rd-party-registration.html">써드 파티 등록 패턴</a> (<em>3rd Party Registration Pattern</em>) : 제3의 시스템에서 등록을 관리.</li></ul><h3 id="셀프-등록-패턴">셀프 등록 패턴</h3><p>등록과 관리를 하는 주체가 서비스인 방식입니다. 각 서비스는 서비스 레지스트리에 자신의 정보를 등록하고, 필요하다면 주기적으로 자신이 살아있다는 신호(<em>heartbeat</em>)를 계속 전송합니다. 만약 이 정보가 일정 시간이 지나도 오지 않는다면 서비스에 문제가 발생한 것으로 보고 등록이 해제될 겁니다. 그리고 서비스가 종료될 때는 등록을 해제합니다.</p><p><img src="https://www.nginx.com/wp-content/uploads/2016/04/Richardson-microservices-part4-4_self-registration-pattern.png" alt="https://www.nginx.com/blog/service-discovery-in-a-microservices-architecture/"></p><p>앞서 살펴본 Eureka 클라이언트가 이에 해당합니다. Spring Cloud project 에서는 <code>@EnableEurekaClinet</code> 어노테이션을 이용해 쉽게 구현할 수 있습니다.</p><p>이 방식은 다른 컴포넌트 없이 간단하게 구성할 수 있다는 장점이 있지만 각 서비스에서 서비스 등록 로직을 구현해야 한다는 단점이 있습니다.</p><h3 id="써드-파티-등록-패턴">써드 파티 등록 패턴</h3><p>대신 외부에서 서비스 등록을 관리하는 방법이 있습니다. 서비스 등록을 관리하는 서비스 레지스트라(<em>Service Registrar</em>)를 따로 두는 것이죠. 서비스 레지스트라는 각 서비스 인스턴스의 변화를 폴링(<em>polling</em>) 이나 이벤트 구독으로 감지해서 서비스 레지스트리에 계속 업데이트합니다.</p><p><img src="https://www.nginx.com/wp-content/uploads/2016/04/Richardson-microservices-part4-5_third-party-pattern.png" alt="https://www.nginx.com/blog/service-discovery-in-a-microservices-architecture/"></p><p>이런 방식의 예로는 <a href="https://github.com/gliderlabs/registrator">Registrator</a>가 있습니다. Docker 컨테이너로 배포된 서비스 인스턴스의 등록을 관리하는 오픈소스 프로젝트입니다. etcd 와 Consul 를 포함해 여러 서비스 레지스트리를 지원합니다.</p><p>다른 예로는 <a href="https://github.com/netflix/Prana">NetflixOSS Prana</a> 가 있습니다. 기본적으로 non-JVM 언어로 작성된 서비스를 위해서 만들어진 애플리케이션으로 애플리케이션과 함께 실행되는 방식입니다(<em>sidecar application</em>). Eureka 서비스 인스턴스를 등록 및 해제하는 역할을 합니다. 이 외에도 배포 환경에 내장된 서비스 레지스트라를 사용할 수도 있습니다.</p><p>이런 방식의 장점은 서비스에서 서비스 등록 및 관리 로직을 분리할 수 있다는 점, 중앙에서 통제가 가능하다는 점이고 반대로 서비스 레지스트라가 멈추면 안되기 때문에 고가용성 등 더 많은 관리가 필요한 단점도 있습니다.</p><h2 id="참고">참고</h2><ul><li><a href="https://www.nginx.com/blog/service-discovery-in-a-microservices-architecture/">Service Discovery in a Microservices Architecture | NGINX Blog</a></li></ul><h2 id="Related-Posts">Related Posts</h2><ul><li><a href="/2018/09/14/what-is-microservices-architecture/" title="마이크로서비스 Microservices (1) 아키텍처 소개">마이크로서비스 Microservices (1) 아키텍처 소개</a></li><li><a href="/2018/09/14/microservices-with-api-gateway/" title="마이크로서비스 Microservices (2) API 게이트웨이">마이크로서비스 Microservices (2) API 게이트웨이</a></li><li><a href="/2018/10/04/inter-process-communication-in-microservices/" title="마이크로서비스 Microservices (3) 프로세스 간 통신">마이크로서비스 Microservices (3) 프로세스 간 통신</a></li><li><a href="/2018/10/18/service-discovery-in-microservices/" title="마이크로서비스 Microservices (4) 서비스 디스커버리">마이크로서비스 Microservices (4) 서비스 디스커버리</a></li><li><a href="/2018/10/19/microservices-and-event-driven-data-management/" title="마이크로서비스 Microservices (5) 이벤트 주도 데이터 관리">마이크로서비스 Microservices (5) 이벤트 주도 데이터 관리</a></li><li><a href="/2018/10/19/microservices-deployment-strategy/" title="마이크로서비스 Microservices (6) 배포 전략">마이크로서비스 Microservices (6) 배포 전략</a></li><li><a href="/2018/10/19/microservices-refactoring-for-monolith/" title="마이크로서비스 Microservices (7) 모놀리스 리팩토링">마이크로서비스 Microservices (7) 모놀리스 리팩토링</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h2 id=&quot;서비스-디스커버리&quot;&gt;서비스 디스커버리&lt;/h2&gt;
&lt;p&gt;REST</summary>
      
    
    
    
    <category term="Programming" scheme="https://futurecreator.github.io/categories/Programming/"/>
    
    <category term="MSA" scheme="https://futurecreator.github.io/categories/Programming/MSA/"/>
    
    
    <category term="aws" scheme="https://futurecreator.github.io/tags/aws/"/>
    
    <category term="msa" scheme="https://futurecreator.github.io/tags/msa/"/>
    
    <category term="microservices" scheme="https://futurecreator.github.io/tags/microservices/"/>
    
    <category term="service_discovery" scheme="https://futurecreator.github.io/tags/service-discovery/"/>
    
    <category term="netflix" scheme="https://futurecreator.github.io/tags/netflix/"/>
    
  </entry>
  
  <entry>
    <title>함수형 프로그래밍 기초 (2) 필터, 맵, 폴드(리듀스)</title>
    <link href="https://futurecreator.github.io/2018/10/07/functional-programming-filter-map-fold-reduce/"/>
    <id>https://futurecreator.github.io/2018/10/07/functional-programming-filter-map-fold-reduce/</id>
    <published>2018-10-06T16:08:28.000Z</published>
    <updated>2025-03-14T16:10:24.208Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="함수형-접근">함수형 접근</h2><p>함수형 프로그래밍 언어의 문법을 배우는 것은 쉽습니다. 하지만 함수형으로 생각하는 방법을 익히는 것은 쉽지 않습니다. Java 에서 Scala 나 Clojure 로 바꾸는 것보다 문제에 접근하는 방식을 바꾸는 것이 더 중요합니다.</p><p>함수형 프로그래밍은 좀 더 추상화된 레벨에서 코딩할 수 있도록 합니다. 이게 어떤 의미인지 간단한 예제로 살펴보겠습니다. 우리가 구현할 로직은 다음과 같습니다.</p><p>이름을 담은 String List 를 받아서</p><ul><li>이름이 한 글자가 넘는 이름들 중에</li><li>각 이름을 첫 글자만 대문자로 변형하고</li><li>쉼표(,)로 구분한 하나의 문자열로 변환한다.</li></ul><p>그래서 만약 입력 값이 “tony”, “a”, “steve”, “captain” 라면 반환값은 “Tony,Steve,Captain”이라는 문자열이 됩니다.</p><h3 id="일반적인-처리">일반적인 처리</h3><p>먼저 자바로 로직을 구현해봅시다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TheCompanyProcess</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">cleanNames</span><span class="params">(List&lt;String&gt; names)</span> &#123;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="keyword">for</span> (String name : names) &#123;</span><br><span class="line">      <span class="keyword">if</span> (name.length() &gt; <span class="number">1</span>)</span><br><span class="line">        result.append(capitalizeString(name)).append(<span class="string">&quot; ,&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result.substring(<span class="number">0</span>, result.length() - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String <span class="title function_">capitalizeString</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> s.substring(<span class="number">0</span>, <span class="number">1</span>).toUpperCase() + s.substring(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>어려운 로직은 아니죠. 코드를 자세히 살펴보면 작성한 로직을 다음 세 개의 그룹으로 묶어서(추상화) 생각해 볼 수 있습니다.</p><ul><li>한 글자 이름을 걸러내고(<em>filter</em>)</li><li>이름 첫 글자를 대문자로 변형하고(<em>transform</em>)</li><li>쉼표로 구분한 하나의 문자열로 변환한다(<em>convert</em>)</li></ul><h3 id="함수형-처리">함수형 처리</h3><p>함수형 프로그래밍에서는 이러한 필터, 변경, 변환하는 작업을 쉽게 할 수 있도록 해줍니다. 해당 작업을 루프 안에서 직접 기술하는 것이 아니라 추상화된 메소드(filter, transform, convert)를 이용해 작업할 수 있고, 세부 사항에 대한 내용은 함수를 인자로 넘겨줘서 처리할 수 있습니다. 의사코드를 한번 볼까요?</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">listOfNames</span><br><span class="line">  -&gt; filter(x.length &gt; 1)</span><br><span class="line">  -&gt; transform(x.capitalize)</span><br><span class="line">  -&gt; convert(x + &quot;,&quot; + y)</span><br></pre></td></tr></table></figure><p>위에서 작성했던 일반적인 코드와 다른 점이 보이시나요? 우리가 풀어야 할 문제에 대해 더 추상적인 레벨에서 접근할 수 있고, 세부적으로 처리해야 하는 작업의 내용은 함수 인자(람다)를 이용해 전달합니다.</p><p>이 개념을 스칼라로 구현해보겠습니다.</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> employees = <span class="type">List</span>(<span class="string">&quot;tony&quot;</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;steve&quot;</span>, <span class="string">&quot;captain&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;thor&quot;</span>, <span class="string">&quot;hulk&quot;</span>, <span class="string">&quot;c&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> result = employees</span><br><span class="line">  .filter(_.length &gt; <span class="number">1</span>)</span><br><span class="line">  .map(_.capitalize)</span><br><span class="line">  .reduce(_ + <span class="string">&quot;,&quot;</span> + _)</span><br></pre></td></tr></table></figure><p>의사코드와 거의 똑같습니다. 아주 간결하고 쉽게 읽히죠. 물론 함수의 이름은 <code>map</code> 이나 <code>reduce</code> 로 바뀌었지만 역할은 같습니다. 그리고 인자로 넘어가는 함수 모두 사용하는 변수의 이름은 크게 상관이 없기 때문에 스칼라에서는 이름을 생략하고 언더바(<code>_</code>)를 사용합니다.</p><p>이번엔 자바 8을 이용해 구현해보겠습니다. 자바는 스트림을 이용해서 처리할 수 있습니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">cleanNamesWithJava8</span><span class="params">(List&lt;String&gt; names)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (names == <span class="literal">null</span>) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> names.stream()</span><br><span class="line">    .filter(name -&gt; name.length() &gt; <span class="number">1</span>)</span><br><span class="line">    .map(<span class="built_in">this</span>::capitalize)</span><br><span class="line">    .collect(Collectors.joining(<span class="string">&quot;,&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String <span class="title function_">capitalize</span><span class="params">(String s)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> s.substring(<span class="number">0</span>, <span class="number">1</span>).toUpperCase() + s.substring(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이번엔 Groovy 로 작성해볼까요? <code>findAll</code> 을 이용해서 해당 조건을 만족하는 요소를 걸러내고 <code>map</code>의 그루비 버전인 <code>collect</code> 를 이용해서 맵핑하고 <code>join</code> 을 이용해 하나의 문자열로 변환합니다. 스칼라처럼 인자를 간단하게 치환하는데 그루비에서는 <code>it</code> 라는 키워드를 사용합니다.</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TheCompanyProcess</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> String cleanNames(listOfNames) &#123;</span><br><span class="line">    listOfNames</span><br><span class="line">    .findAll &#123; it.length() &gt; <span class="number">1</span> &#125;</span><br><span class="line">    .collect &#123; it.capitalize() &#125;</span><br><span class="line">    .join <span class="string">&#x27;,&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>마지막으로 클로저를 살펴보겠습니다. 클로저가 익숙하지 않으면 코드를 읽기 어려울 수 있습니다. 😅 하지만 자세한 문법을 몰라도 어떤 식으로 이루어졌는지는 살펴볼 수 있습니다. 클로저는 안에서 밖으로 실행됩니다. 그래서 제일 안쪽인 매개변수 <code>list-of-emps</code>  부터 시작해서 <code>(filter )</code>, <code>(map )</code>, <code>(reduce )</code> 순으로 실행됩니다.</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">ns</span></span> trans.core</span><br><span class="line">  (<span class="symbol">:require</span> [clojure.string <span class="symbol">:as</span> s]))</span><br><span class="line"></span><br><span class="line">(<span class="keyword">defn</span> <span class="title">process</span> [list-of-emps]</span><br><span class="line">  (<span class="name"><span class="built_in">reduce</span></span> str (<span class="name">interpose</span> <span class="string">&quot;,&quot;</span></span><br><span class="line">    (<span class="name"><span class="built_in">map</span></span> s/capitalize (<span class="name"><span class="built_in">filter</span></span> #(<span class="name"><span class="built_in">&lt;</span></span> <span class="number">1</span> (<span class="name"><span class="built_in">count</span></span> %)) list-of-emps)))))</span><br></pre></td></tr></table></figure><p>참고로 클로저에서는 이렇게 함수가 중첩되면 알아보기 어려워지기 때문에 thread-last(<code>-&gt;&gt;</code>)라는 매크로를 이용해서 가독성을 높일 수 있습니다. 이렇게 되면 왼쪽에서 오른쪽으로 실행되는 순서가 바뀝니다.</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">defn</span> <span class="title">process2</span> [list-of-emps]</span><br><span class="line">  (<span class="name"><span class="built_in">-&gt;&gt;</span></span> list-of-emps</span><br><span class="line">       (<span class="name"><span class="built_in">filter</span></span> #(<span class="name"><span class="built_in">&lt;</span></span> <span class="number">1</span> (<span class="name"><span class="built_in">count</span></span> %)))</span><br><span class="line">       (<span class="name"><span class="built_in">map</span></span> s/capitalize)</span><br><span class="line">       (<span class="name">interpose</span> <span class="string">&quot;,&quot;</span>)</span><br><span class="line">       (<span class="name"><span class="built_in">reduce</span></span> str)))</span><br></pre></td></tr></table></figure><p>지금까지 일반적으로 작성한 코드와 함수형으로 작성한 의사코드, 그리고 의사코드를 구현한 코드를 살펴봤습니다. 자바, 스칼라, 그루비, 클로저 모두 함수 이름이나 문법은 조금씩 달랐지만 함수형 프로그래밍의 주요 개념을  포함하고 있습니다.</p><p>함수형으로 작성하면 더 추상적인 레벨에서 코드를 작성할 수 있습니다. 이렇게 추상적으로 작업을 하면 코드가 간결할 뿐만 아니라 런타임에서 최적화를 해줘서 성능을 높여주고 엔진 레벨에서 처리해야 하는 코드에 신경쓰지 않게 도와줍니다. 예를 들어 쓰레드를 이용해 병렬 처리를 해야 할 경우엔 <code>par</code> 를 붙여서 병렬 스트림을 만들기만 하면 됩니다.</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> parallelResut = names</span><br><span class="line">  .par</span><br><span class="line">  .fileter(_.length() &gt; <span class="number">1</span>)</span><br><span class="line">  .map(_.capitalize)</span><br><span class="line">  .reduce(_ + <span class="string">&quot;,&quot;</span> + _)</span><br></pre></td></tr></table></figure><h2 id="함수형-작업">함수형 작업</h2><p>앞에서 사용했던 함수형 작업은 다음과 같습니다.</p><ul><li>필터 filter</li><li>맵 map</li><li>폴드/리듀스 fold/reduce</li></ul><h3 id="필터-filter">필터 filter</h3><p><img src="filter.png" alt=""></p><p>필터는 큰 컬렉션에서 조건에 맞는 작은 컬렉션을 만들어내는 연산입니다. 데이터를 필터링해서 걸러내는 거라고 볼 수 있습니다.</p><h3 id="맵-map">맵 map</h3><p><img src="map.png" alt=""></p><p>맵은 해당 값에 함수를 적용해 새로운 컬렉션을 만드는 연산입니다. 값을 매핑하는 거라고 볼 수 있습니다.</p><h3 id="폴드-리듀스-fold-reduce">폴드/리듀스 fold/reduce</h3><p><img src="fold.png" alt=""></p><p>폴드 또는 리듀스는 언어들 사이에서도 이름이 다양하고 조금씩 의미도 다릅니다. 이 작업은 연산(<em>operation</em>)과 누산기(<em>accumulator</em>)를 가지고 컬렉션에 있는 값을 처리해 더 작은 컬렉션이나 단일 값을 만드는 작업입니다. 그림은 목록에 있는 값을 모두 더하는 작업입니다. 여기 누산기에 초기 값이 있는 경우도 있습니다.</p><h2 id="예제-자연수-분류하기">예제) 자연수 분류하기</h2><p>다른 예제를 살펴봅니다. 고대 그리스의 수학자 Nicomachus 는 자연수를 과잉수, 완전수, 부족수로 나누는 분류법을 고안했다고 합니다. 여기서 완전수는 자신을 뺀 약수의 합과 같습니다. 예를 들면 6의 약수는 1, 2, 3, 6으로 1 + 2 + 3 = 6이므로 완전수입니다. 28도 1 + 2 + 4 + 7 + 14 = 28이므로 완전수입니다. 여기서 자신을 뺀 약수의 합을 진약수의 합(<em>aliquot sum</em>)이라고 합니다.</p><ul><li>완전수 : 진약수의 합 = 수</li><li>초과수 : 진약수의 합 &gt; 수</li><li>부족수 : 진약수의 합 &lt; 수</li></ul><h3 id="일반적인-코드">일반적인 코드</h3><p>위 내용을 자바로 작성해봅시다. 클래스에 필드로 해당 숫자를 저장하고 메소드를 이용해서 완전수 여부를 계산합니다. <code>Map</code>으로 캐시도 구현해놨고 기능을 여러 메소드로 분리해놨는데 이제 함수형으로 차근차근 바꿔나갈겁니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ImpNumberClassifierSimple</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> _number;</span><br><span class="line">  <span class="keyword">private</span> Map&lt;Integer, Integer&gt; _cache;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">ImpNumberClassifierSimple</span><span class="params">(<span class="type">int</span> targetNumber)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>._number = targetNumber;</span><br><span class="line">    _cache = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> Set&lt;Integer&gt; <span class="title function_">getFactors</span><span class="params">()</span> &#123;</span><br><span class="line">    Set&lt;Integer&gt; factors = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    factors.add(<span class="number">1</span>);</span><br><span class="line">    factors.add(_number);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt; _number; i++)</span><br><span class="line">      <span class="keyword">if</span> (isFactor(i))</span><br><span class="line">        factors.add(i);</span><br><span class="line">    <span class="keyword">return</span> factors;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isFactor</span><span class="params">(<span class="type">int</span> potential)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> _number % potential == <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> 진약수(자신을 제외한 약수)의 합</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">aliquotSum</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (_cache.get(_number) == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> i : getFactors())</span><br><span class="line">        sum += i;</span><br><span class="line">      _cache.put(_number, sum - _number);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _cache.get(_number);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> 완전수 여부</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPerfect</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> aliquotSum() == _number;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> 초과수 여부</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAbundant</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> aliquotSum() &gt; _number;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> 부족수 여부</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isDeficient</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> aliquotSum() &lt; _number;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="조금-수정한-코드">조금 수정한 코드</h3><p>위 코드를 함수형으로 조금 변환해보겠습니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NumberClassifier</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isFactor</span><span class="params">(<span class="keyword">final</span> <span class="type">int</span> candidate, <span class="keyword">final</span> <span class="type">int</span> number)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> number % candidate == <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> Set&lt;Integer&gt; <span class="title function_">factors</span><span class="params">(<span class="keyword">final</span> <span class="type">int</span> number)</span> &#123;</span><br><span class="line">    Set&lt;Integer&gt; factors = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    factors.add(<span class="number">1</span>);</span><br><span class="line">    factors.add(number);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt; number; i++)</span><br><span class="line">      <span class="keyword">if</span> (isFactor(i, number))</span><br><span class="line">        factors.add(i);</span><br><span class="line">    <span class="keyword">return</span> factors;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">aliquotSum</span><span class="params">(<span class="keyword">final</span> Collection&lt;Integer&gt; factors)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> n : factors) &#123;</span><br><span class="line">      sum += n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum - Collections.max(factors);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isPerfect</span><span class="params">(<span class="keyword">final</span> <span class="type">int</span> number)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> aliquotSum(factors(number)) == number;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isAbundant</span><span class="params">(<span class="keyword">final</span> <span class="type">int</span> number)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> aliquotSum(factors(number)) &gt; number;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isDeficient</span><span class="params">(<span class="keyword">final</span> <span class="type">int</span> number)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> aliquotSum(factors(number)) &lt; number;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>달라진 부분이 보이시나요? 먼저 클래스 내에 상태를 저장하지 않기 위해서 필드를 없애고 각 메소드에서 <code>number</code> 인자를 받도록 변경했습니다. 따라서 모든 메소드는 필드를 사용하지 않는 static 메소드로 바꿀 수 있고 함수 수준에서 재사용이 쉬워졌습니다.</p><p>하지만 내부에 상태를 저장하지 않기 때문에 캐시가 없기 때문에 성능이 떨어질 수 있습니다. 다음 포스트에서 메모제이션을 통해 상태성을 보존하는 방법을 살펴봅니다.</p><h3 id="함수형-코드">함수형 코드</h3><p>이제 람다를 이용해 함수형 코드로 바꿔봅시다. 훨씬 간결해졌죠?</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NumberClassifierLambda</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> IntStream <span class="title function_">factorsOf</span><span class="params">(<span class="type">int</span> number)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> range(<span class="number">1</span>, number + <span class="number">1</span>)</span><br><span class="line">            .filter(potential -&gt; number % potential == <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">aliquotSum</span><span class="params">(<span class="type">int</span> number)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> factorsOf(number).sum() - number;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isPerfect</span><span class="params">(<span class="type">int</span> number)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> aliquotSum(number) == number;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isAbundant</span><span class="params">(<span class="type">int</span> number)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> aliquotSum(number) &gt; number;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isDeficient</span><span class="params">(<span class="type">int</span> number)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> aliquotSum(number) &lt; number;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>factorsOf</code>메소드는 스트림을 생성하고 약수만 필터링합니다. 스트림은 종료 작업을 하기 전까지는 계속해서 작업을 할 수 있죠. 여기서는 <code>sum()</code>은 스트림을 종료하고 값을 생성해줍니다.</p><h2 id="참고">참고</h2><ul><li><a href="http://www.kyobobook.co.kr/product/detailViewKor.laf?ejkGb=KOR&amp;mallGb=KOR&amp;barcode=9788968482960&amp;orderClick=LAG&amp;Kc=">도서 &lt;함수형 사고&gt;</a></li></ul><h2 id="Related-Posts">Related Posts</h2><ul><li><a href="/2018/10/05/why-functional-programming/" title="함수형 프로그래밍 기초 (1) 왜 함수형 프로그래밍인가">함수형 프로그래밍 기초 (1) 왜 함수형 프로그래밍인가</a></li><li><a href="/2018/10/07/functional-programming-filter-map-fold-reduce/" title="함수형 프로그래밍 기초 (2) 필터, 맵, 폴드(리듀스)">함수형 프로그래밍 기초 (2) 필터, 맵, 폴드(리듀스)</a></li><li>함수형 프로그래밍 기초 (3) 클로저와 커링</li><li>함수형 프로그래밍 기초 (4) 메모제이션과 Lazy</li><li>함수형 프로그래밍 기초 (5) 코드 재사용</li><li>함수형 프로그래밍 기초 (6) 함수형 디자인 패턴</li><li>함수형 프로그래밍 기초 (7) 실전 예제</li><li>함수형 프로그래밍 기초 (8) 폴리글랏과 폴리패러다임</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h2 id=&quot;함수형-접근&quot;&gt;함수형 접근&lt;/h2&gt;
&lt;p&gt;함수형 프로그래밍 </summary>
      
    
    
    
    <category term="Programming" scheme="https://futurecreator.github.io/categories/Programming/"/>
    
    
    <category term="reduce" scheme="https://futurecreator.github.io/tags/reduce/"/>
    
    <category term="functional_programming" scheme="https://futurecreator.github.io/tags/functional-programming/"/>
    
    <category term="filter" scheme="https://futurecreator.github.io/tags/filter/"/>
    
    <category term="map" scheme="https://futurecreator.github.io/tags/map/"/>
    
    <category term="fold" scheme="https://futurecreator.github.io/tags/fold/"/>
    
  </entry>
  
  <entry>
    <title>함수형 프로그래밍 기초 (1) 왜 함수형 프로그래밍인가</title>
    <link href="https://futurecreator.github.io/2018/10/05/why-functional-programming/"/>
    <id>https://futurecreator.github.io/2018/10/05/why-functional-programming/</id>
    <published>2018-10-05T14:41:27.000Z</published>
    <updated>2025-03-14T16:10:24.208Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="함수형-패러다임">함수형 패러다임</h2><p>새로운 프로그래밍 패러다임에서 중요한 것은 새로운 언어를 배우는 것이 아니라 새로운 방식으로 생각하는 법입니다. 문법을 배우는 건 쉽지만 사고방식을 배우는 건 쉽지 않죠.</p><p>컴퓨터 과학에서는 수십 년 전의 아이디어가 갑자기 주류가 되곤 합니다. 객체지향은 1983년 <a href="https://en.wikipedia.org/wiki/Simula">Simula 67</a>이라는 언어에서 처음 등장했지만 1983년 처음 등장한 C++이 보편화된 후에야 주류가 되었습니다. Java 는 초창기에 메모리를 많이 사용해 고성능 애플리케이션에는 적합하지 않았지만 하드웨어가 발전하면서 선호도가 높아졌습니다.</p><p>함수형 언어도 마찬가지입니다. 1930년대 <a href="https://en.wikipedia.org/wiki/Lambda_calculus">람다 대수</a> 라는 수학적 표기 방식이 함수형 프로그래밍의 기반이 된 이후 <a href="https://en.wikipedia.org/wiki/Lisp_(programming_language)">Lisp</a> 라는 함수형 프로그래밍 언어도 만들어졌습니다. 리스프는 현대적 함수형 프로그래밍의 여러 특징을 가지고 있습니다.</p><p>한동안 객체지향 언어가 유행이었지만 <a href="https://futurecreator.github.io/2018/08/07/highest-salaries-worldwide-programming-languages-2018/">연봉 높은 프로그래밍 언어 순위 2018</a> 을 보면 순위 TOP 10의 언어들은 거의 함수형 언어이고, 주요 언어들도 함수형 기능을 추가하고 있습니다. JavaScript 는 이미 많은 함수형 기능을 지원하고, C++은 2011년 표준에서 람다 블록을 추가했으며, 자바조차도 자바 8에 람다 블록을 도입했습니다. 앞서 이야기한 것처럼 문법 자체가 중요한 것은 아닙니다. 함수형으로 사고방식을 바꾸면 이런 기능을 바로 사용할 수 있습니다.</p><h2 id="객체-지향-프로그래밍과의-차이">객체 지향 프로그래밍과의 차이</h2><div class="twitter-wrapper"><blockquote class="twitter-tweet"><a href="https://twitter.com/mfeathers/status/29581296216"></a></blockquote></div><script async defer src="https://platform.twitter.com/widgets.js" charset="utf-8"></script><blockquote><p>객체지향은 동작하는 부분을 캡슐화해서 이해할 수 있게 하고, 함수형 프로그래밍은 동작하는 부분을 최소화해서 코드 이해를 돕는다.</p><footer><strong>마이클 페더스</strong><cite>‘레거시 코드 활용 전략' 저자</cite></footer></blockquote><p>객체지향과 함수형의 차이는 상태를 관리하는 점입니다. 객체지향의 경우 객체 안에 상태를 저장합니다. 그리고 해당 상태를 이용해서 제공할 수 있는 기능(메소드)를 추가하고 상태 변화를 ‘누가 어디까지 볼 수 있게 할지’를 설정하고 조정하기 위해 캡슐화, scoping, visibility 등의 기능을 사용합니다. 여기에 쓰레드까지 더해지면 더 복잡해지는데요. 함수형 프로그래밍은 이런 상태를 제어하기보다는 상태를 저장하지 않고 없애는데 주력합니다. <a href="https://en.wikipedia.org/wiki/Function_(mathematics)">함수</a>라는 것 자체가 입력값이 들어가면 이에 따른 특정한 출력값이 나오는 것으로 상태를 저장하지 않습니다.</p><p>따라서 매우 간결하게 코드를 작성할 수 있고 이를 위해서는 객체지향과는 다른 방식으로 접근해야 합니다. 객체 지향은 상태를 저장하는 필드와 필드를 이용해 기능을 제공하는 메소드를 붙여서 클래스를 만듭니다. 항상 새로운 자료구조를 사용하게 되는 셈입니다. 하지만 함수형은 몇몇 자료구조(<em>list, set, map</em>)를 이용해 최적화된 동작을 만들어냅니다.</p><h2 id="예제-단어-수-세기">예제) 단어 수 세기</h2><p>객체 지향과 함수형의 차이를 예제로 살펴보겠습니다. 텍스트 파일을 읽고 가장 많이 사용된 단어를 찾은 후 그 단어와 빈도를 정렬된 리스트로 출력하는 예제입니다.<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="CACM의 고정 칼럼인 Programming Perls 의 기고자 존 벤틀리가 초기 컴퓨터과학의 개척자 도널드 커누스에게 요구했던 작업.">[1]</span></a></sup></p><h3 id="Java">Java</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">import</span> java.util.TreeMap;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Matcher;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Pattern;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Words</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> Set&lt;String&gt; NON_WORDS = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;String&gt;() &#123;&#123;</span><br><span class="line">    add(<span class="string">&quot;the&quot;</span>); add(<span class="string">&quot;and&quot;</span>); add(<span class="string">&quot;of&quot;</span>); add(<span class="string">&quot;to&quot;</span>); add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">    add(<span class="string">&quot;i&quot;</span>); add(<span class="string">&quot;it&quot;</span>); add(<span class="string">&quot;in&quot;</span>); add(<span class="string">&quot;or&quot;</span>); add(<span class="string">&quot;is&quot;</span>);</span><br><span class="line">    add(<span class="string">&quot;d&quot;</span>); add(<span class="string">&quot;s&quot;</span>); add(<span class="string">&quot;as&quot;</span>); add(<span class="string">&quot;so&quot;</span>); add(<span class="string">&quot;but&quot;</span>);</span><br><span class="line">    add(<span class="string">&quot;be&quot;</span>);</span><br><span class="line">  &#125;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> Map <span class="title function_">wordFreq</span><span class="params">(String words)</span> &#123;</span><br><span class="line">    TreeMap&lt;String, Integer&gt; wordMap = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;();</span><br><span class="line">    <span class="type">Matcher</span> <span class="variable">m</span> <span class="operator">=</span> Pattern.compile(<span class="string">&quot;\\w+&quot;</span>).matcher(words);</span><br><span class="line">    <span class="keyword">while</span> (m.find()) &#123;</span><br><span class="line">      <span class="type">String</span> <span class="variable">word</span> <span class="operator">=</span> m.group().toLowerCase();</span><br><span class="line">      <span class="keyword">if</span> (!NON_WORDS.contains(word)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (wordMap.get(word) == <span class="literal">null</span>) &#123;</span><br><span class="line">          wordMap.put(word, <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          wordMap.put(word, wordMap.get(word) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> wordMap;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>루프를 돌면서 단어인지 아닌지 체크하고 맵을 이용해 갯수를 카운트합니다.</p><h3 id="Java-8">Java 8</h3><p>자바 8의 스트림과 람다를 이용해보죠. 정규식 결과를 리스트로 바꿔서 스트림을 생성합니다. 스트림을 생성하면 아주 간결하게 처리할 수 있습니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Map <span class="title function_">wordFreq</span><span class="params">(String words)</span> &#123;</span><br><span class="line">  TreeMap&lt;String, Integer&gt; wordMap = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;();</span><br><span class="line">  regexToList(words, <span class="string">&quot;\\w+&quot;</span>).stream()</span><br><span class="line">    .map(String::toLowerCase)</span><br><span class="line">    .filter(w -&gt; !NON_WORDS.contains(w))</span><br><span class="line">    .forEach(w -&gt; wordMap.put(w, wordMap.getOrDefault(w, <span class="number">0</span>) + <span class="number">1</span>));</span><br><span class="line">  <span class="keyword">return</span> wordMap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> List&lt;String&gt; <span class="title function_">regexToList</span><span class="params">(String words, String regex)</span> &#123;</span><br><span class="line">  <span class="type">List</span> <span class="variable">wordList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">  <span class="type">Matcher</span> <span class="variable">m</span> <span class="operator">=</span> Pattern.compile(regex).matcher(words);</span><br><span class="line">  <span class="keyword">while</span> (m.find())</span><br><span class="line">    wordList.add(m.group());</span><br><span class="line">  <span class="keyword">return</span> wordList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="예제-문자-위치-찾기">예제) 문자 위치 찾기</h2><h3 id="Java-v2">Java</h3><p>이번 예제는 주어진 배열 내에서 해당 문자가 처음 발견되는 위치를 리턴하는 예제입니다. 소스는 <a href="https://commons.apache.org/">Apache Commons</a> 의 <a href="https://commons.apache.org/proper/commons-lang/apidocs/org/apache/commons/lang3/StringUtils.html">StringUtils</a>의 <code>indexOfAny</code> 라는 메소드입니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">indexOfAny</span><span class="params">(<span class="keyword">final</span> CharSequence cs, <span class="keyword">final</span> <span class="type">char</span>... searchChars)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) &#123;</span><br><span class="line">    <span class="keyword">return</span> INDEX_NOT_FOUND;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">final</span> <span class="type">int</span> <span class="variable">csLen</span> <span class="operator">=</span> cs.length();</span><br><span class="line">  <span class="keyword">final</span> <span class="type">int</span> <span class="variable">csLast</span> <span class="operator">=</span> csLen - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">final</span> <span class="type">int</span> <span class="variable">searchLen</span> <span class="operator">=</span> searchChars.length;</span><br><span class="line">  <span class="keyword">final</span> <span class="type">int</span> <span class="variable">searchLast</span> <span class="operator">=</span> searchLen - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; csLen; i++) &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> cs.charAt(i);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; searchLen; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (searchChars[j] == ch) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; csLast &amp;&amp; j &lt; searchLast &amp;&amp; Character.isHighSurrogate(ch)) &#123;</span><br><span class="line">          <span class="comment">// ch is a supplementary character</span></span><br><span class="line">          <span class="keyword">if</span> (searchChars[j + <span class="number">1</span>] == cs.charAt(i + <span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> INDEX_NOT_FOUND;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>로직 자체는 단순하지만 복잡하게 구현되어 있습니다. 이중 <code>for</code> 문과 중첩된 <code>if</code> 문 때문에 복잡하게 보입니다.</p><h3 id="Scala">Scala</h3><p>이번엔 동일한 기능을 Scala 를 이용해서 구현해보겠습니다.</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">firstIndexOfAny</span></span>(input: <span class="type">String</span>, searchChars: <span class="type">Seq</span>[<span class="type">Char</span>]) : <span class="type">Option</span>[<span class="type">Int</span>] = &#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">indexedInput</span> </span>= (<span class="number">0</span> until input.length).zip(input)</span><br><span class="line">  <span class="keyword">val</span> result = <span class="keyword">for</span> (pair &lt;- indexedInput;</span><br><span class="line">                    char &lt;- searchChars;</span><br><span class="line">                    <span class="keyword">if</span> char == pair._2) <span class="keyword">yield</span> pair._1</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (result.isEmpty)</span><br><span class="line">    <span class="type">None</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="type">Some</span>(result.head)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>먼저 <code>0 until input.length</code> 는 입력된 문자열만큼 자연수 컬렉션을 만들고 <code>zip()</code> 메소드를 이용해 숫자와 문자를 각각 매핑시킵니다. 만약 입력 문자가 “zzabyycdxx” 라면 0~9까지 숫자가 만들어지고 각 문자와 맵핑되어 다음과 같은 컬렉션이 만들어집니다. 앞에 숫자를 인덱스로 사용할 목적입니다.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vector((0,z), (1,z), (2,a), (3,b), (4,y), (5,y), (6,c), (7,d), (8,x), (9,x))</span><br></pre></td></tr></table></figure><p>그리고 <code>for</code> 문을 이용해서 같은 문자를 찾으면 인덱스를 반환합니다. 마지막으로 null 문제를 피하기 위해서 Option 객체를 사용합니다. Option 객체의 하위 객체에는 값이 있는 Some과 값이 없는 None이 있습니다. 결과 값을 확인해서 해당 객체를 리턴합니다.</p><p>이번 포스트에서는 함수형 프로그래밍에 대해 간단하게 알아봤습니다. 앞으로 좀 더 자세한 내용과 함수형 사고방식을 다루겠습니다.</p><h2 id="참고">참고</h2><ul><li><a href="http://www.kyobobook.co.kr/product/detailViewKor.laf?ejkGb=KOR&amp;mallGb=KOR&amp;barcode=9788968482960&amp;orderClick=LAG&amp;Kc=">도서 &lt;함수형 사고&gt;</a></li></ul><h2 id="Related-Posts">Related Posts</h2><ul><li><a href="/2018/10/05/why-functional-programming/" title="함수형 프로그래밍 기초 (1) 왜 함수형 프로그래밍인가">함수형 프로그래밍 기초 (1) 왜 함수형 프로그래밍인가</a></li><li><a href="/2018/10/07/functional-programming-filter-map-fold-reduce/" title="함수형 프로그래밍 기초 (2) 필터, 맵, 폴드(리듀스)">함수형 프로그래밍 기초 (2) 필터, 맵, 폴드(리듀스)</a></li><li>함수형 프로그래밍 기초 (3) 클로저와 커링</li><li>함수형 프로그래밍 기초 (4) 메모제이션과 Lazy</li><li>함수형 프로그래밍 기초 (5) 코드 재사용</li><li>함수형 프로그래밍 기초 (6) 함수형 디자인 패턴</li><li>함수형 프로그래밍 기초 (7) 실전 예제</li><li>함수형 프로그래밍 기초 (8) 폴리글랏과 폴리패러다임</li></ul><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">CACM의 고정 칼럼인 Programming Perls 의 기고자 존 벤틀리가 초기 컴퓨터과학의 개척자 도널드 커누스에게 요구했던 작업.<a href="#fnref:1" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h2 id=&quot;함수형-패러다임&quot;&gt;함수형 패러다임&lt;/h2&gt;
&lt;p&gt;새로운 프로</summary>
      
    
    
    
    <category term="Programming" scheme="https://futurecreator.github.io/categories/Programming/"/>
    
    
    <category term="java" scheme="https://futurecreator.github.io/tags/java/"/>
    
    <category term="functional_programming" scheme="https://futurecreator.github.io/tags/functional-programming/"/>
    
    <category term="why" scheme="https://futurecreator.github.io/tags/why/"/>
    
    <category term="scala" scheme="https://futurecreator.github.io/tags/scala/"/>
    
  </entry>
  
  <entry>
    <title>마이크로서비스 Microservices (3) 프로세스 간 통신</title>
    <link href="https://futurecreator.github.io/2018/10/04/inter-process-communication-in-microservices/"/>
    <id>https://futurecreator.github.io/2018/10/04/inter-process-communication-in-microservices/</id>
    <published>2018-10-04T14:55:09.000Z</published>
    <updated>2025-03-14T16:10:24.208Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="프로세스-간-통신">프로세스 간 통신</h2><p>모놀리식(<em>monolithic</em>) 애플리케이션에서는 단순하게 다른 메소드나 함수를 호출하면 됩니다. 하지만 마이크로서비스(<em>Microservices</em>)에서는 서비스 단위로 나뉘어져 있는 분산 시스템이기 때문에 서비스 간 통신이 필요합니다. 이러한 통신을 프로세스 간 통신(<em>inter-process communication</em>)이라고 합니다. 다음 그림에서 왼쪽이 모놀리스, 오른쪽이 마이크로서비스입니다.</p><p><img src="https://cdn-1.wp.nginx.com/wp-content/uploads/2015/07/Richardson-microservices-part3-monolith-vs-microservices-1024x518.png" alt="https://www.nginx.com/blog/building-microservices-inter-process-communication/"></p><h2 id="통신-방식">통신 방식</h2><p>통신 방식은 먼저 호출하는 쪽과 호출당하는 쪽의 수로 구분해볼 수 있습니다. 하나의 요청이 하나의 서비스를 실행하면 일대일(<em>One-to-One</em>), 하나의 요청이 여러 서비스를 실행하면 일대다(<em>One-to-Many</em>)라고 볼 수 있습니다.</p><p>그리고 동기(<em>Synchronous</em>)와 비동기 방식(<em>Asynchronous</em>)으로 구분할 수 있습니다. 동기 방식은 요청을 보내고 응답이 올 때까지 기다리는 방식으로 이후 동작은 멈춘 상태(<em>block</em>)가 됩니다. 그리고 응답을 받은 후에 처리합니다. 반대로 비동기 방식은 요청을 보내고 응답이 올 때까지 기다리지 않고 다음을 실행합니다. 그리고 응답을 처리하는 코드를 같이 보내서 작업이 끝나면 실행하게 됩니다. 이러한 함수를 콜백 함수(<em>callback function</em>)라고 합니다.</p><p>이 두 가지 구분 방식을 조합하면 다음과 같습니다.</p><table><thead><tr><th></th><th style="text-align:center">일대일</th><th style="text-align:center">일대다</th></tr></thead><tbody><tr><td>동기</td><td style="text-align:center">1) 요청/응답(<em>Request/response</em>)</td><td style="text-align:center">-</td></tr><tr><td>비동기</td><td style="text-align:center">2) 알림(<em>Notification</em>)</td><td style="text-align:center">4) 퍼블리시/구독<br />(<em>Publish/subscribe</em>)</td></tr><tr><td></td><td style="text-align:center">3) 요청/비동기 응답<br />(Request/async response)</td><td style="text-align:center">5) 퍼블리시/비동기 구독<br />(<em>Publish/async responses</em>)</td></tr></tbody></table><ol><li>요청/응답 : 요청을 보내고 응답이 올 때까지 기다립니다.</li><li>알림 : 요청을 보내기만 합니다. 모바일의 푸시 알림을 생각하시면 됩니다.</li><li>요청/비동기 응답 : 요청을 보내면 비동기로 응답이 옵니다.</li><li>퍼블리시/구독 : 등록된 서비스들에 요청을 보냅니다. 요청을 받은 서비스들은 각자 로직을 처리합니다. 잡지를 구독하는 것과 같다고해서 퍼블리시/구독 방식이라고 합니다.</li><li>퍼블리시/비동기 응답 : 위와 같지만 비동기 형태로 응답을 보낸다는 점이 다릅니다.</li></ol><p>여러가지 방식을 살펴봤는데요, 애플리케이션에 따라서 하나의 방식만으로도 충분하기도 하고, 여러 방식을 함께 사용하기도 합니다. 이전 포스트에서 살펴본 택시 호출 서비스를 예로 들어보겠습니다.</p><p><img src="https://cdn-1.wp.nginx.com/wp-content/uploads/2015/07/Richardson-microservices-part3-taxi-service-1024x609.png" alt="https://www.nginx.com/blog/building-microservices-inter-process-communication/"></p><ol><li>승객이 스마트폰으로 픽업을 요청합니다. 이 요청은 트립 관리 서비스를 호출합니다(알림)</li><li>트립 관리 서비스는 승객 관리 서비스에서 승객 정보를 확인합니다(요청/응답)</li><li>트립 관리 서비스는 해당 트립을 디스패와처와 가까운 택시기사에게 보냅니다(요청/응답)</li></ol><h2 id="API-정의와-수정">API 정의와 수정</h2><p>API 는 서비스와 클라이언트 간 일종의 계약입니다. 그래서 API 를 제대로 정의하는 것이 중요합니다. 그래서 API 먼저 설계하고 클라이언트 개발자들과 리뷰를 통해서 확정 짓고 개발을 진행하는 것이 좋습니다. 나중에 API를 수정하는 것보다 합리적인 방법이죠.</p><p>처음에 API 를 잘 정의하는 것만큼 API 를 수정하는 것도 중요한 일입니다. 특히 마이크로서비스 기반의 애플리케이션에서는 해당 API 를 사용하는 서비스들이 많기 때문에 수정의 영향이 상당히 큽니다. 요청, 응답에 속성이 추가되는 정도의 마이너한 수정은 API 내에서 호환성을 지원할 수 있습니다.</p><p>하지만 메이저한 수정이 필요할 때도 있습니다. 이럴 땐 API를 사용하는 클라이언트가 당장 업그레이드할 수 없으니 수정할 시간을 줘야합니다. 그래서 옛날 버전과 새로운 버전을 한동안 같이 지원해야 하고 HTTP 같은 경우에는 URL 에 버전을 포함시키는 것이 일반적입니다.</p><h2 id="IPC-기술">IPC 기술</h2><p>IPC 기술들은 다음과 같이 구분할 수 있습니다.</p><ul><li>동기 요청/응답 기반 : <a href="https://en.wikipedia.org/wiki/Representational_state_transfer">REST</a>, <a href="https://thrift.apache.org/">Apache Thrift</a></li><li>비동기 메시지 기반 : <a href="https://en.wikipedia.org/wiki/Advanced_Message_Queuing_Protocol">AMQP</a>, <a href="https://stomp.github.io/">STOMP</a></li></ul><p>여기서 사용하는 메시지 포맷도 여러가지가 있죠.</p><ul><li>텍스트 기반(사람이 쉽게 읽을 수 있음): JSON, XML</li><li>바이너리 포맷(성능 상 좋음): <a href="https://avro.apache.org/">Apache Avro</a>, <a href="https://developers.google.com/protocol-buffers/docs/overview">Protocol Buffers</a></li></ul><p>자세한 내용을 살펴보겠습니다.</p><h3 id="동기-요청-응답">동기 요청/응답</h3><p>클라이언트에서 서비스로 요청을 보내면 해당 서비스가 요청을 처리해서 결과로 응답을 보내는 방식입니다. 요청을 보낸 클라이언트의 쓰레드는 응답이 올 때까지 기다리며 블락(<em>block</em>)됩니다. 물론 <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Future.html">Future</a> 나 <a href="http://reactivex.io/">ReactiveX</a> 를 이용해서 이벤트 기반으로 코드를 짜면 비동기로 처리할 수 있습니다.</p><h4 id="REST">REST</h4><p>상당히 많은 API 가 HTTP 기반의 RESTful API 로 작성되어 있습니다. REST 는 웹 상에 리소스를 지정하는 방식으로 HTTP 동사와 URL 을 조합해서 사용합니다. URL 로는 특정 리소스(<em>Customer</em>나 <em>Product</em> 같은 비즈니스 개체)를 지정하고 HTTP 동사로 동작을 지정합니다.</p><ul><li>GET : 조회(<em>Read</em>)</li><li>POST : 생성(<em>Create</em>)</li><li>PUT: 업데이트(<em>Update</em>)</li><li>DELETE: 삭제(<em>Delete</em>)</li></ul><p><a href="https://cdn.wp.nginx.com/wp-content/uploads/2015/07/Richardson-microservices-part3-rest.png?_ga=2.54457194.335686935.1538621026-931831265.1536563442"><img src="https://cdn.wp.nginx.com/wp-content/uploads/2015/07/Richardson-microservices-part3-rest-1024x397.png" alt="https://www.nginx.com/blog/building-microservices-inter-process-communication/"></a></p><p>택시 호출 애플리케이션 예제로 돌아가볼까요? 승객이 택시를 부를 때 REST API 를 호출합니다. POST 방식으로 URL은 /trips 인데요 트립 관리 서비스에 새로운 트립 정보가 생성된다는걸 알 수 있습니다. 트립 관리 서비스에서는 승객에 대한 정보를 조회하기 위해서 승객 관리 서비스가 제공하는 API에 GET 방식으로 /passensgers/passengerId 의 요청을 보냅니다. 그럼 해당 승객 ID 로 승객 정보를 조회할 수 있습니다. 응답은 처리 결과를 나타내는 응답 코드를 가지고 있는데 각각 200, 201 코드를 반환하게 됩니다.</p><p>REST 는 직관적이고 기존 HTTP 웹 인프라를 그대로 사용할 수 있어 사용하기 쉽습니다. 하지만 API 가 HTTP 기반이라고 해서 모두 RESTful 한 것은 아닙니다.<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[Richardson Maturity Model | MARTINFOWLER.COM](https://martinfowler.com/articles/richardsonMaturityModel.html)">[1]</span></a></sup> 명확한 표준이 없다보니 잘못 설계된 API 도 많고 무엇보다 복잡한 비즈니스 로직을 표현하기가 어렵습니다. 위에서 사용한 HTTP 동사들은 기본적인 CRUD 기능을 나타내고 있죠. <a href="https://raml.org/">RAML</a> 이나 <a href="https://swagger.io/">Swagger</a> 같은 API 설계 도구를 사용해 쉽고 제대로 된 Restful API를 설계할 수 있습니다.</p><h4 id="Apache-Thrift">Apache Thrift</h4><p><a href="https://thrift.apache.org/">Apache Trhift</a> 는 REST의 대안 중 하나입니다. Thrift 를 이용해 API를 정의하면 C++, Java, Python, PHP, Ruby, Node.js 등 여러 언어의 코드를 생성해줍니다. REST의 대안 답게 요청/응답 뿐만 아니라 단방향 전송도 지원하고 JSON, 바이너리 등 다양한 메시지 포맷을 지원합니다.</p><h3 id="비동기-메시지-기반-통신">비동기 메시지 기반 통신</h3><p>이번엔 비동기 방식을 살펴보겠습니다. 비동기 방식은 메시지를 보내놓고 응답을 기다리지 않습니다. 이 메시지는 헤더(<em>header</em>)와 바디(<em>body</em>)로 구성되어 있고 채널(<em>channel</em>)을 통해 전송됩니다. 메시지는 한 곳에만 보낼 수도 있고(일대일), 옵저버 패턴같은 퍼블리시-구독 모델을 따라 여러 곳에 메시지를 보낼 수도 있습니다(일대다). 그 메시지를 받겠다고 구독해놓은 서비스에게 모두 메시지가 전송되는 거죠.</p><p><a href="https://cdn.wp.nginx.com/wp-content/uploads/2015/07/Richardson-microservices-part3-pub-sub-channels.png?_ga=2.57596008.335686935.1538621026-931831265.1536563442"><img src="https://cdn.wp.nginx.com/wp-content/uploads/2015/07/Richardson-microservices-part3-pub-sub-channels-1024x639.png" alt="https://www.nginx.com/blog/building-microservices-inter-process-communication/"></a></p><p>택시 호출 예제로 돌아가봅시다. 동기 방식과는 완전히 다른 모습이죠. 트립이 생성되었다는 메시지를 NEW TRIPS 채널에 전송하면 해당 채널을 구독하고 있는 디스패처가 받아 택시 기사를 배정합니다. 그리고 나서 배정 결과를 DISPATCHING 채널에 전송하면 해당 채널을 구독하고 있는 트립, 승객, 택시기사 관리 서비스에서 한번에 메시지를 받게 됩니다.</p><p>이런 메시징 방식은 클라이언트와 서비스 사이의 의존도를 줄여줍니다. 동기 방식은 클라이언트와 서비스가 서로를 알아야 하고 직접 통신하는 구조이지만 메시징 방식은 그 사이에 메시징 시스템이 들어가서 간접적으로 통신하기 때문이죠. 일대일 뿐만 아니라 일대다 통신을 지원하는 것도 장점입니다. 그리고 메시징 시스템은 전송되는 메시지가 많을 때 버퍼를 활용해 속도를 조절할 수도 있습니다. 물론 메시징 시스템이 추가로 들어가는만큼 운영하고 관리해야 할 것이 늘어나게 됩니다.</p><p>메시지를 전송하는 표준 프로토콜은 AMQP 와 STOMP가 있습니다. 그리고 오픈소스 메시징 시스템에는 <a href="https://www.rabbitmq.com/">RabbitMQ</a>, <a href="http://kafka.apache.org/">Apache Kafka</a>, <a href="http://activemq.apache.org/">Apache ActiveMQ</a>, <a href="https://github.com/bitly/nsq">NSQ</a> 등이 있습니다.</p><h3 id="메시지-포맷">메시지 포맷</h3><p>통신 방식을 골랐다면 메시지를 어떤 포맷으로 보낼지 골라야 합니다.</p><p>먼저 사람이 읽기 쉽고 이해할 수 있는 XML 과 JSON 이 있습니다. XML 은 <a href="https://www.w3.org/XML/Schema">XML 스키마</a>로 구조를 정의할 수가 있어서 데이터를 쉽게 검증할 수 있지만 메시지 사이즈가 너무 커집니다. JSON 은 XML 보다 가볍지만 데이터를 검증하기가 쉽지 않았습니다. 그래서 JSON 에서도 XML 처럼 데이터를 검증할 수 있도록 만든 것이 <a href="http://json-schema.org/">JSON 스키마</a> 입니다.</p><p>이런 텍스트 기반 메시지는 텍스트를 파싱하는데 오버헤드가 생깁니다. 따라서 성능을 위해 바이너리 값으로 전송하는 방법도 있습니다. 많이 쓰이는 것으로는 binary Thrift 나 <a href="https://developers.google.com/protocol-buffers/docs/overview">Protocol Buffers</a>, <a href="https://avro.apache.org/">Apache Avro</a>. 등이 있습니다.</p><h2 id="참고">참고</h2><ul><li><a href="https://www.nginx.com/blog/building-microservices-inter-process-communication/">Building Microservices: Inter-Process Communication in a Microservices Architecture | NGINX</a></li></ul><h2 id="Related-Posts">Related Posts</h2><ul><li><a href="/2018/09/14/what-is-microservices-architecture/" title="마이크로서비스 Microservices (1) 아키텍처 소개">마이크로서비스 Microservices (1) 아키텍처 소개</a></li><li><a href="/2018/09/14/microservices-with-api-gateway/" title="마이크로서비스 Microservices (2) API 게이트웨이">마이크로서비스 Microservices (2) API 게이트웨이</a></li><li><a href="/2018/10/04/inter-process-communication-in-microservices/" title="마이크로서비스 Microservices (3) 프로세스 간 통신">마이크로서비스 Microservices (3) 프로세스 간 통신</a></li><li><a href="/2018/10/18/service-discovery-in-microservices/" title="마이크로서비스 Microservices (4) 서비스 디스커버리">마이크로서비스 Microservices (4) 서비스 디스커버리</a></li><li><a href="/2018/10/19/microservices-and-event-driven-data-management/" title="마이크로서비스 Microservices (5) 이벤트 주도 데이터 관리">마이크로서비스 Microservices (5) 이벤트 주도 데이터 관리</a></li><li><a href="/2018/10/19/microservices-deployment-strategy/" title="마이크로서비스 Microservices (6) 배포 전략">마이크로서비스 Microservices (6) 배포 전략</a></li><li><a href="/2018/10/19/microservices-refactoring-for-monolith/" title="마이크로서비스 Microservices (7) 모놀리스 리팩토링">마이크로서비스 Microservices (7) 모놀리스 리팩토링</a></li></ul><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://martinfowler.com/articles/richardsonMaturityModel.html">Richardson Maturity Model | MARTINFOWLER.COM</a><a href="#fnref:1" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h2 id=&quot;프로세스-간-통신&quot;&gt;프로세스 간 통신&lt;/h2&gt;
&lt;p&gt;모놀리식</summary>
      
    
    
    
    <category term="Programming" scheme="https://futurecreator.github.io/categories/Programming/"/>
    
    <category term="MSA" scheme="https://futurecreator.github.io/categories/Programming/MSA/"/>
    
    
    <category term="msa" scheme="https://futurecreator.github.io/tags/msa/"/>
    
    <category term="microservices" scheme="https://futurecreator.github.io/tags/microservices/"/>
    
    <category term="ipc" scheme="https://futurecreator.github.io/tags/ipc/"/>
    
    <category term="inter_process_communication" scheme="https://futurecreator.github.io/tags/inter-process-communication/"/>
    
    <category term="message" scheme="https://futurecreator.github.io/tags/message/"/>
    
  </entry>
  
  <entry>
    <title>Java 11 릴리즈!</title>
    <link href="https://futurecreator.github.io/2018/09/29/java-11-released/"/>
    <id>https://futurecreator.github.io/2018/09/29/java-11-released/</id>
    <published>2018-09-29T14:06:48.000Z</published>
    <updated>2025-03-14T16:10:24.208Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>자바 11이 릴리즈됐습니다. 자바 10이 출시된지 6개월만입니다. 오라클은 6개월마다 새 버전을 출시한다고 했고, 특정 버전만 장기간 지원(Long-term support; LTS)한다고 밝혔는데요. 자바 11은 첫 번째 LTS 버전입니다.</p><div class="twitter-wrapper"><blockquote class="twitter-tweet"><a href="https://twitter.com/java/status/928185028714160128"></a></blockquote></div><script async defer src="https://platform.twitter.com/widgets.js" charset="utf-8"></script><p>오라클이 이런 버전 정책을 가져가는 이유는 두 가지입니다.</p><ul><li>자바 생태계가 빠르게 발전할 수 있도록 6개월마다 새로운 버전을 릴리즈합니다.</li><li>중간 중간 LTS 버전을 둠으로써 다음 버전으로 마이그레이션할 충분할 시간을 줍니다.</li></ul><p>그럼 자바 11에서 달라진 점을 살펴보겠습니다.</p><h2 id="새로운-기능">새로운 기능</h2><h3 id="Nest-기반-접근-제어">Nest 기반 접근 제어</h3><p><a href="https://openjdk.java.net/jeps/181">Nest-based access controls</a>. Nest 는 접근 제어 컨텍스트로 논리적으로는 같은 클래스를 분리된 클래스로 컴파일할 수 있게 해줍니다. 그러면 다른 클래스의 private 멤버에 getter/setter 없이 바로 접근 가능합니다. 여러 클래스를 하나의 클래스처럼 묶어줄 수 있는 기술로 보입니다.</p><h3 id="새로운-가비지-컬렉터">새로운 가비지 컬렉터</h3><p><a href="https://openjdk.java.net/jeps/333">ZGC: A Scalable Low-Latency Garbage Collector (Experimental)</a>. 성능을 향상시킨 새로운 가비지 컬렉터(Carbage Collector)입니다. 메모리를 자동으로 정리해주는 가비지 컬렉터는 자바의 장점 중 하나이지만, 가비지 컬렉터가 동작할 때 JVM이 애플리케이션을 멈추기 때문에 자바의 단점이기도 합니다. ZGC는 이 시간을 10ms 미만으로 줄이고 15% 이하의 성능 페널티를 목표로 합니다.</p><h3 id="Flight-Recorder">Flight Recorder</h3><p><a href="https://bugs.openjdk.java.net/browse/JDK-8203664">Flight Recorder</a>. 자바 애플리케이션과 HotSpot JVM의 문제 해결을 위한 오버헤드가 낮은 데이터 수집 프레임워크입니다. 이전에는 유료 기능이었지만 오픈소스로 공개되었습니다.</p><h3 id="새로운-표준-HTTP-라이브러리">새로운 표준 HTTP 라이브러리</h3><p><a href="https://openjdk.java.net/jeps/321">HTTP Clinet(Standard)</a>. <code>java.net.http</code> 패키지의 새로운 모듈로 flow 기반의 HTTP/1.1과 HTTP/2를 지원합니다. 자바 9과 자바 10에서 사용되었던 <code>jdk.incubator.http</code> 패키지가 표준화되어 <code>java.net.http</code> 패키지로 추가되었습니다.</p><h3 id="TLS-1-3">TLS 1.3</h3><p><a href="https://openjdk.java.net/jeps/332">Transport Layer Security (TLS) 1.3</a>. <a href="https://futurecreator.github.io/2018/07/12/https-and-ssl-tls/">TLS</a>는 <a href="https://futurecreator.github.io/2018/07/12/https-and-ssl-tls/">이전 포스트</a>에서 살펴봤던 것처럼 SSL(Secure Socket Layer)의 표준 이름이죠. TLS의 새로운 버전을 구현했습니다.</p><h3 id="람다에서의-var-변수">람다에서의 var 변수</h3><p><a href="https://openjdk.java.net/jeps/323">Local-Variable Syntax for Lambda Parameters</a>. 자바 10에서 도입된 var 타입 추론을 업데이트했습니다.</p><h2 id="사라진-기능">사라진 기능</h2><p>사라진 기능도 간단하게 살펴보겠습니다.</p><ul><li><strong>Java EE and CORBA Modules</strong> : 앞으로 EE 나 CORBA 모듈이 필요한 경우 명시적으로 의존을 추가해야 합니다.</li><li><strong>Web Start</strong> : 특별한 대안 없이 삭제되었습니다.</li><li><strong>Applets</strong> : 한동안 대부분 deprecated 되었다가 완전히 삭제되었습니다.</li><li><strong>JavaFX</strong> : FX 라이브러리가 OpenJFX 프로젝트로 옮겨가면서 코어에서 삭제되었습니다.</li></ul><p>자바 11이 릴리즈되었다는 소식에 달라진 점을 간단히 살펴봤습니다. 자바 10을 아직 정리하지 않아서 차차 다른 포스트에서 다뤄볼 예정입니다. 자바 11은 <a href="https://www.oracle.com/technetwork/java/javase/downloads/index.html">오라클 다운로드 페이지</a>에서 다운로드하실 수 있습니다.</p><h2 id="참고">참고</h2><ul><li><a href="https://jdk.java.net/11/release-notes">JDK 11 Release Notes | jdk.java.net</a></li><li><a href="https://www.infoq.com/news/2018/09/java11-released">Java 11 Released | InfoQ</a></li><li><a href="https://byline.network/2018/09/3-22/">오라클 자바 SE 유료화(?)에 대한 오해 셋 | BylineNetwork</a></li></ul><h2 id="Related-Posts">Related Posts</h2><ul><li><a href="/2018/08/26/java-8-streams/" title="Java 스트림 Stream (1) 총정리">Java 스트림 Stream (1) 총정리</a></li><li><a href="/2018/08/26/java-8-streams-advanced/" title="Java 스트림 Stream (2) 고급">Java 스트림 Stream (2) 고급</a></li><li><a href="#">Post not found: java-8-lambda-deep-dive</a></li><li><a href="/2018/08/12/java-generics/" title="Java 제네릭 Generics DEEP DIVE">Java 제네릭 Generics DEEP DIVE</a></li><li><a href="/2018/08/14/java-8-optional/" title="Java 8 옵셔널 Optional">Java 8 옵셔널 Optional</a></li><li><a href="/2018/06/04/java-observer-pattern/" title="Java 옵저버 패턴 (Observer Pattern)">Java 옵저버 패턴 (Observer Pattern)</a></li><li><a href="/2017/01/27/java-variable-data-type/" title="자바의 변수와 데이터 타입 (Java Variables &amp; Data type)">자바의 변수와 데이터 타입 (Java Variables &amp; Data type)</a></li><li><a href="/2018/06/02/java-string-concatenation/" title="Java 문자열 연결 방법 비교">Java 문자열 연결 방법 비교</a></li><li><a href="/2018/06/02/java-string-joiner/" title="Java StringJoiner (문자열 구분자 붙이기)">Java StringJoiner (문자열 구분자 붙이기)</a> </li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;p&gt;자바 11이 릴리즈됐습니다. 자바 10이 출시된지 6개월만입니다. 오</summary>
      
    
    
    
    <category term="Programming" scheme="https://futurecreator.github.io/categories/Programming/"/>
    
    <category term="Java" scheme="https://futurecreator.github.io/categories/Programming/Java/"/>
    
    
    <category term="release" scheme="https://futurecreator.github.io/tags/release/"/>
    
    <category term="java_11" scheme="https://futurecreator.github.io/tags/java-11/"/>
    
    <category term="lts" scheme="https://futurecreator.github.io/tags/lts/"/>
    
  </entry>
  
  <entry>
    <title>마이크로서비스 Microservices (2) API 게이트웨이</title>
    <link href="https://futurecreator.github.io/2018/09/14/microservices-with-api-gateway/"/>
    <id>https://futurecreator.github.io/2018/09/14/microservices-with-api-gateway/</id>
    <published>2018-09-14T13:42:41.000Z</published>
    <updated>2025-03-14T16:10:24.208Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>이전 포스트에서 마이크로서비스 아키텍처의 개념을 살펴봤습니다. 이번 포스트에서는 마이크로서비스의 중요한 요소 중 하나인 API 게이트웨이(<em>API Gateway</em>)를 알아보겠습니다.</p><h2 id="서비스-직접-호출하기">서비스 직접 호출하기</h2><p>먼저 대표적인 쇼핑몰 아마존의 모바일 애플리케이션을 예로 들어보겠습니다.</p><p><img src="https://cdn.wp.nginx.com/wp-content/uploads/2016/04/Richardson-microservices-part2-1_amazon-apps.png" alt="https://www.nginx.com/blog/building-microservices-using-an-api-gateway/"></p><p>위 화면은 모바일에서 본 아마존 제품 상세 화면입니다. 간단해보이지만, 실제로 이 안에는 여러 가지 정보와 기능이 담겨있습니다.</p><ul><li>상품 정보</li><li>쇼핑 카트에 담긴 상품 수</li><li>주문 내역</li><li>고객 리뷰</li><li>수량이 얼마 안남았으면 경고 보여주기</li><li>배송 옵션</li><li>다른 사람들이 해당 상품과 같이 구매한 상품 추천</li><li>구매 옵션</li></ul><p>모놀리식 애플리케이션(<em>monolithic application</em>)이라면 한 번의 API 호출로 모든 정보를 가져올 겁니다. REST 요청을 로드 밸런서가 받아서 애플리케이션 인스턴스 중 하나에 전달하고 애플리케이션은 여러 테이블에서 데이터를 가져와 응답을 보내줄 겁니다.</p><p>하지만 마이크로서비스 아키텍처에서는 어떨까요? 각 기능이 서비스로 나뉘어있기 때문에 각 서비스마다 호출이 필요합니다. 예를 들면 다음과 같이 서비스가 나뉘어 있을 겁니다.</p><ul><li>상품 정보, 구매 옵션 -&gt; Catalog Service</li><li>쇼핑 카트에 담긴 상품 수 -&gt; Shopping Cart Service</li><li>주문 내역 -&gt; Order Service</li><li>고객 리뷰 -&gt; Review Service</li><li>수량이 얼마 안남았으면 경고 보여주기 -&gt; Inventory Service</li><li>배송 옵션 -&gt; Shipping Service</li><li>다른 사람들이 해당 상품과 같이 구매한 상품 추천 -&gt; Recommendation Service</li></ul><p>한 번의 호출로 충분했던 모놀리스와 달리, 하나의 페이지를 보여주기 위해 이렇게 많이 서비스를 호출하는 것은 비합리적입니다.</p><p><img src="https://cdn.wp.nginx.com/wp-content/uploads/2016/04/Richardson-microservices-part2-2_microservices-client.png" alt="https://www.nginx.com/blog/building-microservices-using-an-api-gateway/"></p><ul><li>요청이 많이 일어나면서 네트워크 데이터를 많이 소모합니다. 특히나 모바일 환경에서는 더 중요합니다.</li><li>각 서비스의 API 가 웹 친화적(<em>web-friendly</em>)이지 않을 수 있습니다. HTTP 가 아닌 Thrift binary RPC 나 AMQP 메시징 프로토콜을 사용할 수도 있습니다. 이럴 경우 클라이언트에서 직접 호출하기 어렵습니다.</li><li>서비스의 리팩토링이 어려워집니다. 하나의 서비스가 커져서 여러 서비스로 나누거나, 반대로 여러 서비스를 하나의 서비스로 합칠 때 호출단까지 같이 수정해야하기 때문에 작업이 어렵습니다.</li></ul><h2 id="API-게이트웨이-사용하기">API 게이트웨이 사용하기</h2><p>이런 문제를 해결하기 위해 서비스들의 엔드포인트를 하나로 묶을 수 있는 API 게이트웨이가 필요합니다. 각 서비스를 직접 호출하지않고 모든 요청이 API 게이트웨이를 통하게 만드는 것입니다. 예제에서 API 게이트웨이는 하나의 요청에 여러 서비스를 호출한 후 하나의 결과로 취합해서 보내줄 겁니다.</p><p><img src="https://cdn.wp.nginx.com/wp-content/uploads/2016/04/Richardson-microservices-part2-3_api-gateway.png" alt="https://www.nginx.com/blog/building-microservices-using-an-api-gateway/"></p><h3 id="기능과-장점">기능과 장점</h3><p>이러면 API 게이트웨이에서 모든 요청을 볼 수 있기 때문에 한 곳에서 다양한 일을 할 수 있습니다.</p><ul><li>요청에 따라 필요한 서비스로 라우팅합니다.</li><li>모든 서비스의 API 를 노출하는 대신 필요한 API 만을 노출해서 캡슐화할 수 있습니다.</li><li>클라이언트 별로 다른 API 를 제공할 수 있습니다.</li><li>하나의 요청에 필요한 서비스를 각각 호출해 결과를 모아서 응답할 수 있습니다.</li><li>내부에서 사용하는 프로토콜이 다를 경우 외부에는 웹 친화적인 프로토콜(<em>HTTP, WebSocket</em> 등)으로 변환해줍니다.</li><li>클라이언트와의 통신을 줄일 수 있고, 클라이언트의 코드도 단순해집니다.</li><li>권한 인증, 모니터링, 로드 밸런싱, 캐싱, 과금을 위한 측정 등을 한 곳에서 할 수 있습니다.</li></ul><h3 id="단점">단점</h3><p>하나의 엔트리 포인트를 갖는 것은 장점이자 단점입니다.</p><ul><li>API 게이트웨이에서 하는 역할이 많고, 게이트웨이에 장애가 나면 서비스 전체가 사용이 불가능합니다.</li><li>각 서비스의 API 를 수정하면 API 게이트웨이를 함께 수정해야 합니다. 이는 개발 과정에서 병목(<em>bottleneck</em>)이 되어 개발 과정일 지연시킬 수 있습니다.</li><li>API 게이트웨이 또한 개발하고 유지보수해야 할 대상입니다.</li></ul><h2 id="구현-시-고려사항">구현 시 고려사항</h2><h3 id="비동기-반응형-프로그래밍">비동기, 반응형 프로그래밍</h3><p>API 게이트웨이는 많은 요청을 처리하기 위해 비동기(<em>asynchronous</em>), 논블락킹(<em>nonblocking</em>) I/O 기반으로 설계되어야 합니다. 한 요청을 받아 서비스를 호출할 때 해당 서비스가 지연되거나 응답이 없는 경우, 동기(<em>synchronous</em>), 블락킹(<em>blocking</em>) 모델이라면 전체 서비스에 지연이 생길 겁니다. JVM 위에서 동작하는 NIO 기반 프레임워크는 <a href="https://netty.io/">Netty</a>, <a href="https://vertx.io/">Vert.x</a>, <a href="https://projectreactor.io/">Spring Reactor</a> 등이 있습니다. JVM 을 사용하지 않는 환경에서는 대표적으로 <a href="https://nodejs.org/ko/">Node.js</a> 가 있습니다.</p><p>API 를 비동기로 구축하다보면 흔히 ‘콜백 지옥’이라 부르는 얽히고설켜 복잡한 콜백 함수들을 다루게 됩니다. 이럴 땐 반응형 프로그래밍 모델(<em>Reactive programming model</em>)을 고려해보는 것이 좋습니다. 반응형 프로그래밍은 데이터를 다루는 방식이 다릅니다. 기존 프로그램처럼 필요한 데이터를 당겨오는(<em>pull</em>) 방식이 아니라 데이터 변화가 발생했을 때 새로운 데이터를 보내주는(<em>push</em>) 방식입니다.</p><p>리액티브 방식은 스칼라(<em>Scala</em>)의 <a href="https://docs.scala-lang.org/overviews/core/futures.html">Future</a>, 자바 8의 <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html">CompletableFuture</a>, 자바스크립트의 <a href="https://developers.google.com/web/fundamentals/primers/promises?hl=ko">Promise</a> 등을 이용해 구현할 수 있습니다. 그리고 RxJava<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="RxJava 는 넷플릭스(*Netflix*)에서는 REST 기반의 API 호출 횟수와 서비스의 전반적인 성능을 개선하면서 .NET 환경의 리액티브 확장 라이브러리(*Rx*)를 JVM 에 포팅하여 만들었다.">[1]</span></a></sup>, RxJS 와 같은 <a href="http://reactivex.io/">ReactiveX</a> 를 사용하는 것도 좋은 방법입니다.</p><h3 id="프로세스-간-통신">프로세스 간 통신</h3><p>마이크로서비스에서 분산된 서비스가 서로 통신하기 위해서는 프로세스 간 통신(<em>inter-process communication; IPC</em>) 매커니즘이 필요합니다. 각 서비스들이 사용하는 방식이 다를 경우 API 게이트웨이는 다양한 방식을 지원해야 합니다.</p><ul><li>비동기 메시징 기반(<em>asynchronous, messaging‑based mechanism</em>) : <a href="https://en.wikipedia.org/wiki/Java_Message_Service">JMS</a>(<em>Java Message Service</em>), <a href="https://en.wikipedia.org/wiki/Advanced_Message_Queuing_Protocol">AMQP</a>(<em>Advanced Message Queuing Protocol</em>) 등</li><li>동기 방식(<em>synchronous mechanism</em>) : HTTP, <a href="https://thrift.apache.org/">Apache Thrift</a> 등</li></ul><h3 id="서비스-디스커버리">서비스 디스커버리</h3><p>API 게이트웨이는 각 서비스를 호출하기 위해 IP 주소와 포트를 알고 있어야 합니다. 기존 환경에서는 이러한 서버의 위치가 고정이라 문제가 없지만, 클라우드 기반에서는 각 서비스가 동적으로 할당된 서버에 배포되면서 해당 서비스의 위치를 파악하는 것이 어려워졌습니다. 이렇게 해당 서비스의 위치를 찾는 기술을 서비스 디스커버리(<em>Service Discovery</em>)라고 합니다. API 게이트웨이는 서버 사이드, 혹은 클라이언트 사이드 기준으로 서비스 디스커버리를 구현할 수 있습니다.</p><h3 id="부분적인-장애-대처">부분적인 장애 대처</h3><p>마이크로서비스에서 각 서비스는 독립적으로 배포되기 때문에 부분별로 장애가 발생할 수 있습니다. API 게이트웨이는 각 서비스를 호출하면서 해당 서비스에서 장애가 났을 경우 사용자가 경험을 해치지 않도록 매끄럽게 처리해야 합니다. 에러를 던져줄 수도, 에러 화면으로 라우팅할 수도, 또는 기본값이나 캐시된 값을 보여줄 수도 있습니다.</p><h2 id="참고">참고</h2><ul><li><a href="https://www.nginx.com/blog/building-microservices-using-an-api-gateway/">Building Microservices: Using an API Gateway | NGINX</a></li></ul><h2 id="Related-Posts">Related Posts</h2><ul><li><a href="/2018/09/14/what-is-microservices-architecture/" title="마이크로서비스 Microservices (1) 아키텍처 소개">마이크로서비스 Microservices (1) 아키텍처 소개</a></li><li><a href="/2018/09/14/microservices-with-api-gateway/" title="마이크로서비스 Microservices (2) API 게이트웨이">마이크로서비스 Microservices (2) API 게이트웨이</a></li><li><a href="/2018/10/04/inter-process-communication-in-microservices/" title="마이크로서비스 Microservices (3) 프로세스 간 통신">마이크로서비스 Microservices (3) 프로세스 간 통신</a></li><li><a href="/2018/10/18/service-discovery-in-microservices/" title="마이크로서비스 Microservices (4) 서비스 디스커버리">마이크로서비스 Microservices (4) 서비스 디스커버리</a></li><li><a href="/2018/10/19/microservices-and-event-driven-data-management/" title="마이크로서비스 Microservices (5) 이벤트 주도 데이터 관리">마이크로서비스 Microservices (5) 이벤트 주도 데이터 관리</a></li><li><a href="/2018/10/19/microservices-deployment-strategy/" title="마이크로서비스 Microservices (6) 배포 전략">마이크로서비스 Microservices (6) 배포 전략</a></li><li><a href="/2018/10/19/microservices-refactoring-for-monolith/" title="마이크로서비스 Microservices (7) 모놀리스 리팩토링">마이크로서비스 Microservices (7) 모놀리스 리팩토링</a></li></ul><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">RxJava 는 넷플릭스(<em>Netflix</em>)에서는 REST 기반의 API 호출 횟수와 서비스의 전반적인 성능을 개선하면서 .NET 환경의 리액티브 확장 라이브러리(<em>Rx</em>)를 JVM 에 포팅하여 만들었다.<a href="#fnref:1" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;p&gt;이전 포스트에서 마이크로서비스 아키텍처의 개념을 살펴봤습니다. 이번 </summary>
      
    
    
    
    <category term="Programming" scheme="https://futurecreator.github.io/categories/Programming/"/>
    
    <category term="MSA" scheme="https://futurecreator.github.io/categories/Programming/MSA/"/>
    
    
    <category term="msa" scheme="https://futurecreator.github.io/tags/msa/"/>
    
    <category term="microservices" scheme="https://futurecreator.github.io/tags/microservices/"/>
    
    <category term="architecture" scheme="https://futurecreator.github.io/tags/architecture/"/>
    
    <category term="api_gateway" scheme="https://futurecreator.github.io/tags/api-gateway/"/>
    
    <category term="api" scheme="https://futurecreator.github.io/tags/api/"/>
    
  </entry>
  
</feed>
